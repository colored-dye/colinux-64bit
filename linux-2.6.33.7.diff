Index: linux-2.6.25.20-source/drivers/video/console/cocon.c
===================================================================
--- /dev/null
+++ linux-2.6.25.20-source/drivers/video/console/cocon.c
@@ -0,0 +1,488 @@
+/*
+ *  linux/drivers/video/cocon.c -- Cooperative Linux console VGA driver
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file COPYING in the main directory of this archive for
+ *  more details.
+ *
+ *  Based on code copied from vgacon.c.
+ *
+ *  Dan Aloni <da-x@gmx.net>, 2003-2004 (c)
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/string.h>
+#include <linux/kd.h>
+#include <linux/slab.h>
+#include <linux/vt_kern.h>
+#include <linux/selection.h>
+#include <linux/init.h>
+
+#include <linux/cooperative_internal.h>
+
+/*
+ *  Interface used by the world
+ */
+
+static int cocon_cols = 80;
+static int cocon_rows = 25;
+static int cocon_attr = 0x07; /* fg=white, bg=black */
+
+static const char __init *cocon_startup(void)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_STARTUP;
+		co_switch_wrapper();
+		if (message->type == CO_OPERATION_CONSOLE_CONFIG) {
+			cocon_cols = message->config.cols;
+			cocon_rows = message->config.rows;
+			cocon_attr = message->config.attr;
+		}
+		co_passage_page_release(flags);
+	}
+
+	return "CoCON";
+}
+
+static void cocon_init(struct vc_data *c, int init)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	/* We cannot be loaded as a module, therefore init is always 1 */
+	c->vc_can_do_color = 1;
+	c->vc_cols = cocon_cols;
+	c->vc_rows = cocon_rows;
+
+	/* drivers/char/vt.c: Must hack vc_init() for vc_def_color */
+	c->vc_def_color = cocon_attr;
+
+	c->vc_complement_mask = 0x7700;
+	c->vc_visible_origin = 0;
+	c->vc_origin = 0;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_INIT;
+	co_send_message_restore(flags);
+}
+
+static void cocon_deinit(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_DEINIT;
+	co_send_message_restore(flags);
+
+}
+
+static void cocon_clear(struct vc_data *c, int top, int left, int rows, int cols)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->clear + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_CLEAR;
+	message->clear.top = top;
+	message->clear.left = left;
+	message->clear.bottom = top + rows - 1;
+	message->clear.right = left + cols - 1;
+	message->clear.charattr = c->vc_video_erase_char;
+	co_send_message_restore(flags);
+}
+
+static void cocon_putc(struct vc_data *c, int charattr, int y, int x)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putc + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_PUTC;
+	message->putc.x = x;
+	message->putc.y = y;
+	message->putc.charattr = charattr;
+	co_send_message_restore(flags);
+}
+
+
+static void cocon_putcs(struct vc_data *conp,
+			const unsigned short *s, int count, int yy, int xx)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	if (count > CO_MAX_PARAM_SIZE/2 - 16)
+		return;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->putcs + 1)) - ((char *)message) +
+		count * sizeof(unsigned short);
+	message->type = CO_OPERATION_CONSOLE_PUTCS;
+	message->putcs.x = xx;
+	message->putcs.y = yy;
+	message->putcs.count = count;
+	memcpy(&message->putcs.data, s, count * sizeof(unsigned short));
+	co_send_message_restore(flags);
+}
+
+static u8 cocon_build_attr(struct vc_data *c, u8 color, u8 intensity, u8 blink, u8 underline, u8 reverse, u8 italic)
+{
+	u8 attr = color;
+
+	if (underline)
+		attr = (attr & 0xf0) | c->vc_ulcolor;
+	else if (intensity == 0)
+		attr = (attr & 0xf0) | c->vc_halfcolor;
+	if (reverse)
+		attr = ((attr) & 0x88) | ((((attr) >> 4) | ((attr) << 4)) & 0x77);
+	if (blink)
+		attr ^= 0x80;
+	if (intensity == 2)
+		attr ^= 0x08;
+
+	return attr;
+}
+
+static void cocon_invert_region(struct vc_data *c, u16 *p, int count)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+	co_console_message_t *message;
+	unsigned long x = (unsigned long)(p - c->vc_origin);  // UPDATE: vc_origin = 0; but not yet
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->invert + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_INVERT_REGION;
+		message->invert.y = ((unsigned)x)/c->vc_cols;
+		message->invert.x = ((unsigned)x)-(message->invert.y);
+		message->invert.count = count;
+		co_send_message_restore(flags);
+	}
+
+	while (count--) {
+		u16 a = scr_readw(p);
+		a = ((a) & 0x88ff) | (((a) & 0x7000) >> 4) | (((a) & 0x0700) << 4);
+		scr_writew(a, p++);
+        }
+
+}
+
+static void cocon_cursor(struct vc_data *c, int mode)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->cursor + 1)) - ((char *)message);;
+	if (mode==CM_ERASE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_ERASE;
+		message->cursor.height = CUR_NONE;
+		co_send_message_restore(flags);
+		return;
+	}
+
+	if(mode==CM_MOVE) {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_MOVE;
+	} else /*(mode==CM_DRAW)*/ {
+		message->type = CO_OPERATION_CONSOLE_CURSOR_DRAW;
+	}
+	message->cursor.x = c->vc_x;
+	message->cursor.y = c->vc_y;
+	message->cursor.height = c->vc_cursor_type & CUR_HWMASK;
+
+	co_send_message_restore(flags);
+}
+
+static int cocon_switch(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_SWITCH;
+		co_send_message_restore(flags);
+	}
+
+	return 1;	/* Redrawing not needed */
+}
+
+static int cocon_set_palette(struct vc_data *c, unsigned char *table)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_SET_PALETTE;
+		co_send_message_restore(flags);
+	}
+
+	return 1;
+}
+
+static int cocon_blank(struct vc_data *c, int blank, int mode_switchg)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_BLANK;
+		co_send_message_restore(flags);
+	}
+
+	return 1;
+}
+
+
+static int cocon_scrolldelta(struct vc_data *c, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_SCROLLDELTA;
+		co_send_message_restore(flags);
+	}
+
+	return 1;
+}
+
+static int cocon_set_origin(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_SET_ORIGIN;
+		co_send_message_restore(flags);
+	}
+
+	return 1;
+}
+
+static void cocon_save_screen(struct vc_data *c)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->type + 1)) - ((char *)message);
+		message->type = CO_OPERATION_CONSOLE_SAVE_SCREEN;
+		co_send_message_restore(flags);
+	}
+}
+
+static int cocon_scroll(struct vc_data *c, int t, int b, int dir, int lines)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		message = (co_console_message_t *)co_message->data;
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_CONSOLE;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		co_message->size = ((char *)(&message->scroll + 1)) - ((char *)message);
+		if (dir == SM_UP)
+			message->type = CO_OPERATION_CONSOLE_SCROLL_UP;
+		else
+			message->type = CO_OPERATION_CONSOLE_SCROLL_DOWN;
+		message->scroll.top = t;
+		message->scroll.bottom = b-1;
+		message->scroll.lines = lines;
+		message->scroll.charattr = c->vc_video_erase_char;
+		co_send_message_restore(flags);
+	}
+
+	return 0;
+}
+
+static void cocon_bmove(struct vc_data *c, int sy, int sx, int dy, int dx, int h, int w)
+{
+	unsigned long flags;
+	co_console_message_t *message;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (!co_message)
+		return;
+
+	message = (co_console_message_t *)co_message->data;
+	co_message->from = CO_MODULE_LINUX;
+	co_message->to = CO_MODULE_CONSOLE;
+	co_message->priority = CO_PRIORITY_DISCARDABLE;
+	co_message->type = CO_MESSAGE_TYPE_STRING;
+	co_message->size = ((char *)(&message->bmove + 1)) - ((char *)message);
+	message->type = CO_OPERATION_CONSOLE_BMOVE;
+	message->bmove.row = dy;
+	message->bmove.column = dx;
+	message->bmove.top = sy;
+	message->bmove.left = sx;
+	message->bmove.bottom = sy + h - 1;
+	message->bmove.right = sx + w - 1;
+	co_send_message_restore(flags);
+}
+
+static int cocon_resize(struct vc_data *c, unsigned int width,
+				unsigned int height)
+{
+	return -EINVAL;
+}
+
+/*
+ *  The console `switch' structure for the VGA based console
+ */
+
+const struct consw colinux_con = {
+	con_startup:		cocon_startup,
+	con_init:		cocon_init,
+	con_deinit:		cocon_deinit,
+	con_clear:		cocon_clear,
+	con_putc:		cocon_putc,
+	con_putcs:		cocon_putcs,
+	con_cursor:		cocon_cursor,
+	con_scroll:		cocon_scroll,
+	con_bmove:		cocon_bmove,
+	con_switch:		cocon_switch,
+	con_blank:		cocon_blank,
+	con_resize: 		cocon_resize,
+	con_set_palette:	cocon_set_palette,
+	con_scrolldelta:	cocon_scrolldelta,
+	con_set_origin:		cocon_set_origin,
+	con_save_screen:	cocon_save_screen,
+	con_build_attr:		cocon_build_attr,
+	con_invert_region:	cocon_invert_region,
+};
+
+MODULE_LICENSE("GPL");
Serial support

Index: linux-2.6.33-source/drivers/serial/coserial.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/drivers/serial/coserial.c
@@ -0,0 +1,256 @@
+/*
+ *  Copyright (C) 2004 Dan Aloni <da-x@colinux.org>
+ *
+ *  Cooperative Linux Serial Line implementation
+ *
+ *  Compatible with UML, also based on some code from there.
+ *  Also based on The tiny_tty.c example driver by Greg Kroah-Hartman (greg@kroah.com).
+ */
+
+#include <linux/major.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/device.h>
+#include <linux/console.h>
+#include <linux/interrupt.h>
+
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+
+#include <linux/cooperative_internal.h>
+
+static irqreturn_t cocd_interrupt(int irq, void *dev_id);
+
+struct cocd_tty {
+	struct tty_struct	*tty;		/* tty for this device */
+	unsigned		open_count;	/* open()/close() tally */
+};
+
+static struct tty_driver *cocd_driver;
+DECLARE_MUTEX(cocd_sem);
+
+static int cocd_open(struct tty_struct *tty, struct file * filp)
+{
+	struct cocd_tty *cocd;
+
+	down(&cocd_sem);
+
+	if (!(cocd = (struct cocd_tty *)tty->driver_data)) {
+		int ret;
+
+		ret = request_irq(SERIAL_IRQ, &cocd_interrupt, IRQF_SAMPLE_RANDOM, "coserial", NULL);
+		if (ret) {
+			printk(KERN_ERR "COSERIAL: unable to get irq %d", SERIAL_IRQ);
+			up(&cocd_sem);
+			return ret;
+		}
+
+		if(!(cocd = kmalloc(sizeof(*cocd), GFP_KERNEL))) {
+			up(&cocd_sem);
+			return -ENOMEM;
+		}
+
+		cocd->open_count = 0;
+		cocd->tty = tty;
+		tty->driver_data = cocd;
+		tty->low_latency = 1;
+	}
+
+	cocd->open_count++;
+
+	up(&cocd_sem);
+
+	return 0;
+}
+
+static void cocd_close(struct tty_struct *tty, struct file * filp)
+{
+	struct cocd_tty *cocd;
+
+	down(&cocd_sem);
+
+	cocd = (struct cocd_tty *)tty->driver_data;
+	if (!cocd) {
+		printk(KERN_ERR "cocd: close no attached struct\n");
+		goto out;
+	}
+
+	if (--cocd->open_count == 0) {
+		/* last close, clear all */
+		free_irq(SERIAL_IRQ, NULL);
+		tty->driver_data = NULL;
+		cocd->tty = NULL;
+		kfree(cocd);
+	}
+
+out:
+	up(&cocd_sem);
+}
+
+static irqreturn_t cocd_interrupt(int irq, void *dev_id)
+{
+	co_message_node_t *input;
+	co_linux_message_t *message;
+	struct tty_struct *tty;
+	struct cocd_tty *cocd;
+	int len;
+
+	if (!cocd_driver)
+		return IRQ_NONE;
+
+	if (down_trylock(&cocd_sem))
+		return IRQ_NONE;
+
+	if(!co_get_message(&input, CO_DEVICE_SERIAL))
+		goto out;
+
+	if(!input)
+		goto out;
+
+	message = (co_linux_message_t *)&input->msg.data;
+	if (message->unit < CO_MODULE_MAX_SERIAL
+	 && (tty = cocd_driver->ttys[message->unit])
+	 && (cocd = (struct cocd_tty *)tty->driver_data)) {
+		up(&cocd_sem);
+
+		len = tty_insert_flip_string(tty, message->data, message->size);
+		if (len)
+			tty_flip_buffer_push(tty);
+
+		co_free_message(input);
+		return IRQ_HANDLED;
+	}
+	co_free_message(input); /* message lost */
+out:
+	up(&cocd_sem);
+	return IRQ_NONE;
+}
+
+static int do_cocd_write(int index, const char *buf, unsigned count)
+{
+	const char *kbuf_scan = buf;
+	int count_left = count;
+
+	while (count_left > 0) {
+		int count_partial = count_left;
+		if (count_partial > 1000)
+			count_partial = 1000;
+
+		co_send_message(CO_MODULE_LINUX,
+				CO_MODULE_SERIAL0 + index,
+				CO_PRIORITY_DISCARDABLE,
+				CO_MESSAGE_TYPE_STRING,
+				count_partial,
+				kbuf_scan);
+
+		count_left -= count_partial;
+		kbuf_scan += count_partial;
+	}
+
+	return count;
+}
+
+
+static int cocd_write(struct tty_struct * tty, const unsigned char *buf, int count)
+{
+	return do_cocd_write(tty->index, buf, count);
+}
+
+static int cocd_write_room(struct tty_struct *tty)
+{
+	struct cocd_tty *cocd = (struct cocd_tty *)tty->driver_data;
+	if (!cocd)
+		return -ENODEV;
+	return 255;
+}
+
+static void cocd_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
+{
+}
+
+static struct tty_operations cocd_ops = {
+	.open = cocd_open,
+	.close = cocd_close,
+	.write = cocd_write,
+	.write_room = cocd_write_room,
+	.set_termios = cocd_set_termios,
+};
+
+static int __init cocd_init(void)
+{
+	int retval;
+
+	cocd_driver = alloc_tty_driver(CO_MODULE_MAX_SERIAL);
+	if (!cocd_driver) {
+		printk(KERN_ERR "Couldn't allocate cocd driver");
+		return -ENOMEM;
+	}
+
+	cocd_driver->owner = THIS_MODULE;
+	cocd_driver->driver_name = "coserial";
+	cocd_driver->name = "ttyS";
+	cocd_driver->major = TTY_MAJOR;
+	cocd_driver->minor_start = 64;
+	cocd_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	cocd_driver->subtype = SERIAL_TYPE_NORMAL;
+	cocd_driver->init_termios = tty_std_termios;
+	cocd_driver->flags = 0;
+
+	tty_set_operations(cocd_driver, &cocd_ops);
+
+	retval = tty_register_driver(cocd_driver);
+	if (retval) {
+		printk(KERN_ERR "Couldn't register cocd driver");
+		put_tty_driver(cocd_driver);
+		return retval;
+	}
+
+	return 0;
+}
+
+static void __exit cocd_exit(void)
+{
+	tty_unregister_driver(cocd_driver);
+	put_tty_driver(cocd_driver);
+}
+
+module_init(cocd_init);
+module_exit(cocd_exit);
+
+/*
+ * ------------------------------------------------------------
+ * Serial console driver
+ * ------------------------------------------------------------
+ */
+#ifdef CONFIG_SERIAL_COOPERATIVE_CONSOLE
+static void cocd_console_write(struct console *c, const char *buf,  unsigned count)
+{
+	do_cocd_write(c->index, buf, count);
+}
+
+static struct tty_driver *cocd_console_device(struct console *c, int *index)
+{
+        *index = c->index;
+        return cocd_driver;
+}
+
+static struct console cocd_cons = {
+        name:           "ttyS",
+        write:          cocd_console_write,
+        device:         cocd_console_device,
+        flags:          CON_PRINTBUFFER,
+        index:          -1,
+};
+
+/*
+ *	Register console.
+ */
+static int __init cocd_console_init(void)
+{
+	register_console(&cocd_cons);
+	return 0;
+}
+console_initcall(cocd_console_init);
+#endif /* CONFIG_SERIAL_COOPERATIVE_CONSOLE */
Index: linux-2.6.22-source/drivers/net/conet.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/drivers/net/conet.c
@@ -0,0 +1,444 @@
+/*
+ *  Copyright (C) 2003-2004 Dan Aloni <da-x@gmx.net>
+ *  Copyright (C) 2004 Pat Erley
+ *  Copyright (C) 2004 George Boutwell
+ *  Copyright (C) 2007 Steve Shoecraft <sshoecraft@earthlink.net>
+ *
+ *  Cooperative Linux Network Device implementation
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/kernel.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/pci.h>
+
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
+#include <asm/irq.h>
+
+#define DRV_NAME 	"conet"
+#define DRV_VERSION	"1.02"
+
+struct conet_priv {
+	struct net_device_stats stats;
+	int unit;
+	unsigned short flags;
+	struct pci_dev *pdev;
+	spinlock_t rx_lock;
+	spinlock_t ioctl_lock;
+	struct mii_if_info mii_if;
+};
+
+#define CONET_FLAG_ENABLED	0x01
+#define CONET_FLAG_HANDLING	0x02
+#define CONET_FLAG_DEBUG	0x80
+
+static struct net_device *conet_dev[CO_MODULE_MAX_CONET];
+
+static int conet_open(struct net_device *dev)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	if (priv->flags & CONET_FLAG_ENABLED) return 0;
+
+	priv->flags |= CONET_FLAG_ENABLED;
+
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static int conet_stop(struct net_device *dev)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	priv->flags &= ~CONET_FLAG_ENABLED;
+
+	netif_stop_queue(dev);
+
+	return 0;
+}
+
+static int conet_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	char *data;
+	struct conet_priv *priv = netdev_priv(dev);
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	data = skb->data;
+
+	dev->trans_start = jiffies; /* save the timestamp */
+
+	co_send_message(CO_MODULE_LINUX,
+			CO_MODULE_CONET0 + priv->unit,
+			CO_PRIORITY_DISCARDABLE,
+			CO_MESSAGE_TYPE_OTHER,
+			len,
+			data);
+
+	priv->stats.tx_bytes+=skb->len;
+	priv->stats.tx_packets++;
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+static void conet_rx(struct net_device *dev, co_linux_message_t *message)
+{
+	struct sk_buff *skb;
+	struct conet_priv *priv = netdev_priv(dev);
+	int len;
+	unsigned char *buf;
+
+	len = message->size;
+	if (len > 0x10000) {
+		printk("conet rx: buggy network reception\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	buf = message->data;
+
+	/*
+	 * The packet has been retrieved from the transmission
+	 * medium. Build an skb around it, so upper layers can handle it
+	 */
+	skb = dev_alloc_skb(len+2);
+	if (!skb) {
+		printk("conet rx: low on mem - packet dropped\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	memcpy(skb_put(skb, len), buf, len);
+
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_NONE; /* make the kernel calculate and verify
+                                           the checksum */
+
+	priv->stats.rx_bytes += len;
+	priv->stats.rx_packets++;
+
+	netif_rx(skb);
+	return;
+}
+
+static irqreturn_t conet_interrupt(int irq, void *dev_id)
+{
+	co_message_node_t *node_message;
+
+	while (co_get_message(&node_message, CO_DEVICE_NETWORK)) {
+		struct net_device *dev;
+		struct conet_priv *priv;
+		co_linux_message_t *message;
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+		if (message->unit >= CO_MODULE_MAX_CONET) {
+			printk("conet interrupt: buggy network reception unit %d\n", message->unit);
+			return IRQ_HANDLED;
+		}
+
+		dev = conet_dev[message->unit];
+		if (!dev) {
+			co_free_message(node_message);
+			continue;
+		}
+
+		if (!netif_running(dev)) {
+			co_free_message(node_message);
+			continue;
+		}
+
+		if (node_message->msg.type == CO_MESSAGE_TYPE_STRING) {
+			int connected= *(int*)(message+1);
+			if (connected)
+				netif_carrier_on(dev);
+			else
+				netif_carrier_off(dev);
+			co_free_message(node_message);
+			continue;
+		}
+
+		priv = netdev_priv(dev);
+		spin_lock(&priv->rx_lock);
+#if 0
+		if (priv->flags & CONET_FLAG_HANDLING) {
+			co_free_message(node_message);
+			continue;
+		}
+
+		priv->flags |= CONET_FLAG_HANDLING;
+		conet_rx(dev, message);
+		co_free_message(node_message);
+		priv->flags &= ~CONET_FLAG_HANDLING;
+#endif
+		conet_rx(dev, message);
+		co_free_message(node_message);
+		spin_unlock(&priv->rx_lock);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct net_device_stats* conet_get_stats(struct net_device *dev)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	return &priv->stats;
+}
+
+static int conet_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	/* We support 100-baseT Full duplex TP */
+	cmd->port = PORT_TP;
+	cmd->duplex = DUPLEX_FULL;
+	cmd->supported = SUPPORTED_TP | SUPPORTED_100baseT_Full;
+	cmd->speed = SPEED_100;
+	return 0;
+}
+
+static int conet_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	/* We support TP Full duplex 100 */
+	if (cmd->port != PORT_TP || cmd->duplex != DUPLEX_FULL || cmd->speed != SPEED_100)
+		return -EOPNOTSUPP;
+	return 0;
+}
+
+static void conet_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	strcpy(info->driver, DRV_NAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, pci_name(priv->pdev));
+}
+
+static u32 conet_get_link(struct net_device *dev)
+{
+	/* Always connected */
+	return 1;
+}
+
+static u32 conet_get_msglevel(struct net_device *dev)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+        return ((priv->flags & CONET_FLAG_DEBUG) != 0);
+}
+
+static void conet_set_msglevel(struct net_device *dev, u32 level)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	if (level)
+		priv->flags |= CONET_FLAG_DEBUG;
+	else
+		priv->flags &= ~CONET_FLAG_DEBUG;
+}
+
+static int conet_mdio_read(struct net_device *dev, int id, int reg)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+	int val;
+
+	if (priv->flags & CONET_FLAG_DEBUG)
+		printk(KERN_INFO "conet%d: mdio_read: id: %d, reg: %d\n", priv->unit, id, reg);
+	switch(reg) {
+	case MII_BMCR:			/* Basic mode control register */
+		val = BMCR_FULLDPLX | BMCR_SPEED100;
+		break;
+	case MII_BMSR:			/* Basic mode status register  */
+		val = BMSR_LSTATUS | BMSR_100FULL;
+		break;
+	default:
+		val = 0;
+		break;
+	}
+	return val;
+}
+
+static void conet_mdio_write(struct net_device *dev, int id, int reg, int val)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+
+	if (priv->flags & CONET_FLAG_DEBUG)
+		printk(KERN_INFO "conet%d: mdio_write: id: %d, reg: %d, val: %d\n", priv->unit, id, reg, val);
+	return;
+}
+
+static int conet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	struct conet_priv *priv = netdev_priv(dev);
+	int rc;
+
+	spin_lock(&priv->ioctl_lock);
+	rc = generic_mii_ioctl(&priv->mii_if, if_mii(rq), cmd, NULL);
+	spin_unlock(&priv->ioctl_lock);
+
+	return rc;
+}
+
+static const struct ethtool_ops conet_ethtool_ops = {
+	.get_settings           = conet_get_settings,
+	.set_settings           = conet_set_settings,
+	.get_drvinfo            = conet_get_drvinfo,
+	.get_link               = conet_get_link,
+	.get_msglevel           = conet_get_msglevel,
+	.set_msglevel           = conet_set_msglevel,
+#if 0
+	.nway_reset             = conet_nway_reset,
+	.get_ringparam          = conet_get_ringparam,
+	.set_ringparam          = conet_set_ringparam,
+	.get_tx_csum            = ethtool_op_get_tx_csum,
+	.get_sg                 = ethtool_op_get_sg,
+	.get_tso                = ethtool_op_get_tso,
+	.get_strings            = conet_get_strings,
+	.self_test_count        = conet_self_test_count,
+	.self_test              = conet_ethtool_test,
+	.phys_id                = conet_phys_id,
+	.get_regs_len           = conet_get_regs_len,
+	.get_regs               = conet_get_regs,
+	.get_perm_addr          = ethtool_op_get_perm_addr,
+#endif
+};
+
+static struct pci_device_id conet_pci_ids[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_CONET) },
+	{ 0 }
+};
+
+MODULE_DEVICE_TABLE(pci, conet_pci_ids);
+
+static int __devinit conet_pci_probe( struct pci_dev *pdev,
+                                    const struct pci_device_id *ent)
+{
+	u8 unit, addr[6];
+	struct net_device *dev;
+	struct conet_priv *priv;
+	int rc;
+
+//	printk(KERN_INFO "CONET: probing!\n");
+
+	unit = -1;
+	pci_read_config_byte(pdev, PCI_CO_UNIT, &unit);
+	pci_read_config_byte(pdev, PCI_CO_MAC1, &addr[0]);
+	pci_read_config_byte(pdev, PCI_CO_MAC2, &addr[1]);
+	pci_read_config_byte(pdev, PCI_CO_MAC3, &addr[2]);
+	pci_read_config_byte(pdev, PCI_CO_MAC4, &addr[3]);
+	pci_read_config_byte(pdev, PCI_CO_MAC5, &addr[4]);
+	pci_read_config_byte(pdev, PCI_CO_MAC6, &addr[5]);
+
+	dev = alloc_etherdev(sizeof(*priv));
+	if (dev == NULL) {
+		printk(KERN_ERR "conet%d: could not allocate memory for device.\n", unit);
+		rc = -ENOMEM;
+		goto error_out_pdev;
+	}
+	SET_MODULE_OWNER(dev);
+	SET_NETDEV_DEV(dev, &pdev->dev);
+	memcpy(dev->dev_addr, addr, 6);
+
+	dev->open = conet_open;
+	dev->stop = conet_stop;
+	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->ethtool_ops = &conet_ethtool_ops;
+	dev->get_stats = conet_get_stats;
+	dev->do_ioctl = conet_ioctl;
+	dev->irq = pdev->irq;
+
+	priv = netdev_priv(dev);
+	priv->unit = unit;
+	priv->pdev = pdev;
+
+	spin_lock_init(&priv->ioctl_lock);
+	spin_lock_init(&priv->rx_lock);
+
+	priv->mii_if.full_duplex = 1;
+	priv->mii_if.phy_id_mask = 0x1f;
+	priv->mii_if.reg_num_mask = 0x1f;
+	priv->mii_if.dev = dev;
+	priv->mii_if.mdio_read = conet_mdio_read;
+	priv->mii_if.mdio_write = conet_mdio_write;
+	priv->mii_if.phy_id = 1;
+
+	pci_set_drvdata(pdev, priv);
+
+	rc = register_netdev(dev);
+	if (rc) {
+		printk(KERN_ERR "conet%d: could not register device; rc: %d\n", unit, rc);
+		goto error_out_dev;
+	}
+
+	conet_dev[unit] = dev;
+
+	printk(KERN_INFO "conet%d: irq %d, HWAddr %02x:%02x:%02x:%02x:%02x:%02x\n",
+		unit, NETWORK_IRQ, addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+	return 0;
+
+error_out_dev:
+	free_netdev(dev);
+
+error_out_pdev:
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	return rc;
+}
+
+static void __devexit conet_pci_remove(struct pci_dev *pdev)
+{
+	struct conet_priv *priv = dev_get_drvdata(&pdev->dev);
+	struct net_device *net_dev = conet_dev[priv->unit];
+
+	unregister_netdev(net_dev);
+	free_netdev(net_dev);
+	dev_set_drvdata(&pdev->dev, NULL);
+}
+
+static struct pci_driver conet_pci_driver = {
+	.name           = DRV_NAME,
+	.id_table       = conet_pci_ids,
+	.probe          = conet_pci_probe,
+	.remove         = __devexit_p(conet_pci_remove),
+};
+
+static int __init conet_pci_init(void)
+{
+	int unit, rc;
+
+//	printk(KERN_INFO "CONET: Initializing...\n");
+
+	rc = request_irq(NETWORK_IRQ, &conet_interrupt, IRQF_SAMPLE_RANDOM, "conet", NULL);
+	if (rc) {
+		printk(KERN_ERR "CONET: unable to get irq %d", NETWORK_IRQ);
+		return rc;
+	}
+
+	/* Init our units */
+	for (unit=0; unit < CO_MODULE_MAX_CONET; unit++)
+		conet_dev[unit] = NULL;
+
+//	printk(KERN_INFO "CONET: registering...\n");
+        return pci_register_driver(&conet_pci_driver);
+}
+
+static void __exit conet_pci_exit(void)
+{
+        pci_unregister_driver(&conet_pci_driver);
+}
+
+module_init(conet_pci_init);
+module_exit(conet_pci_exit);
Index: linux-2.6.25-source/drivers/block/cobd.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/drivers/block/cobd.c
@@ -0,0 +1,574 @@
+/*
+ *  Copyright (C) 2003 Dan Aloni <da-x@colinux.org>
+ *
+ *  Cooperative Linux Block Device implementation
+ */
+
+#include <linux/major.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/bio.h>
+#include <linux/blkdev.h>
+#include <linux/cooperative_internal.h>
+#include <linux/file.h>
+#include <linux/ioctl.h>
+#include <linux/ctype.h>
+#include <linux/interrupt.h>
+
+#include <asm/uaccess.h>
+#include <asm/types.h>
+
+static int const hardsect_size = 512;
+static int const hardsect_size_shift = 9;
+static int const cobd_max = CO_MODULE_MAX_COBD;
+static spinlock_t cobd_lock = SPIN_LOCK_UNLOCKED;
+
+struct cobd_device {
+	int unit;
+	int refcount;
+	struct block_device *device;
+};
+
+static struct gendisk **cobd_disks;
+static struct cobd_device cobd_devs[CO_MODULE_MAX_COBD];
+
+static int cobd_request(struct cobd_device *cobd, co_block_request_type_t type, co_block_request_t *out_request)
+{
+	co_block_request_t *request;
+	unsigned long flags;
+	long rc;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	request = (co_block_request_t *)&co_passage_page->params[2];
+	request->type = type;
+	request->rc = -1;
+	co_switch_wrapper();
+	rc = request->rc;
+	*out_request = *request;
+	co_passage_page_release(flags);
+
+	return rc;
+}
+
+static int cobd_stat(struct cobd_device *cobd, co_block_request_t *out_request)
+{
+	return cobd_request(cobd, CO_BLOCK_STAT, out_request);
+}
+
+static int cobd_get_alias(struct cobd_device *cobd, co_block_request_t *out_request)
+{
+	return cobd_request(cobd, CO_BLOCK_GET_ALIAS, out_request);
+}
+
+static int cobd_ioctl(struct inode * inode, struct file * file,
+		      unsigned int cmd, unsigned long arg)
+{
+	return -ENOTTY; /* unknown command */
+}
+
+static int cobd_open(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	co_block_request_t stat_request;
+	unsigned long flags;
+	int result;
+
+	if (cobd->device  &&  cobd->device != inode->i_bdev)
+		return -EBUSY;
+
+	if (cobd->refcount == 0) {
+		if (cobd_stat(cobd, &stat_request)) {
+			return -ENODEV;
+		}
+	}
+
+	result = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_OPEN;
+	co_switch_wrapper();
+	if (co_request->rc)
+		result = -EIO;
+	else
+		cobd->refcount++;
+	co_passage_page_release(flags);
+
+	if (result)
+		return result;
+
+	if (cobd->refcount == 1) {
+		set_capacity(inode->i_bdev->bd_disk, stat_request.disk_size >> hardsect_size_shift);
+		cobd->device = inode->i_bdev;
+	}
+
+	return 0;
+}
+
+static int cobd_release(struct inode *inode, struct file *file)
+{
+	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret = 0;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = CO_BLOCK_CLOSE;
+	co_switch_wrapper();
+	if (co_request->rc)
+		ret = -EIO;
+	cobd->refcount--;
+	co_passage_page_release(flags);
+
+	if (cobd->refcount == 0)
+		cobd->device = NULL;
+
+	return ret;
+}
+
+/*
+ * Handle an I/O request.
+ */
+static int cobd_transfer(struct cobd_device *cobd, struct request *req, int *async)
+{
+	co_block_request_t *co_request;
+	unsigned long flags;
+	int ret;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_BLOCK;
+	co_passage_page->params[1] = cobd->unit;
+	co_request = (co_block_request_t *)&co_passage_page->params[2];
+	co_request->type = (rq_data_dir(req) == READ) ? CO_BLOCK_READ : CO_BLOCK_WRITE;
+	co_request->irq_request = req;
+	co_request->offset = ((unsigned long long)(req->sector)) << hardsect_size_shift;
+	co_request->size = req->current_nr_sectors << hardsect_size_shift;
+	co_request->address = req->buffer;
+	co_request->rc = 0;
+	co_request->async = 0;
+	co_switch_wrapper();
+	*async = co_request->async;
+	ret = co_request->rc;
+
+	co_passage_page_release(flags);
+	return ret;
+}
+
+static void do_cobd_request(request_queue_t *q)
+{
+        struct request *req;
+	struct cobd_device *cobd;
+
+        while ((req = elv_next_request(q)) != NULL) {
+		int ret;
+		int async;
+
+		if (!blk_fs_request(req)) {
+			end_request(req, 0);
+			continue;
+		}
+		cobd = (struct cobd_device *)(req->rq_disk->private_data);
+
+		ret = cobd_transfer(cobd, req, &async);
+
+		/*
+		 * OK:   ret ==  0 --> uptodate = 1
+		 * FAIL: ret == -1 --> uptodate = 0
+		 */
+		if (ret == CO_BLOCK_REQUEST_RETCODE_OK) {
+			if (async)
+				break; /* wait for interrupt */
+			end_request(req, 1);
+		} else {
+			end_request(req, 0);
+		}
+        }
+}
+
+static irqreturn_t cobd_interrupt(int irq, void *dev_id)
+{
+	co_message_node_t *input;
+
+	while (co_get_message(&input, CO_DEVICE_BLOCK)) {
+		co_linux_message_t *message;
+		co_block_intr_t *intr;
+		struct request *req;
+
+		message = (co_linux_message_t *)&input->msg.data;
+		if (message->unit >= CO_MODULE_MAX_COBD) {
+			printk("cobd interrupt: buggy unit reception: %x\n", message->unit);
+			goto goto_next_message;
+		}
+
+		BUG_ON(message->size != sizeof(co_block_intr_t));
+		intr = (co_block_intr_t *)message->data;
+		req = intr->irq_request;
+		BUG_ON(!req);
+
+		spin_lock(&cobd_lock);
+		end_request(req, intr->uptodate);
+		do_cobd_request(req->q);
+		spin_unlock(&cobd_lock);
+
+goto_next_message:
+		co_free_message(input);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static struct block_device_operations cobd_fops = {
+	.owner   = THIS_MODULE,
+	.open    = cobd_open,
+	.release = cobd_release,
+	.ioctl   = cobd_ioctl,
+};
+
+static int __init cobd_drives_init(void)
+{
+	int result, i;
+
+	if (request_irq(BLOCKDEV_IRQ, &cobd_interrupt, 0, "cobd", NULL)) {
+		printk("cobd: unable to get IRQ%d\n", BLOCKDEV_IRQ);
+		return -EBUSY;
+	}
+
+	if (register_blkdev(COLINUX_MAJOR, "cobd")) {
+		printk(KERN_WARNING "Unable to get major number %d for cobd device\n", COLINUX_MAJOR);
+		result = -EIO;
+		goto fail_irq;
+	}
+
+	result = -ENOMEM; /* for the possible errors */
+
+	cobd_disks = kmalloc(cobd_max * sizeof(struct gendisk *), GFP_KERNEL);
+	if (!cobd_disks)
+		goto fail_malloc;
+
+	for (i=0; i < cobd_max; i++) {
+		cobd_disks[i] = alloc_disk(1);
+		if (!cobd_disks[i])
+			goto fail_malloc3;
+	}
+
+	for (i=0; i < cobd_max; i++) {
+		struct cobd_device *cobd = &cobd_devs[i];
+		struct gendisk *disk = cobd_disks[i];
+
+		disk->queue = blk_init_queue(do_cobd_request, &cobd_lock);
+		if (!disk->queue)
+			goto fail_malloc4;
+
+		blk_queue_hardsect_size(disk->queue, hardsect_size);
+
+		cobd->unit = i;
+		disk->major = COLINUX_MAJOR;
+		disk->first_minor = i;
+		disk->fops = &cobd_fops;
+		sprintf(disk->disk_name, "cobd%d", i);
+		disk->private_data = cobd;
+	}
+
+	for (i=0; i < cobd_max; i++)
+		add_disk(cobd_disks[i]);
+
+	printk(KERN_INFO "cobd: loaded (max %d devices)\n", cobd_max);
+	return 0;
+
+/* error path */
+fail_malloc4:
+	while (i--)
+		blk_cleanup_queue(cobd_disks[i]->queue);
+	i = cobd_max;
+
+fail_malloc3:
+	while (i--)
+		if (cobd_disks[i] != NULL)
+			put_disk(cobd_disks[i]);
+
+	kfree(cobd_disks);
+
+fail_malloc:
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+fail_irq:
+	free_irq(BLOCKDEV_IRQ, NULL);
+	return result;
+}
+
+struct cobd_alias_major {
+	const char *name;
+	int registered;
+	int number;
+};
+
+struct cobd_alias {
+	const char *name;
+	struct cobd_alias_major *major;
+	int minor_start;
+	int minor_count;
+	struct gendisk **gendisk;
+};
+
+struct cobd_alias_major cobd_aliases_major_ide0 = {
+	.name = "ide0",
+	.number = IDE0_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide1 = {
+	.name = "ide1",
+	.number = IDE1_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide2 = {
+	.name = "ide2",
+	.number = IDE2_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_ide3 = {
+	.name = "ide3",
+	.number = IDE3_MAJOR,
+};
+
+struct cobd_alias_major cobd_aliases_major_sd = {
+	.name = "sd",
+	.number = SCSI_DISK0_MAJOR,
+};
+
+struct cobd_alias cobd_aliases[] = {
+	{"hda", &cobd_aliases_major_ide0, 0x00, 21, },
+	{"hdb", &cobd_aliases_major_ide0, 0x40, 21, },
+	{"hdc", &cobd_aliases_major_ide1, 0x00, 21, },
+	{"hdd", &cobd_aliases_major_ide1, 0x40, 21, },
+	{"hde", &cobd_aliases_major_ide2, 0x00, 21, },
+	{"hdf", &cobd_aliases_major_ide2, 0x40, 21, },
+	{"hdg", &cobd_aliases_major_ide3, 0x00, 21, },
+	{"hdh", &cobd_aliases_major_ide3, 0x40, 21, },
+	{"sda", &cobd_aliases_major_sd, 0x00, 0x10, },
+	{"sdb", &cobd_aliases_major_sd, 0x10, 0x10, },
+	{"sdc", &cobd_aliases_major_sd, 0x20, 0x10, },
+	{"sdd", &cobd_aliases_major_sd, 0x30, 0x10, },
+	{"sde", &cobd_aliases_major_sd, 0x40, 0x10, },
+	{"sdf", &cobd_aliases_major_sd, 0x50, 0x10, },
+	{"sdg", &cobd_aliases_major_sd, 0x60, 0x10, },
+	{"sdh", &cobd_aliases_major_sd, 0x70, 0x10, },
+	{"sdi", &cobd_aliases_major_sd, 0x80, 0x10, },
+	{"sdj", &cobd_aliases_major_sd, 0x90, 0x10, },
+	{"sdk", &cobd_aliases_major_sd, 0xa0, 0x10, },
+	{"sdl", &cobd_aliases_major_sd, 0xb0, 0x10, },
+	{"sdm", &cobd_aliases_major_sd, 0xc0, 0x10, },
+	{"sdn", &cobd_aliases_major_sd, 0xd0, 0x10, },
+	{"sdo", &cobd_aliases_major_sd, 0xe0, 0x10, },
+	{"sdp", &cobd_aliases_major_sd, 0xf0, 0x10, },
+	{NULL, },
+};
+
+static int __init skip_atoi(const char **s)
+{
+	/* lib/spprintf.h */
+
+        int i=0;
+
+        while (isdigit(**s))
+                i = i*10 + *((*s)++) - '0';
+
+        return i;
+}
+
+static int __init cobd_spawn_alias(struct cobd_alias *alias,
+				   const char *alias_name_requested,
+				   int cobd_unit)
+{
+	const char *index_str_start = &alias_name_requested[strlen(alias->name)];
+	const char *index_str_end = index_str_start;
+	struct cobd_device *cobd;
+	struct gendisk *disk;
+
+	int index = skip_atoi(&index_str_end);
+
+	if (!((index >= 0) && (index <= alias->minor_count))) {
+		printk(KERN_WARNING "index out of bounds for alias %s (1 - %d)\n",
+		       alias_name_requested, alias->minor_count);
+		return -1;
+	}
+
+	if (alias->gendisk == NULL) {
+		static struct gendisk **gendisks;
+
+		gendisks = kzalloc(alias->minor_count * sizeof(struct gendisk *), GFP_KERNEL);
+		if (!gendisks) {
+			printk(KERN_WARNING "cannot allocate gendisk array for %s\n", alias->name);
+			return -ENOMEM;
+		}
+
+		if (!alias->major->registered) {
+			if (register_blkdev(alias->major->number, alias->major->name)) {
+				printk(KERN_WARNING "unable to get major number %d for cobd alias device %s\n",
+				       alias->major->number, alias_name_requested);
+				kfree(gendisks);
+				return -EIO;
+			}
+
+			alias->major->registered = 1;
+		}
+
+		alias->gendisk = gendisks;
+	}
+
+	if (alias->gendisk[index] != NULL) {
+		printk(KERN_WARNING "alias %s already used\n", alias_name_requested);
+		return -1;
+	}
+
+	disk = alloc_disk(1);
+	if (!disk) {
+		printk(KERN_WARNING "cannot allocate disk for alias %s\n", alias_name_requested);
+		return -1;
+	}
+
+	disk->queue = blk_init_queue(do_cobd_request, &cobd_lock);
+	if (!disk->queue) {
+		printk(KERN_WARNING "cannot allocate init queue for alias %s\n", alias_name_requested);
+		put_disk(disk);
+		return -1;
+	}
+
+	cobd = &cobd_devs[cobd_unit];
+	blk_queue_hardsect_size(disk->queue, hardsect_size);
+	disk->major = alias->major->number;
+	disk->first_minor = alias->minor_start + index;
+	disk->fops = &cobd_fops;
+	if (index)
+		sprintf(disk->disk_name, "%s%d", alias->name, index);
+	else
+		sprintf(disk->disk_name, "%s", alias->name);
+	disk->private_data = cobd;
+	add_disk(disk);
+	alias->gendisk[index] = disk;
+
+	printk("cobd alias cobd%d -> %s created\n", cobd_unit, alias_name_requested);
+
+	return 0;
+}
+
+static void __init cobd_aliases_init(void)
+{
+	int unit;
+	co_block_request_t request;
+
+	for (unit=0; unit < cobd_max; unit++) {
+		struct cobd_alias *alias = cobd_aliases;
+		int result = cobd_get_alias(&cobd_devs[unit], &request);
+		if (result)
+			continue;
+
+		printk("alias for cobd%d is %s\n", unit, request.alias);
+
+		while (alias->name) {
+			const char *match = (strstr(request.alias, alias->name));
+			if (match == request.alias) {
+				cobd_spawn_alias(alias, request.alias, unit);
+				break;
+			}
+			alias++;
+		}
+
+		if (alias->name == NULL)
+			printk("alias %s is unknown (see cobd_aliases in cobd.c)\n", request.alias);
+	}
+}
+
+static void cobd_drives_exit(void)
+{
+	int i;
+
+	for (i = 0; i < cobd_max; i++) {
+		blk_cleanup_queue(cobd_disks[i]->queue);
+		del_gendisk(cobd_disks[i]);
+		put_disk(cobd_disks[i]);
+	}
+
+	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
+		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+
+	free_irq(BLOCKDEV_IRQ, NULL);
+	kfree(cobd_disks);
+}
+
+static void cobd_aliases_exit(void)
+{
+	struct cobd_alias *alias = &cobd_aliases[0];
+	while (alias->name != NULL) {
+		int index;
+		if (alias->gendisk == NULL) {
+			alias++;
+			continue;
+		}
+
+		for (index=0; index < alias->minor_count; index++) {
+			struct gendisk *disk = alias->gendisk[index];
+			if (!disk)
+				return;
+
+			blk_cleanup_queue(disk->queue);
+			del_gendisk(disk);
+			put_disk(disk);
+		}
+
+		if (!alias->major->registered) {
+			unregister_blkdev(alias->major->number, alias->major->name);
+			alias->major->registered = 0;
+		}
+		kfree(alias->gendisk);
+
+		alias++;
+	}
+}
+
+static int __init cobd_init(void)
+{
+	int result = cobd_drives_init();
+	if (result)
+		return result;
+
+	cobd_aliases_init();
+
+	return result;
+}
+
+static void cobd_exit(void)
+{
+	cobd_aliases_exit();
+	cobd_drives_exit();
+}
+
+module_init(cobd_init);
+module_exit(cobd_exit);
+
+
Index: linux-2.6.22-source/drivers/input/serio/cokbd.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/drivers/input/serio/cokbd.c
@@ -0,0 +1,133 @@
+/*
+ *  Cooperative Linux virtual keyboard controller driver
+ *
+ *  Copyright (c) 1999-2002 Dan Aloni <da-x@colinux.org)
+ *    Based on 98kbd-io.c written by Osamu Tomita>
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/serio.h>
+#include <linux/sched.h>
+#include <linux/kbd_kern.h>
+#include <linux/cooperative_internal.h>
+
+#include <asm/io.h>
+
+MODULE_AUTHOR("Dan Aloni <da-x@colinux.org>");
+MODULE_DESCRIPTION("Cooperative Linux virtual keyboard controller driver");
+MODULE_LICENSE("GPL");
+
+/*
+ * Names.
+ */
+
+#define COKBD_PHYS_DESC        "cokbd"
+
+static struct serio cokbd_port;
+
+static irqreturn_t cokbdio_interrupt(int irq, void *dev_id);
+
+/*
+ * cokbd_write() sends a byte out through the keyboard interface.
+ */
+
+#define ATKBD_CMD_GETID		0x02f2
+
+static int cokbd_write(struct serio *port, unsigned char c)
+{
+	return 0;
+}
+
+/*
+ * cokbd_open() is called when a port is open by the higher layer.
+ * It allocates the interrupt and enables in in the chip.
+ */
+
+static int cokbd_open(struct serio *port)
+{
+	if (request_irq(KEYBOARD_IRQ, cokbdio_interrupt, 0, "cokbd", NULL)) {
+		printk(KERN_ERR "cobkd.c: Can't get irq %d for %s, unregistering the port.\n", KEYBOARD_IRQ, "KBD");
+		serio_unregister_port(port);
+		return -1;
+	}
+
+	return 0;
+}
+
+static void cokbd_close(struct serio *port)
+{
+	printk(KERN_INFO "cokbd closed\n");
+
+	free_irq(KEYBOARD_IRQ, NULL);
+}
+
+/*
+ * Structures for registering the devices in the serio.c module.
+ */
+
+static struct serio cokbd_port =
+{
+	.id.type =	SERIO_8042_XL,
+	.write =	cokbd_write,
+	.open =		cokbd_open,
+	.close =	cokbd_close,
+	.name =		"cokbd port",
+	.phys =		COKBD_PHYS_DESC,
+};
+
+/*
+ * cokbdio_interrupt() is the most important function in this driver -
+ * it handles the interrupts from keyboard, and sends incoming bytes
+ * to the upper layers.
+ */
+
+static irqreturn_t cokbdio_interrupt(int irq, void *dev_id)
+{
+	co_message_node_t *node_message;
+	while (co_get_message(&node_message, CO_DEVICE_KEYBOARD)) {
+		co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+		co_scan_code_t *sc = (co_scan_code_t *)message->data;
+		unsigned long scancode = sc->code;
+
+		switch (sc->mode)
+		{
+		    case CO_KBD_SCANCODE_RAW:
+			serio_interrupt(&cokbd_port, scancode, 0);
+			break;
+
+		    case CO_KBD_SCANCODE_ASCII:
+			keyboard_inject_utf8(scancode);
+			break;
+		}
+		co_free_message(node_message);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int __init cokbdio_init(void)
+{
+	serio_register_port(&cokbd_port);
+
+	printk(KERN_INFO "serio: cokbd at irq %d\n", KEYBOARD_IRQ);
+
+	return 0;
+}
+
+void __exit cokbdio_exit(void)
+{
+	serio_unregister_port(&cokbd_port);
+}
+
+module_init(cokbdio_init);
+module_exit(cokbdio_exit);
Index: linux-2.6.26-source/drivers/input/mouse/comouse.c
===================================================================
--- /dev/null
+++ linux-2.6.26-source/drivers/input/mouse/comouse.c
@@ -0,0 +1,146 @@
+
+/*
+ * Cooperative mouse driver
+ *
+ * Copyright (c) 2007 Steve Shoecraft <sshoecraft@earthlink.net>
+ * Copyright (c) 2005 Nuno Lucas <nuno.lucas@zmail.pt>
+ * Copyright (c) 2004 Dan Aloni
+ * Copyright (c) 1999-2001 Vojtech Pavlik
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/cooperative_internal.h>
+
+#define COMOUSE_DEBUG 0
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net");
+MODULE_DESCRIPTION("Cooperative Mouse Driver");
+MODULE_LICENSE("GPL");
+
+static struct input_dev *comouse_dev;
+
+static irqreturn_t comouse_isr(int irq, void *dev_id) {
+	co_message_node_t *node_message;
+
+	while ( co_get_message(&node_message, CO_DEVICE_MOUSE) ) {
+		co_linux_message_t *message = (co_linux_message_t *)&node_message->msg.data;
+		co_mouse_data_t* data = (co_mouse_data_t*) message->data;
+		unsigned len = message->size;
+
+		if ( sizeof(*data) != len ) {
+			printk( KERN_ERR "comouse: Invalid data packet!\n" );
+		} else {
+			/* Movement */
+			input_report_abs( comouse_dev, ABS_X, data->abs_x );
+			input_report_abs( comouse_dev, ABS_Y, data->abs_y );
+
+			/* Wheel */
+			if ( data->rel_z ) input_report_rel( comouse_dev, REL_WHEEL, -data->rel_z );
+
+			/* Buttons */
+			input_report_key( comouse_dev, BTN_TOUCH, data->btns & 1 );
+			input_report_key( comouse_dev, BTN_LEFT, data->btns & 1 );
+			input_report_key( comouse_dev, BTN_RIGHT, data->btns & 2 );
+			input_report_key( comouse_dev, BTN_MIDDLE, data->btns & 4 );
+
+			input_sync( comouse_dev );
+#if COMOUSE_DEBUG
+			printk( KERN_DEBUG "comouse: x:%d y:%d buttons:%u wheel: %d.\n",
+				data->abs_x, data->abs_y, data->btns, data->rel_z );
+#endif
+		}
+		co_free_message(node_message);
+	}
+
+	return IRQ_HANDLED;
+}
+
+#if 0
+static int comouse_open(struct input_dev *dev) {
+	return 0;
+}
+
+static void comouse_close(struct input_dev *dev) {
+	return;
+}
+#endif
+
+static int __init comouse_init(void) {
+	int err;
+
+	comouse_dev = input_allocate_device();
+	if (!comouse_dev) {
+		printk(KERN_ERR "comouse.c: Not enough memory for input device\n");
+		return -ENOMEM;
+	}
+
+	comouse_dev->name = "Cooperative Mouse";
+	comouse_dev->phys = "comouse/input0";
+	comouse_dev->id.bustype = BUS_HOST;
+	comouse_dev->id.vendor  = 0x0001;
+	comouse_dev->id.product = 0x0001;
+	comouse_dev->id.version = 0x0100;
+#if 0
+	comouse_dev->open  = comouse_open;
+	comouse_dev->close = comouse_close;
+#endif
+
+	/* Buttons */
+	set_bit( EV_KEY, comouse_dev->evbit );
+	set_bit( BTN_TOUCH , comouse_dev->keybit );
+	set_bit( BTN_LEFT  , comouse_dev->keybit );
+	set_bit( BTN_RIGHT , comouse_dev->keybit );
+	set_bit( BTN_MIDDLE, comouse_dev->keybit );
+
+	/* Movement */
+	set_bit( EV_ABS, comouse_dev->evbit );
+	input_set_abs_params(comouse_dev, ABS_X, 0, CO_MOUSE_MAX_X, 0, 0);
+	input_set_abs_params(comouse_dev, ABS_Y, 0, CO_MOUSE_MAX_Y, 0, 0);
+
+	/* Wheel */
+	set_bit( EV_REL, comouse_dev->evbit );
+	set_bit( REL_WHEEL, comouse_dev->relbit );
+
+	err = input_register_device(comouse_dev);
+	if (err) {
+		printk(KERN_ERR "comouse: device registration failed!\n");
+		input_free_device(comouse_dev);
+		return err;
+	}
+
+	if (request_irq(MOUSE_IRQ, comouse_isr, 0, "comouse", NULL)) {
+		printk(KERN_ERR "comouse: unable to allocate irq %d!\n", MOUSE_IRQ);
+		return -EBUSY;
+	}
+
+#if COMOUSE_DEBUG
+	printk(KERN_INFO "comouse: initialized.\n");
+#endif
+	return 0;
+}
+
+static void __exit comouse_exit(void) {
+	free_irq(MOUSE_IRQ, NULL);
+	input_unregister_device(comouse_dev);
+}
+
+module_init(comouse_init);
+module_exit(comouse_exit);
Index: linux-2.6.25-source/fs/cofusefs/dev.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/dev.c
@@ -0,0 +1,235 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+
+struct fuse_conn *cofs_volumes[CO_MODULE_MAX_COFS] = {NULL, };
+
+static void cofuse_request_start(unsigned long *flags, struct fuse_conn *fc, struct fuse_in *in)
+{
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = fc->cofs_unit;
+	co_passage_page->params[2] = in->h.opcode;
+	co_passage_page->params[3] = in->h.ino;
+	co_passage_page->params[4] = 0;
+}
+
+static void cofuse_request_end(unsigned long flags, struct fuse_out *out)
+{
+	unsigned long ret;
+	ret = co_passage_page->params[4];
+	co_passage_page_release(flags);
+	out->h.error = ret;
+}
+
+void request_send(struct fuse_conn *fc, struct fuse_in *in,
+		  struct fuse_out *out)
+{
+	unsigned long flags;
+	char *str;
+
+	switch ((unsigned long)in->h.opcode) {
+	case FUSE_STATFS: {
+		struct fuse_statfs_out *arg;
+
+		arg = (struct fuse_statfs_out *)out->args[0].value;
+
+		cofuse_request_start(&flags, fc, in);
+		co_switch_wrapper();
+		*arg = *(struct fuse_statfs_out *)&co_passage_page->params[5];
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_OPEN: {
+		struct fuse_open_in *opin = (struct fuse_open_in *)in->args[0].value;
+
+		cofuse_request_start(&flags, fc, in);
+		co_passage_page->params[5] = opin->flags;
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_WRITE: {
+		struct fuse_write_in *write_in = (struct fuse_write_in *)in->args[0].value;
+		unsigned long long *offset_passage = (unsigned long long *)&co_passage_page->params[5];
+
+		cofuse_request_start(&flags, fc, in);
+		*offset_passage = write_in->offset;
+		co_passage_page->params[7] = write_in->size;
+		co_passage_page->params[8] = (unsigned long)in->args[1].value;
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_READ: {
+		struct fuse_read_in *read_in = (struct fuse_read_in *)in->args[0].value;
+		unsigned long long *offset_passage = (unsigned long long *)&co_passage_page->params[5];
+
+		cofuse_request_start(&flags, fc, in);
+		*offset_passage = read_in->offset;
+		co_passage_page->params[7] = read_in->size;
+		co_passage_page->params[8] = (unsigned long)out->args[0].value;
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_LOOKUP: {
+		struct fuse_lookup_out *arg;
+
+		arg = (struct fuse_lookup_out *)out->args[0].value;
+		str = (char *)&co_passage_page->params[30];
+
+		cofuse_request_start(&flags, fc, in);
+		memcpy(str, (char *)in->args[0].value, in->args[0].size);
+		co_switch_wrapper();
+		*arg = *(struct fuse_lookup_out *)&co_passage_page->params[5];
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_RENAME: {
+		struct fuse_rename_in *arg;
+		char *str2;
+
+		arg = (struct fuse_rename_in *)in->args[0].value;
+		str = (char *)(&co_passage_page->params[30]);
+		str2 = str + in->args[1].size;
+
+		cofuse_request_start(&flags, fc, in);
+		co_passage_page->params[5] = arg->newdir;
+		memcpy(str, (char *)in->args[1].value, in->args[1].size);
+		memcpy(str2, (char *)in->args[2].value, in->args[2].size);
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_MKNOD: {
+		struct fuse_mknod_in *inarg;
+		struct fuse_mknod_out *outarg;
+		char *str;
+
+		inarg = (struct fuse_mknod_in *)(in->args[0].value);
+		outarg = (struct fuse_mknod_out *)(out->args[0].value);
+
+		cofuse_request_start(&flags, fc, in);
+		co_passage_page->params[5] = inarg->mode;
+		co_passage_page->params[6] = inarg->rdev;
+		str = (char *)&co_passage_page->params[30];
+		memcpy(str, (char *)in->args[1].value, in->args[1].size);
+		co_switch_wrapper();
+		outarg->ino = co_passage_page->params[7];
+		outarg->attr = *(struct fuse_attr *)(&co_passage_page->params[8]);
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_SETATTR: {
+		struct fuse_setattr_in *inarg;
+		struct fuse_setattr_out *outarg;
+		struct fuse_attr *attr;
+
+		inarg = (struct fuse_setattr_in *)(in->args[0].value);
+		outarg = (struct fuse_setattr_out *)(out->args[0].value);
+		attr = (struct fuse_attr *)(&co_passage_page->params[6]);
+
+		cofuse_request_start(&flags, fc, in);
+		co_passage_page->params[5] = inarg->valid;
+		*attr = inarg->attr;
+		co_switch_wrapper();
+		outarg->attr = *attr;
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_MKDIR: {
+		struct fuse_mkdir_in *arg;
+
+		arg = (struct fuse_mkdir_in *)(in->args[0].value);
+		str = (char *)&co_passage_page->params[30];
+
+		cofuse_request_start(&flags, fc, in);
+		co_passage_page->params[5] = arg->mode;
+		memcpy(str, (char *)in->args[1].value, in->args[1].size);
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_UNLINK:
+	case FUSE_RMDIR: {
+		str = (char *)&co_passage_page->params[30];
+
+		cofuse_request_start(&flags, fc, in);
+		memcpy(str, (char *)in->args[0].value, in->args[0].size);
+		co_switch_wrapper();
+		cofuse_request_end(flags, out);
+		return;
+	}
+
+	case FUSE_GETATTR: {
+		struct fuse_getattr_out *arg;
+		arg = (struct fuse_getattr_out *)out->args[0].value;
+
+		co_passage_page_assert_valid();
+		cofuse_request_start(&flags, fc, in);
+		co_switch_wrapper();
+		*arg = *(struct fuse_getattr_out *)&co_passage_page->params[5];
+		cofuse_request_end(flags, out);
+		return;
+	}
+	default: {
+		static unsigned long warn_bit_array;
+		unsigned long mask = 1 << in->h.opcode;
+
+		if (!(warn_bit_array & mask)) {
+			warn_bit_array |= mask;
+			printk(KERN_WARNING "cofuse: unsuppored request %d\n", in->h.opcode);
+		}
+	}
+	}
+
+	out->h.error = -ENOSYS;
+}
+
+int request_send_nonblock(struct fuse_conn *fc, struct fuse_in *in,
+			  struct fuse_out *out, fuse_reqend_t end, void *data)
+{
+	/* printk("cofuse: request_send_nonblock %d\n", in->h.opcode); */
+	request_send(fc, in, out);
+	end(fc, in, out, data);
+	return 0;
+}
+
+int fuse_dev_init()
+{
+	return 0;
+}
+
+void fuse_dev_cleanup()
+{
+}
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/fs/cofusefs/dir.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/dir.c
@@ -0,0 +1,819 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/jiffies.h>
+#include <linux/sched.h>
+
+static struct inode_operations fuse_dir_inode_operations;
+static struct inode_operations fuse_file_inode_operations;
+static struct inode_operations fuse_symlink_inode_operations;
+
+static struct file_operations fuse_dir_operations;
+
+static struct dentry_operations fuse_dentry_operations;
+
+/* FIXME: This should be user configurable */
+#define FUSE_REVALIDATE_TIME (1 * HZ)
+
+static void change_attributes(struct inode *inode, struct fuse_attr *attr)
+{
+	if(S_ISREG(inode->i_mode) && i_size_read(inode) != attr->size)
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+
+	inode->i_mode    = (inode->i_mode & S_IFMT) + (attr->mode & 07777);
+	inode->i_nlink   = attr->nlink;
+	inode->i_uid     = attr->uid;
+	inode->i_gid     = attr->gid;
+	i_size_write(inode, attr->size);
+	inode->i_blocks  = attr->blocks;
+	inode->i_atime.tv_sec   = attr->atime;
+	inode->i_atime.tv_nsec  = 0;
+	inode->i_mtime.tv_sec   = attr->mtime;
+	inode->i_mtime.tv_nsec  = 0;
+	inode->i_ctime.tv_sec   = attr->ctime;
+	inode->i_ctime.tv_nsec  = 0;
+}
+
+static void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)
+{
+	inode->i_mode = attr->mode & S_IFMT;
+	i_size_write(inode, attr->size);
+	if(S_ISREG(inode->i_mode)) {
+		inode->i_op = &fuse_file_inode_operations;
+		fuse_init_file_inode(inode);
+	}
+	else if(S_ISDIR(inode->i_mode)) {
+		inode->i_op = &fuse_dir_inode_operations;
+		inode->i_fop = &fuse_dir_operations;
+	}
+	else if(S_ISLNK(inode->i_mode)) {
+		inode->i_op = &fuse_symlink_inode_operations;
+	}
+	else {
+		inode->i_op = &fuse_file_inode_operations;
+		init_special_inode(inode, inode->i_mode,
+				   new_decode_dev(attr->rdev));
+	}
+	inode->i_private = inode;
+}
+
+struct inode *fuse_iget(struct super_block *sb, ino_t ino,
+			struct fuse_attr *attr, int version)
+{
+	struct inode *inode;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if ((inode->i_state & I_NEW)) {
+		fuse_init_inode(inode, attr);
+		inode->i_version = version;
+		unlock_new_inode(inode);
+	}
+
+	change_attributes(inode, attr);
+
+	return inode;
+}
+
+static int fuse_do_lookup(struct inode *dir, struct dentry *entry,
+			  struct fuse_lookup_out *outarg, int *version)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+
+	if (entry->d_name.len > FUSE_NAME_MAX)
+		return -ENAMETOOLONG;
+
+	in.h.opcode = FUSE_LOOKUP;
+	in.h.ino = dir->i_ino;
+	in.numargs = 1;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	out.numargs = 1;
+	out.args[0].size = sizeof(struct fuse_lookup_out);
+	out.args[0].value = outarg;
+	request_send(fc, &in, &out);
+
+	*version = out.h.unique;
+	return out.h.error;
+}
+
+static int fuse_lookup_iget(struct inode *dir, struct dentry *entry,
+			    struct inode **inodep)
+{
+	int err;
+	struct fuse_lookup_out outarg;
+	int version;
+	struct inode *inode = NULL;
+
+	err = fuse_do_lookup(dir, entry, &outarg, &version);
+	if(!err) {
+		inode = fuse_iget(dir->i_sb, outarg.ino, &outarg.attr, version);
+		if (IS_ERR(inode))
+			return PTR_ERR(inode);
+	} else if(err != -ENOENT)
+		return err;
+
+	entry->d_time = jiffies;
+	entry->d_op = &fuse_dentry_operations;
+	*inodep = inode;
+	return 0;
+}
+
+static void uncache_dir(struct inode *dir)
+{
+	struct dentry *entry = d_find_alias(dir);
+	if (!entry)
+		clear_nlink(dir);
+	else {
+		entry->d_time = jiffies - FUSE_REVALIDATE_TIME - 1;
+		dput(entry);
+	}
+}
+
+/* create needs to return a positive entry, so this is actually an
+   mknod+lookup */
+static int _fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
+		      dev_t rdev)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_mknod_in inarg;
+	struct fuse_mknod_out outarg;
+	struct inode *inode;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+	inarg.rdev = new_encode_dev(rdev);
+
+	in.h.opcode = FUSE_MKNOD;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = entry->d_name.len + 1;
+	in.args[1].value = entry->d_name.name;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+
+	if(out.h.error)
+		return out.h.error;
+
+	inode = fuse_iget(dir->i_sb, outarg.ino, &outarg.attr, out.h.unique);
+	if (IS_ERR(inode))
+		return PTR_ERR(inode);
+
+	/* Don't allow userspace to do really stupid things... */
+	if((inode->i_mode ^ mode) & S_IFMT) {
+		iput(inode);
+		printk("fuse_mknod: inode has wrong type\n");
+		return -EPROTO;
+	}
+
+	d_instantiate(entry, inode);
+	uncache_dir(dir);
+	return 0;
+}
+
+static int _fuse_create(struct inode *dir, struct dentry *entry, int mode)
+{
+	return _fuse_mknod(dir, entry, mode, 0);
+}
+
+/* knfsd needs the new entry instantiated in mkdir/symlink/link. this
+   should rather be done like mknod: attributes returned in out arg to
+   save a call to userspace */
+static int lookup_new_entry(struct inode *dir, struct dentry *entry)
+{
+	struct inode *inode;
+	int err = fuse_lookup_iget(dir, entry, &inode);
+	if(err || !inode) {
+		printk("fuse_mkdir: failed to look up new entry\n");
+		return err ? err : -ENOENT;
+	}
+	d_instantiate(entry, inode);
+	uncache_dir(dir);
+	return 0;
+}
+
+static int fuse_mkdir(struct inode *dir, struct dentry *entry, int mode)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_mkdir_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+
+	in.h.opcode = FUSE_MKDIR;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = entry->d_name.len + 1;
+	in.args[1].value = entry->d_name.name;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	return lookup_new_entry(dir, entry);
+}
+
+static int fuse_symlink(struct inode *dir, struct dentry *entry,
+			const char *link)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	unsigned int len = strlen(link) + 1;
+
+	if (len > FUSE_SYMLINK_MAX)
+		return -ENAMETOOLONG;
+
+	in.h.opcode = FUSE_SYMLINK;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	in.args[1].size = len;
+	in.args[1].value = link;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	return lookup_new_entry(dir, entry);
+}
+
+static int fuse_remove(struct inode *dir, struct dentry *entry,
+		       enum fuse_opcode op)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+
+	in.h.opcode = op;
+	in.h.ino = dir->i_ino;
+	in.numargs = 1;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	request_send(fc, &in, &out);
+
+	return out.h.error;
+}
+
+static int fuse_unlink(struct inode *dir, struct dentry *entry)
+{
+	int err = fuse_remove(dir, entry, FUSE_UNLINK);
+	if(!err) {
+		/* Set nlink to zero so the inode can be cleared, if
+                   the inode does have more links this will be
+                   discovered at the next lookup/getattr */
+		clear_nlink(entry->d_inode);
+
+		uncache_dir(dir);
+		return 0;
+	}
+	return err;
+}
+
+static int fuse_rmdir(struct inode *dir, struct dentry *entry)
+{
+	int err = fuse_remove(dir, entry, FUSE_RMDIR);
+	if(!err) {
+		clear_nlink(entry->d_inode);
+		uncache_dir(dir);
+	}
+	return err;
+}
+
+static int fuse_rename(struct inode *olddir, struct dentry *oldent,
+		       struct inode *newdir, struct dentry *newent)
+{
+	struct fuse_conn *fc = INO_FC(olddir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_rename_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.newdir = newdir->i_ino;
+
+	in.h.opcode = FUSE_RENAME;
+	in.h.ino = olddir->i_ino;
+	in.numargs = 3;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = oldent->d_name.len + 1;
+	in.args[1].value = oldent->d_name.name;
+	in.args[2].size = newent->d_name.len + 1;
+	in.args[2].value = newent->d_name.name;
+	request_send(fc, &in, &out);
+
+	if (!out.h.error) {
+		uncache_dir(olddir);
+		if (olddir != newdir)
+			uncache_dir(newdir);
+	}
+
+	return out.h.error;
+}
+
+static int fuse_link(struct dentry *entry, struct inode *newdir,
+		     struct dentry *newent)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_link_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.newdir = newdir->i_ino;
+
+	in.h.opcode = FUSE_LINK;
+	in.h.ino = inode->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = newent->d_name.len + 1;
+	in.args[1].value = newent->d_name.name;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	/* Invalidate old entry, so attributes are refreshed */
+	d_invalidate(entry);
+	return lookup_new_entry(newdir, newent);
+}
+
+int fuse_do_getattr(struct inode *inode)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_getattr_out arg;
+
+	in.h.opcode = FUSE_GETATTR;
+	in.h.ino = inode->i_ino;
+	out.numargs = 1;
+	out.args[0].size = sizeof(arg);
+	out.args[0].value = &arg;
+	request_send(fc, &in, &out);
+
+	if(!out.h.error)
+		change_attributes(inode, &arg.attr);
+
+	return out.h.error;
+}
+
+static int fuse_revalidate(struct dentry *entry)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(inode->i_ino == FUSE_ROOT_INO) {
+		if(!(fc->flags & FUSE_ALLOW_OTHER) &&
+		   current->fsuid != fc->uid)
+			return -EACCES;
+	} else if(!(fc->flags & COFS_MOUNT_NOCACHE) &&
+		  time_before_eq(jiffies, entry->d_time + FUSE_REVALIDATE_TIME))
+		return 0;
+
+	return fuse_do_getattr(inode);
+}
+
+static int _fuse_permission(struct inode *inode, int mask)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(!(fc->flags & FUSE_ALLOW_OTHER) && current->fsuid != fc->uid)
+		return -EACCES;
+	else if(fc->flags & FUSE_DEFAULT_PERMISSIONS) {
+		int err = generic_permission(inode, mask, NULL);
+
+		/* If permission is denied, try to refresh file
+		   attributes.  This is also needed, because the root
+		   node will at first have no permissions */
+
+		if(err == -EACCES) {
+		 	err = fuse_do_getattr(inode);
+			if(!err)
+			 	err = generic_permission(inode, mask, NULL);
+		}
+
+		/* FIXME: Need some mechanism to revoke permissions:
+		   currently if the filesystem suddenly changes the
+		   file mode, we will not be informed abot that, and
+		   continue to allow access to the file/directory.
+
+		   This is actually not so grave, since the user can
+		   simply keep access to the file/directory anyway by
+		   keeping it open... */
+
+		return err;
+	}
+	else
+		return 0;
+}
+
+static int parse_dirfile(char *buf, size_t nbytes, struct file *file,
+			 void *dstbuf, filldir_t filldir)
+{
+	while(nbytes >= FUSE_NAME_OFFSET) {
+		struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
+		size_t reclen = FUSE_DIRENT_SIZE(dirent);
+		int over;
+
+		if(dirent->namelen > NAME_MAX) {
+			printk("parse_dirfile: name too long\n");
+			return -EPROTO;
+		}
+		if(reclen > nbytes)
+			break;
+
+		over = filldir(dstbuf, dirent->name, dirent->namelen,
+			      file->f_pos, dirent->ino, dirent->type);
+		if(over)
+			break;
+
+		buf += reclen;
+		file->f_pos += reclen;
+		nbytes -= reclen;
+	}
+
+	return 0;
+}
+
+#define DIR_BUFSIZE 4096
+
+typedef struct {
+	struct fuse_conn *fc;
+	int inode;
+} readdir_data_t;
+
+static int fuse_readdir(struct file *file, void *dstbuf, filldir_t filldir)
+{
+	readdir_data_t *rd = file->private_data;
+	unsigned long flags;
+	int ret, size;
+	char *buf;
+
+	buf = kmalloc(DIR_BUFSIZE, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = rd->fc->cofs_unit;
+	co_passage_page->params[2] = FUSE_DIR_READ;
+	co_passage_page->params[3] = rd->inode;
+	co_passage_page->params[5] = DIR_BUFSIZE;
+	co_passage_page->params[6] = (unsigned long)buf;
+	co_passage_page->params[8] = file->f_pos;
+
+	co_switch_wrapper();
+
+	ret = co_passage_page->params[4];
+	size = co_passage_page->params[7];
+
+	co_passage_page_release(flags);
+
+	if (ret) {
+		printk("fuse_readdir: host returned error: %x\n", ret);
+		kfree(buf);
+		return ret;
+	}
+
+	parse_dirfile(buf, size, file, dstbuf, filldir);
+
+	ret = 0;
+	kfree(buf);
+	return ret;
+}
+
+static char *read_link(struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	char *link;
+
+	link = (char *) __get_free_page(GFP_KERNEL);
+	if(!link)
+		return ERR_PTR(-ENOMEM);
+
+	in.h.opcode = FUSE_READLINK;
+	in.h.ino = inode->i_ino;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = PAGE_SIZE - 1;
+	out.args[0].value = link;
+	request_send(fc, &in, &out);
+	if(out.h.error) {
+		free_page((unsigned long) link);
+		return ERR_PTR(out.h.error);
+	}
+
+	link[out.args[0].size] = '\0';
+	return link;
+}
+
+static void free_link(char *link)
+{
+	if(!IS_ERR(link))
+		free_page((unsigned long) link);
+}
+
+static int fuse_readlink(struct dentry *dentry, char *buffer, int buflen)
+{
+	int ret;
+	char *link;
+
+	link = read_link(dentry);
+	ret = vfs_readlink(dentry, buffer, buflen, link);
+	free_link(link);
+	return ret;
+}
+
+static void * fuse_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret;
+	char *link;
+
+	link = read_link(dentry);
+	ret = vfs_follow_link(nd, link);
+	free_link(link);
+	return ERR_PTR(ret);
+}
+
+static int fuse_dir_open(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	unsigned long flags;
+	readdir_data_t *rd;
+	int ret;
+
+	rd = kmalloc(sizeof(*rd), GFP_KERNEL);
+	if (!rd)
+		return -ENOMEM;
+
+	rd->fc = fc;
+	rd->inode = inode->i_ino;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = fc->cofs_unit;
+	co_passage_page->params[2] = FUSE_DIR_OPEN;
+	co_passage_page->params[3] = inode->i_ino;
+	co_passage_page->params[4] = 0;
+
+	co_switch_wrapper();
+
+	ret = co_passage_page->params[4];
+
+	co_passage_page_release(flags);
+
+	if (ret) {
+		printk("fuse_dir_open: host returned error: %x\n", ret);
+		kfree(rd);
+	} else {
+		file->private_data = (void *)rd;
+	}
+
+	return ret;
+}
+
+static int fuse_dir_release(struct inode *inode, struct file *file)
+{
+	readdir_data_t *rd = file->private_data;
+	unsigned long flags;
+	int ret;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = rd->fc->cofs_unit;
+	co_passage_page->params[2] = FUSE_DIR_RELEASE;
+	co_passage_page->params[3] = rd->inode;
+	co_passage_page->params[4] = 0;
+
+	co_switch_wrapper();
+
+	ret = co_passage_page->params[4];
+
+	co_passage_page_release(flags);
+
+	if (ret)
+		printk("fuse_dir_release: host returned error: %x\n", ret);
+
+	kfree(rd);
+
+	return ret;
+}
+
+static unsigned int iattr_to_fattr(struct iattr *iattr,
+				   struct fuse_attr *fattr)
+{
+	unsigned int ivalid = iattr->ia_valid;
+	unsigned int fvalid = 0;
+
+	memset(fattr, 0, sizeof(*fattr));
+
+	if(ivalid & ATTR_MODE)
+		fvalid |= FATTR_MODE,   fattr->mode = iattr->ia_mode;
+	if(ivalid & ATTR_UID)
+		fvalid |= FATTR_UID,    fattr->uid = iattr->ia_uid;
+	if(ivalid & ATTR_GID)
+		fvalid |= FATTR_GID,    fattr->gid = iattr->ia_gid;
+	if(ivalid & ATTR_SIZE)
+		fvalid |= FATTR_SIZE,   fattr->size = iattr->ia_size;
+	/* You can only _set_ these together (they may change by themselves) */
+	if((ivalid & (ATTR_ATIME | ATTR_MTIME)) == (ATTR_ATIME | ATTR_MTIME)) {
+		fvalid |= FATTR_UTIME;
+		fattr->atime = iattr->ia_atime.tv_sec;
+		fattr->mtime = iattr->ia_mtime.tv_sec;
+	}
+
+	return fvalid;
+}
+
+static int fuse_setattr(struct dentry *entry, struct iattr *attr)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_setattr_in inarg;
+	struct fuse_setattr_out outarg;
+
+	/* FIXME: need to fix race between truncate and writepage */
+	if (attr->ia_valid & ATTR_SIZE)
+		fuse_sync_inode(inode);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.valid = iattr_to_fattr(attr, &inarg.attr);
+
+	in.h.opcode = FUSE_SETATTR;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+
+	if(!out.h.error) {
+		if(attr->ia_valid & ATTR_SIZE &&
+		   outarg.attr.size < i_size_read(inode))
+			vmtruncate(inode, outarg.attr.size);
+
+		change_attributes(inode, &outarg.attr);
+		d_invalidate(entry);
+	}
+
+	return out.h.error;
+}
+
+static int _fuse_dentry_revalidate(struct dentry *entry)
+{
+	struct fuse_conn *fc;
+	struct inode *inode = entry->d_inode;
+
+	if(!inode)
+		return 0;
+
+	fc = INO_FC(inode);
+	if((fc->flags & COFS_MOUNT_NOCACHE) ||
+	   time_after(jiffies, entry->d_time + FUSE_REVALIDATE_TIME)) {
+		struct fuse_lookup_out outarg;
+		int version;
+		int ret;
+
+		ret = fuse_do_lookup(entry->d_parent->d_inode, entry, &outarg,
+				     &version);
+		if(ret)
+			return 0;
+
+		if(outarg.ino != inode->i_ino)
+			return 0;
+
+		change_attributes(inode, &outarg.attr);
+		inode->i_version = version;
+		entry->d_time = jiffies;
+	}
+	return 1;
+}
+
+#define fuse_mknod _fuse_mknod
+
+static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
+			struct kstat *stat)
+{
+	struct inode *inode = entry->d_inode;
+	int err = fuse_revalidate(entry);
+	if(!err)
+		generic_fillattr(inode, stat);
+
+	return err;
+}
+
+static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
+				   struct nameidata *nd)
+{
+	struct inode *inode;
+	int err = fuse_lookup_iget(dir, entry, &inode);
+	if (err)
+		return ERR_PTR(err);
+	return d_splice_alias(inode, entry);
+}
+
+static int fuse_create(struct inode *dir, struct dentry *entry, int mode,
+		       struct nameidata *nd)
+{
+	return _fuse_create(dir, entry, mode);
+}
+
+static int fuse_permission(struct inode *inode, int mask,
+			    struct nameidata *nd)
+{
+	return _fuse_permission(inode, mask);
+}
+
+static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
+{
+	return _fuse_dentry_revalidate(entry);
+}
+
+
+static struct inode_operations fuse_dir_inode_operations =
+{
+	.lookup		= fuse_lookup,
+	.create		= fuse_create,
+	.mknod		= fuse_mknod,
+	.mkdir		= fuse_mkdir,
+	.symlink	= fuse_symlink,
+	.unlink		= fuse_unlink,
+	.rmdir		= fuse_rmdir,
+	.rename		= fuse_rename,
+	.link		= fuse_link,
+	.setattr	= fuse_setattr,
+	.permission	= fuse_permission,
+	.getattr	= fuse_getattr,
+};
+
+static struct file_operations fuse_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= fuse_readdir,
+	.open		= fuse_dir_open,
+	.release	= fuse_dir_release,
+};
+
+static struct inode_operations fuse_file_inode_operations = {
+	.setattr	= fuse_setattr,
+	.permission	= fuse_permission,
+	.getattr	= fuse_getattr,
+};
+
+static struct inode_operations fuse_symlink_inode_operations =
+{
+	.setattr	= fuse_setattr,
+	.readlink	= fuse_readlink,
+	.follow_link	= fuse_follow_link,
+	.getattr	= fuse_getattr,
+};
+
+static struct dentry_operations fuse_dentry_operations = {
+	.d_revalidate	= fuse_dentry_revalidate,
+};
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/fs/cofusefs/file.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/file.c
@@ -0,0 +1,446 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/backing-dev.h>
+#include <linux/writeback.h>
+
+static int fuse_open(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_open_in inarg;
+	int err;
+
+	err = generic_file_open(inode, file);
+	if(err)
+		return err;
+
+	/* If opening the root node, no lookup has been performed on
+	   it, so the attributes must be refreshed */
+	if(inode->i_ino == FUSE_ROOT_INO) {
+		int err = fuse_do_getattr(inode);
+		if(err)
+		 	return err;
+	}
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.flags = file->f_flags & ~O_EXCL;
+
+	in.h.opcode = FUSE_OPEN;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	request_send(fc, &in, &out);
+	if(!out.h.error && !(fc->flags & FUSE_KERNEL_CACHE)) {
+		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+	}
+
+	return out.h.error;
+}
+
+void fuse_sync_inode(struct inode *inode)
+{
+	filemap_fdatawrite(inode->i_mapping);
+	filemap_fdatawait(inode->i_mapping);
+}
+
+static int fuse_release(struct inode *inode, struct file *file)
+{
+	if(file->f_mode & FMODE_WRITE)
+		fuse_sync_inode(inode);
+
+	return 0;
+}
+
+static int fuse_fsync(struct file *file, struct dentry *de, int datasync)
+{
+
+	/* FIXME: need to ensure, that all write requests issued
+           before this request are completed.  Should userspace take
+           care of this? */
+
+	return 0;
+}
+
+static int fuse_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_read_in inarg;
+	char *buffer;
+
+	buffer = kmap(page);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = (unsigned long long) page->index << PAGE_CACHE_SHIFT;
+	inarg.size = PAGE_CACHE_SIZE;
+
+	in.h.opcode = FUSE_READ;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = PAGE_CACHE_SIZE;
+	out.args[0].value = buffer;
+
+	/* Hack: Can't detect readed bytes. But the overhead should fill with zero. */
+	if (inarg.offset + PAGE_CACHE_SIZE > i_size_read(inode))
+		memset(buffer, 0, PAGE_CACHE_SIZE);
+
+	request_send(fc, &in, &out);
+	if(!out.h.error) {
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+	}
+
+	kunmap(page);
+	unlock_page(page);
+
+	return out.h.error;
+}
+
+static int fuse_is_block_uptodate(struct address_space *mapping,
+		struct inode *inode, size_t bl_index)
+{
+	size_t index = bl_index << FUSE_BLOCK_PAGE_SHIFT;
+	size_t end_index = ((bl_index + 1) << FUSE_BLOCK_PAGE_SHIFT) - 1;
+	size_t file_end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;
+
+	if (end_index > file_end_index)
+		end_index = file_end_index;
+
+	for (; index <= end_index; index++) {
+		struct page *page = find_get_page(mapping, index);
+
+		if (!page)
+			return 0;
+
+		if (!PageUptodate(page)) {
+			page_cache_release(page);
+			return 0;
+		}
+
+		page_cache_release(page);
+	}
+
+	return 1;
+}
+
+
+static int fuse_cache_block(struct address_space *mapping,
+		struct inode *inode, char *bl_buf,
+		size_t bl_index)
+{
+	size_t start_index = bl_index << FUSE_BLOCK_PAGE_SHIFT;
+	size_t end_index = ((bl_index + 1) << FUSE_BLOCK_PAGE_SHIFT) - 1;
+	size_t file_end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;
+
+	int i;
+
+	if (end_index > file_end_index)
+		end_index = file_end_index;
+
+	for (i = 0; start_index + i <= end_index; i++) {
+		size_t index = start_index + i;
+		struct page *page;
+		char *buffer;
+
+		page = grab_cache_page(mapping, index);
+		if (!page)
+			return -1;
+
+		if (!PageUptodate(page)) {
+			buffer = kmap(page);
+			memcpy(buffer, bl_buf + i * PAGE_CACHE_SIZE,
+					PAGE_CACHE_SIZE);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			kunmap(page);
+		}
+
+		unlock_page(page);
+		page_cache_release(page);
+	}
+
+	return 0;
+}
+
+static int fuse_file_read_block(struct inode *inode, char *bl_buf,
+		size_t bl_index)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_read_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = (unsigned long long) bl_index << FUSE_BLOCK_SHIFT;
+	inarg.size = FUSE_BLOCK_SIZE;
+
+	in.h.opcode = FUSE_READ;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = FUSE_BLOCK_SIZE;
+	out.args[0].value = bl_buf;
+
+	/* Hack: Can't detect readed bytes. But the overhead should fill with zero. */
+	if (inarg.offset + FUSE_BLOCK_SIZE > i_size_read(inode))
+		memset(bl_buf, 0, FUSE_BLOCK_SIZE);
+
+	request_send(fc, &in, &out);
+
+	return out.h.error;
+}
+
+static void fuse_file_bigread(struct address_space *mapping,
+			      struct inode *inode, loff_t pos, size_t count)
+{
+	size_t bl_index = pos >> FUSE_BLOCK_SHIFT;
+	size_t bl_end_index = (pos + count) >> FUSE_BLOCK_SHIFT;
+	size_t bl_file_end_index = i_size_read(inode) >> FUSE_BLOCK_SHIFT;
+
+	if (bl_end_index > bl_file_end_index)
+		bl_end_index = bl_file_end_index;
+
+	while (bl_index <= bl_end_index) {
+		int res;
+		char *bl_buf = kmalloc(FUSE_BLOCK_SIZE, GFP_NOFS);
+		if (!bl_buf)
+			break;
+		res = fuse_is_block_uptodate(mapping, inode, bl_index);
+		if (!res)
+			res = fuse_file_read_block(inode, bl_buf, bl_index);
+		if (!res)
+			fuse_cache_block(mapping, inode, bl_buf, bl_index);
+		kfree(bl_buf);
+		bl_index++;
+	}
+}
+
+static ssize_t fuse_file_read(struct file *filp, char *buf,
+		size_t count, loff_t * ppos)
+{
+	struct address_space *mapping = filp->f_dentry->d_inode->i_mapping;
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(fc->flags & FUSE_LARGE_READ) {
+		/* Don't allow this to get mixed up with writes */
+		mutex_lock(&inode->i_mutex);
+		fuse_file_bigread(mapping, inode, *ppos, count);
+		mutex_unlock(&inode->i_mutex);
+	}
+
+	return do_sync_read(filp, buf, count, ppos);
+}
+
+static int write_buffer(struct inode *inode, struct page *page,
+			unsigned offset, size_t count)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_write_in inarg;
+	char *buffer;
+
+	buffer = kmap(page);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = ((unsigned long long) page->index << PAGE_CACHE_SHIFT) +
+		offset;
+	inarg.size = count;
+
+	in.h.opcode = FUSE_WRITE;
+	in.h.ino = inode->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = count;
+	in.args[1].value = buffer + offset;
+	request_send(fc, &in, &out);
+	kunmap(page);
+	if(out.h.error)
+		SetPageError(page);
+
+	return out.h.error;
+}
+
+static int get_write_count(struct inode *inode, struct page *page)
+{
+	unsigned long end_index;
+	loff_t size = i_size_read(inode);
+	int count;
+
+	end_index = size >> PAGE_CACHE_SHIFT;
+	if(page->index < end_index)
+		count = PAGE_CACHE_SIZE;
+	else {
+		count = size & (PAGE_CACHE_SIZE - 1);
+		if(page->index > end_index || count == 0)
+			return 0;
+	}
+	return count;
+}
+
+static void write_buffer_end(struct fuse_conn *fc, struct fuse_in *in,
+			     struct fuse_out *out, void *_page)
+{
+	struct page *page = (struct page *) _page;
+
+	if(out->h.error) {
+		SetPageError(page);
+		if(out->h.error == -ENOSPC)
+			set_bit(AS_ENOSPC, &page->mapping->flags);
+		else
+			set_bit(AS_EIO, &page->mapping->flags);
+	}
+	end_page_writeback(page);
+	kunmap(page);
+	kfree(in);
+}
+
+static int write_buffer_nonblock(struct inode *inode, struct page *page,
+				 unsigned offset, size_t count)
+{
+	int err;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in *in = NULL;
+	struct fuse_out *out = NULL;
+	struct fuse_write_in *inarg = NULL;
+	char *buffer;
+	unsigned int s = sizeof(struct fuse_in) + sizeof(struct fuse_out) +
+		sizeof(struct fuse_write_in);
+
+	in = kzalloc(s, GFP_NOFS);
+	if(!in)
+		return -ENOMEM;
+
+	out = (struct fuse_out *)(in + 1);
+	inarg = (struct fuse_write_in *)(out + 1);
+
+	buffer = kmap(page);
+
+	inarg->offset = ((unsigned long long) page->index << PAGE_CACHE_SHIFT) + offset;
+	inarg->size = count;
+
+	in->h.opcode = FUSE_WRITE;
+	in->h.ino = inode->i_ino;
+	in->numargs = 2;
+	in->args[0].size = sizeof(struct fuse_write_in);
+	in->args[0].value = inarg;
+	in->args[1].size = count;
+	in->args[1].value = buffer + offset;
+	err = request_send_nonblock(fc, in, out, write_buffer_end, page);
+	if(err) {
+		if(err != -EWOULDBLOCK)
+			SetPageError(page);
+		kunmap(page);
+		kfree(in);
+	}
+	return err;
+}
+
+static int fuse_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int err;
+	struct inode *inode = page->mapping->host;
+	unsigned count = get_write_count(inode, page);
+
+	err = -EINVAL;
+	if(count) {
+		/* FIXME: check sync_mode, and wait for previous writes (or
+		   signal userspace to do this) */
+		if(wbc->nonblocking) {
+			TestSetPageWriteback(page);
+			err = write_buffer_nonblock(inode, page, 0, count);
+			if (err)
+				TestClearPageWriteback(page);
+			if(err == -EWOULDBLOCK) {
+				__set_page_dirty_nobuffers(page);
+				err = 0;
+			}
+		} else
+			err = write_buffer(inode, page, 0, count);
+	}
+
+	unlock_page(page);
+	return err;
+}
+
+static int fuse_prepare_write(struct file *file, struct page *page,
+			      unsigned offset, unsigned to)
+{
+	/* No op */
+	return 0;
+}
+
+static int fuse_commit_write(struct file *file, struct page *page,
+			     unsigned offset, unsigned to)
+{
+	int err;
+	struct inode *inode = page->mapping->host;
+
+	err = write_buffer(inode, page, offset, to - offset);
+	if(!err) {
+		loff_t pos = (page->index << PAGE_CACHE_SHIFT) + to;
+		if(pos > i_size_read(inode))
+			i_size_write(inode, pos);
+	}
+	return err;
+}
+
+static struct file_operations fuse_file_operations = {
+	.llseek		= generic_file_llseek,
+	.read		= fuse_file_read,
+	.aio_read	= generic_file_aio_read,
+	.write		= do_sync_write,
+	.aio_write	= generic_file_aio_write,
+	.mmap		= generic_file_mmap,
+	.open		= fuse_open,
+	.release	= fuse_release,
+	.fsync		= fuse_fsync,
+	.splice_read	= generic_file_splice_read,
+};
+
+static struct address_space_operations fuse_file_aops  = {
+	.readpage =		fuse_readpage,
+	.writepage =		fuse_writepage,
+	.prepare_write =	fuse_prepare_write,
+	.commit_write =		fuse_commit_write,
+};
+
+void fuse_init_file_inode(struct inode *inode)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	/* Readahead somehow defeats big reads on 2.6 (says Michael
+           Grigoriev) */
+	if(fc->flags & FUSE_LARGE_READ)
+		inode->i_mapping->backing_dev_info->ra_pages = 0;
+	inode->i_fop = &fuse_file_operations;
+	inode->i_data.a_ops = &fuse_file_aops;
+}
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/fs/cofusefs/fuse_i.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/fuse_i.h
@@ -0,0 +1,245 @@
+/*
+    COFUSE: Filesystem in an host of Cooperative Linux
+    Copyright (C) 2004 Dan Aloni <da-x@colinux.org>
+
+    based on FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#error Kernel version 2.5.* not supported
+#endif
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_fs.h>
+
+/** Read combining parameters */
+#define FUSE_BLOCK_SHIFT 16
+#define FUSE_BLOCK_SIZE 65536
+#define FUSE_BLOCK_MASK 0xffff0000
+
+#define FUSE_BLOCK_PAGE_SHIFT (FUSE_BLOCK_SHIFT - PAGE_CACHE_SHIFT)
+
+/**
+ * A Fuse connection.
+ *
+ * This structure is created, when the client device is opened, and is
+ * destroyed, when the client device is closed _and_ the filesystem is
+ * unmounted.
+ */
+struct fuse_conn {
+	/** The superblock of the mounted filesystem */
+	struct super_block *sb;
+
+	/** index on the host side **/
+	int cofs_unit;
+
+	/** The user id for this mount */
+	uid_t uid;
+
+	/** The fuse mount flags for this mount */
+	unsigned int flags;
+
+	/** Is the new (synchronous) release not supported by
+	    userspace? */
+	unsigned int oldrelease;
+
+	char opt_pathname[0x80];
+};
+
+/** One input argument of a request */
+struct fuse_in_arg {
+	unsigned int size;
+	const void *value;
+};
+
+/** The request input */
+struct fuse_in {
+	struct fuse_in_header h;
+	unsigned int numargs;
+	struct fuse_in_arg args[3];
+};
+
+/** One output argument of a request */
+struct fuse_out_arg {
+	unsigned int size;
+	void *value;
+};
+
+/** The request output */
+struct fuse_out {
+	struct fuse_out_header h;
+	unsigned int argvar;
+	unsigned int numargs;
+	struct fuse_out_arg args[3];
+};
+
+#define FUSE_IN_INIT { {0, 0, 0, current->fsuid, current->fsgid}, 0}
+#define FUSE_OUT_INIT { {0, 0}, 0, 0}
+
+struct fuse_req;
+typedef void (*fuse_reqend_t)(struct fuse_conn *, struct fuse_in *,
+			      struct fuse_out *, void *data);
+
+/**
+ * A request to the client
+ */
+struct fuse_req {
+	/** The request list */
+	struct list_head list;
+
+	/** True if the request is synchronous */
+	unsigned int issync:1;
+
+	/** The request is locked */
+	unsigned int locked:1;
+
+	/** The request has been interrupted while it was locked */
+	unsigned int interrupted:1;
+
+	/* The request has been sent to the client */
+	unsigned int sent:1;
+
+	/* The request is finished */
+	unsigned int finished:1;
+
+	/** The request input */
+	struct fuse_in *in;
+
+	/** The request output */
+	struct fuse_out *out;
+
+	/** Used to wake up the task waiting for completion of request*/
+	wait_queue_head_t waitq;
+
+	/** Request completion callback */
+	fuse_reqend_t end;
+
+	/** User data */
+	void *data;
+};
+
+#define SB_FC(sb) ((sb)->s_fs_info)
+#define INO_FC(inode) SB_FC((inode)->i_sb)
+#define DEV_FC(file) ((struct fuse_conn *) (file)->private_data)
+
+
+/**
+ * The proc entry for the client device ("/proc/fs/fuse/dev")
+ */
+extern struct proc_dir_entry *proc_fuse_dev;
+
+/**
+ * The lock to protect fuses structures
+ */
+extern spinlock_t cofuse_lock;
+
+
+/**
+ * Get a filled in inode
+ */
+struct inode *cofuse_iget(struct super_block *sb, ino_t ino,
+	   	  	  struct fuse_attr *attr, int version);
+
+
+/**
+ * Initialise operations on regular file
+ */
+void cofuse_init_file_inode(struct inode *inode);
+
+/**
+ * Check if the connection can be released, and if yes, then free the
+ * connection structure
+ */
+void cofuse_release_conn(struct fuse_conn *fc);
+
+/**
+ * Initialize the client device
+ */
+int cofuse_dev_init(void);
+
+/**
+ * Cleanup the client device
+ */
+void cofuse_dev_cleanup(void);
+
+/**
+ * Initialize the fuse filesystem
+ */
+int cofuse_fs_init(void);
+
+/**
+ * Cleanup the fuse filesystem
+ */
+void cofuse_fs_cleanup(void);
+
+/**
+ * Send a request
+ *
+ */
+void cofuse_request_send(struct fuse_conn *fc, struct fuse_in *in,
+    			 struct fuse_out *out);
+
+/**
+ * Send a synchronous request without blocking
+ */
+int cofuse_request_send_nonblock(struct fuse_conn *fc, struct fuse_in *in,
+	  		         struct fuse_out *out, fuse_reqend_t end, void *data);
+
+/**
+ * Get the attributes of a file
+ */
+int cofuse_do_getattr(struct inode *inode);
+
+/**
+ * Write dirty pages
+ */
+void cofuse_sync_inode(struct inode *inode);
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
+
+#define COFUSE_VERSION "0.1"
+#define FUSE_VERSION COFUSE_VERSION
+
+#define fuse_init_file_inode cofuse_init_file_inode
+#define fuse_do_getattr cofuse_do_getattr
+#define fuse_sync_inode cofuse_sync_inode
+#define fuse_lock cofuse_lock
+
+#define request_send cofuse_request_send
+#define request_send_nonblock cofuse_request_send_nonblock
+#define release_conn cofuse_release_conn
+#define fuse_iget cofuse_iget
+#define fuse_dev_init cofuse_dev_init
+#define fuse_dev_cleanup cofuse_dev_cleanup
+#define fuse_fs_init cofuse_fs_init
+#define fuse_fs_cleanup cofuse_fs_cleanup
+
+extern struct fuse_conn *cofs_volumes[CO_MODULE_MAX_COFS];
+
+/** Data passed to mount */
+struct cofuse_mount_data {
+	struct fuse_mount_data *fuse;
+	int uid;
+	int gid;
+	unsigned long file_mode;
+	unsigned long dir_mode;
+	unsigned long flags;
+	char name[0x80];
+};
Index: linux-2.6.25-source/fs/cofusefs/inode.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/inode.c
@@ -0,0 +1,407 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001	Miklos Szeredi (miklos@szeredi.hu)
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/ctype.h>
+#include <linux/proc_fs.h>
+#include <linux/statfs.h>
+#include <linux/exportfs.h>
+
+#define FUSE_SUPER_MAGIC 0x65735546
+
+#ifndef FS_BINARY_MOUNTDATA
+#define FS_BINARY_MOUNTDATA 0
+#endif
+
+static void fuse_clear_inode(struct inode *inode)
+{
+	unsigned long flags;
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if (FUSE_ROOT_INO == inode->i_ino)
+		return;
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = fc->cofs_unit;
+	co_passage_page->params[2] = FUSE_FORGET;
+	co_passage_page->params[3] = inode->i_ino;
+	co_switch_wrapper();
+	co_passage_page_release(flags);
+}
+
+static void fuse_put_super(struct super_block *sb)
+{
+	struct fuse_conn *fc = SB_FC(sb);
+
+	spin_lock(&fuse_lock);
+	fc->sb = NULL;
+	fc->uid = 0;
+	fc->flags = 0;
+	/* Flush all readers on this fs */
+	release_conn(fc);
+	SB_FC(sb) = NULL;
+	spin_unlock(&fuse_lock);
+}
+
+static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)
+{
+	stbuf->f_type	 = FUSE_SUPER_MAGIC;
+	stbuf->f_bsize	 = attr->block_size;
+	stbuf->f_blocks	 = attr->blocks;
+	stbuf->f_bfree	 = stbuf->f_bavail = attr->blocks_free;
+	stbuf->f_files	 = attr->files;
+	stbuf->f_ffree	 = attr->files_free;
+	/* Is this field necessary?  Most filesystems ignore it...
+	stbuf->f_fsid.val[0] = (FUSE_SUPER_MAGIC>>16)&0xffff;
+	stbuf->f_fsid.val[1] =	FUSE_SUPER_MAGIC     &0xffff; */
+	stbuf->f_namelen = attr->namelen;
+}
+
+static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct fuse_conn *fc = SB_FC(sb);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_statfs_out outarg;
+
+	in.numargs = 0;
+	in.h.opcode = FUSE_STATFS;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+	if(!out.h.error)
+		convert_fuse_statfs(buf, &outarg.st);
+
+	return out.h.error;
+}
+
+static int _atoi(const char *s, const char **out)
+{
+	/* lib/spprintf.h */
+
+        int i=0;
+
+        while (isdigit(*s))
+                i = i*10 + *(s++) - '0';
+
+	*out = s;
+
+        return i;
+}
+
+static struct fuse_conn *co_get_conn(struct cofuse_mount_data *d)
+{
+	int index;
+	int ret;
+	unsigned long flags;
+	struct fuse_conn *conn = NULL;
+	const char *name, *next;
+
+	if (d == NULL) {
+		printk("co_get_conn: Bad mount data\n");
+		return NULL;
+	}
+
+	name = d->name;
+
+	if (strncmp("cofs", name, 4) == 0)
+		name += 4;
+
+	index = _atoi(name, &next);
+	if (index < 0  || index >= CO_MODULE_MAX_COFS) {
+		printk("co_get_conn: Invalid index %d\n", index);
+		return NULL;
+	}
+
+	if (cofs_volumes[index])
+		return cofs_volumes[index];
+
+	conn = kzalloc(sizeof(struct fuse_conn), GFP_KERNEL);
+	if (!conn)
+		return NULL;
+
+	if (*next == ':')
+		snprintf(conn->opt_pathname, sizeof(conn->opt_pathname), "%s", next+1);
+
+	conn->cofs_unit = index;
+	conn->flags = d->flags;
+
+	if (d->flags & COFS_MOUNT_NOCACHE)
+		printk("cofs%d: cache disabed\n", index);
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_FILESYSTEM;
+	co_passage_page->params[1] = conn->cofs_unit;
+	co_passage_page->params[2] = FUSE_MOUNT;
+	co_passage_page->params[5] = d->uid;
+	co_passage_page->params[6] = d->gid;
+	co_passage_page->params[7] = d->dir_mode;
+	co_passage_page->params[8] = d->file_mode;
+	co_passage_page->params[9] = d->flags;
+	memcpy(&co_passage_page->params[30], conn->opt_pathname, strlen(conn->opt_pathname) + 1);
+	co_switch_wrapper();
+	ret = co_passage_page->params[4];
+	co_passage_page_release(flags);
+
+	if (ret) {
+		kfree(conn);
+		conn = NULL;
+	}
+	cofs_volumes[index] = conn;
+
+	return conn;
+}
+
+static struct inode *get_root_inode(struct super_block *sb, unsigned int mode)
+{
+	struct fuse_attr attr;
+	memset(&attr, 0, sizeof(attr));
+
+	attr.mode = mode;
+	return fuse_iget(sb, 1, &attr, 0);
+}
+
+static struct super_operations fuse_super_operations = {
+	.clear_inode	= fuse_clear_inode,
+	.put_super	= fuse_put_super,
+	.statfs		= fuse_statfs,
+};
+
+static int fuse_read_super(struct super_block *sb, void *data, int silent)
+{
+	struct fuse_conn *fc;
+	struct inode *root;
+	struct cofuse_mount_data *co_d = data;
+	struct fuse_mount_data *d = co_d->fuse;
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = FUSE_SUPER_MAGIC;
+	sb->s_op = &fuse_super_operations;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+
+	fc = co_get_conn(co_d);
+	if(fc == NULL)
+		return -EINVAL;
+	spin_lock(&fuse_lock);
+	if(fc->sb != NULL) {
+		printk("fuse_read_super: connection already mounted\n");
+		spin_unlock(&fuse_lock);
+		return -EINVAL;
+	}
+	fc->sb = sb;
+	fc->flags = d->flags;
+	fc->uid = d->uid;
+	spin_unlock(&fuse_lock);
+
+	/* fc is needed in fuse_init_file_inode which could be called
+	   from get_root_inode */
+	SB_FC(sb) = fc;
+
+	root = get_root_inode(sb, d->rootmode);
+	if(root == NULL) {
+		printk("fuse_read_super: failed to get root inode\n");
+		return -EINVAL;
+	}
+
+	sb->s_root = d_alloc_root(root);
+	if(!sb->s_root) {
+		printk("fuse_read_super: failed to allocate root\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * cofuse_getopt and cofuse_parse_options were
+ * addopted from smb
+ */
+
+struct option {
+	const char *name;
+	unsigned long flag;
+	int val;
+};
+
+/**
+ *      cofuse_getopt - option parser
+ *      based on smb_getopt from fs/smbfs
+ *
+ *      @caller: name of the caller, for error messages
+ *      @options: the options string
+ *      @opts: an array of &struct option entries controlling parser operations
+ *      @optopt: output; will contain the current option
+ *      @optarg: output; will contain the value (if one exists)
+ *      @flag: output; may be NULL; should point to a long for or'ing flags
+ *      @value: output; may be NULL; will be overwritten with the integer value
+ *              of the current argument.
+ *
+ *      Helper to parse options on the format used by mount ("a=b,c=d,e,f").
+ *      Returns opts->val if a matching entry in the 'opts' array is found,
+ *      0 when no more tokens are found, -1 if an error is encountered.
+ */
+static int cofuse_getopt(char *caller, char **options, struct option *opts,
+			 char **optopt, char **optarg, unsigned long *flag,
+			 unsigned long *value)
+{
+        char *token;
+        char *val;
+        int i;
+
+        do {
+                if ((token = strsep(options, ",")) == NULL)
+                        return 0;
+        } while (*token == '\0');
+        *optopt = token;
+
+        *optarg = NULL;
+        if ((val = strchr (token, '=')) != NULL) {
+                *val++ = 0;
+                if (value)
+                        *value = simple_strtoul(val, NULL, 0);
+                *optarg = val;
+        }
+
+        for (i = 0; opts[i].name != NULL; i++) {
+                if (!strcmp(opts[i].name, token)) {
+                        if (!opts[i].flag && (!val || !*val)) {
+                                printk("%s: the %s option requires an argument\n",
+                                       caller, token);
+                                return -1;
+                        }
+
+                        if (flag && opts[i].flag)
+                                *flag |= opts[i].flag;
+
+                        return opts[i].val;
+                }
+        }
+        printk("%s: Unrecognized mount option %s\n", caller, token);
+        return -1;
+}
+
+static struct option opts[] = {
+	{ "uid",	0, 'u' },
+	{ "gid",	0, 'g' },
+	{ "fmask",	0, 'f' },
+	{ "dmask",	0, 'd' },
+	{ "nocache",	COFS_MOUNT_NOCACHE, 1 },
+	{ "noattrib",	COFS_MOUNT_NOATTRIB, 1 },
+	{ NULL,		0, 0}
+};
+
+/*
+ * parse_options - based on parse_options from fs/smbfs
+ */
+static int parse_options(struct cofuse_mount_data *mnt, char *options)
+{
+        int c;
+        unsigned long flags = 0;
+        unsigned long value = 0;
+        char *optarg;
+        char *optopt;
+
+        while ((c = cofuse_getopt("cofuse", &options, opts,
+				  &optopt, &optarg, &flags, &value)) > 0)
+	{
+                switch (c) {
+                case 1:
+                        /* got a "flag" option */
+                        break;
+                case 'u':
+                        mnt->uid = value;
+                        break;
+                case 'g':
+                        mnt->gid = value;
+                        break;
+                case 'f':
+                        mnt->file_mode = (value & S_IRWXUGO) | S_IFREG;
+                        break;
+                case 'd':
+                        mnt->dir_mode = (value & S_IRWXUGO) | S_IFDIR;
+                        break;
+                default:
+                        printk("cofs: Unrecognized mount option %s\n", optopt);
+                        return -1;
+                }
+        }
+
+        mnt->flags = flags;
+        return c;
+}
+
+static int fuse_get_sb(struct file_system_type *fs_type,
+				       int flags, const char *dev_name,
+				       void *raw_data, struct vfsmount *mnt)
+{
+	struct cofuse_mount_data co_md = {0, };
+	struct fuse_mount_data md = {0, };
+	int ret;
+
+	co_md.uid = current->uid;
+	co_md.gid = current->gid;
+	co_md.dir_mode = FUSE_S_IRWXU | FUSE_S_IRGRP | FUSE_S_IXGRP |
+		FUSE_S_IROTH | FUSE_S_IXOTH | S_IFDIR;
+	co_md.file_mode = FUSE_S_IRWXU | FUSE_S_IRGRP | FUSE_S_IXGRP |
+		FUSE_S_IROTH | FUSE_S_IXOTH | S_IFREG;
+
+	ret = parse_options(&co_md, raw_data);
+	if (ret == -1)
+		return -EINVAL;
+
+	md.rootmode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
+	md.flags = FUSE_ALLOW_OTHER | FUSE_DEFAULT_PERMISSIONS | co_md.flags;
+
+	co_md.fuse = &md;
+	snprintf(co_md.name, sizeof(co_md.name), "%s", dev_name);
+
+	return get_sb_nodev(fs_type, flags, &co_md, fuse_read_super, mnt);
+}
+
+static struct file_system_type fuse_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "cofs",
+	.get_sb		= fuse_get_sb,
+	.kill_sb	= kill_anon_super,
+	.fs_flags	= FS_BINARY_MOUNTDATA,
+};
+
+int __init fuse_fs_init()
+{
+	int res;
+
+	res = register_filesystem(&fuse_fs_type);
+	if(res)
+		printk("fuse: failed to register filesystem\n");
+
+	return res;
+}
+
+void fuse_fs_cleanup()
+{
+	unregister_filesystem(&fuse_fs_type);
+}
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/fs/cofusefs/util.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/fs/cofusefs/util.c
@@ -0,0 +1,69 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/init.h>
+#include <linux/slab.h>
+
+MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
+MODULE_DESCRIPTION("Filesystem in Userspace");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+spinlock_t fuse_lock = SPIN_LOCK_UNLOCKED;
+
+/* Must be called with the fuse lock held */
+void release_conn(struct fuse_conn *fc)
+{
+	cofs_volumes[fc->cofs_unit] = NULL;
+	kfree(fc);
+}
+
+int __init cofuse_init(void)
+{
+	int res;
+
+	printk(KERN_DEBUG "cofuse init %s (API version %i.%i)\n",
+	       FUSE_VERSION,
+	       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
+
+	res = fuse_fs_init();
+	if(res)
+		goto err;
+
+	res = fuse_dev_init();
+	if(res)
+		goto err_fs_cleanup;
+
+	return 0;
+
+  err_fs_cleanup:
+	fuse_fs_cleanup();
+  err:
+	return res;
+}
+
+void __exit cofuse_exit(void)
+{
+	printk(KERN_DEBUG "cofuse exit\n");
+
+	fuse_fs_cleanup();
+	fuse_dev_cleanup();
+}
+
+module_init(cofuse_init);
+module_exit(cofuse_exit);
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/include/linux/cooperative_fs.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/include/linux/cooperative_fs.h
@@ -0,0 +1,273 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+/* This file defines the kernel interface of FUSE */
+
+#pragma pack(0)
+
+/** Version number of this interface */
+#define FUSE_KERNEL_VERSION 2
+
+/** Minor version number of this interface */
+#define FUSE_KERNEL_MINOR_VERSION 2
+
+/** The inode number of the root inode */
+#define FUSE_ROOT_INO 1
+
+/** Data passed to mount */
+struct fuse_mount_data {
+	/** The file type of the root inode */
+	unsigned int rootmode;
+
+	/** The user ID of the user initiating this mount */
+	unsigned int uid;
+
+	/** FUSE specific mount flags */
+	unsigned int flags;
+};
+
+/* FUSE mount flags: */
+
+/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
+module will check permissions based on the file mode.  Otherwise no
+permission checking is done in the kernel */
+#define FUSE_DEFAULT_PERMISSIONS (1 << 0)
+
+/** If the FUSE_ALLOW_OTHER flag is given, then not only the user
+    doing the mount will be allowed to access the filesystem */
+#define FUSE_ALLOW_OTHER         (1 << 1)
+
+/** If the FUSE_KERNEL_CACHE flag is given, then files will be cached
+    until the INVALIDATE operation is invoked */
+#define FUSE_KERNEL_CACHE        (1 << 2)
+
+/** Allow FUSE to combine reads into 64k chunks.  This is useful if
+    the filesystem is better at handling large chunks.  NOTE: in
+    current implementation the raw throughput is worse for large reads
+    than for small. */
+#define FUSE_LARGE_READ          (1 << 3)
+
+/** If COFS_MOUNT_NOCACHE is given, dir entries will no cached */
+#define COFS_MOUNT_NOCACHE       (1 << 4)
+
+/** If COFS_MOUNT_NOATTRIB is given, host file attribs will ignore */
+#define COFS_MOUNT_NOATTRIB      (1 << 5)
+
+struct fuse_attr {
+	unsigned long long  size;
+	unsigned int        mode;
+	unsigned int        nlink;
+	unsigned int        uid;
+	unsigned int        gid;
+	unsigned int        rdev;
+	unsigned long       _dummy;
+	unsigned long       blocks;
+	unsigned long       atime;
+	unsigned long       mtime;
+	unsigned long       ctime;
+};
+
+struct fuse_kstatfs {
+    long block_size;
+    long blocks;
+    long blocks_free;
+    long files;
+    long files_free;
+    long namelen;
+};
+
+#define FATTR_MODE	(1 << 0)
+#define FATTR_UID	(1 << 1)
+#define FATTR_GID	(1 << 2)
+#define FATTR_SIZE	(1 << 3)
+#define FATTR_UTIME	(1 << 4)
+
+enum fuse_opcode {
+	FUSE_LOOKUP	= 1,
+	FUSE_FORGET	= 2,  /* no reply */
+	FUSE_GETATTR	= 3,
+	FUSE_SETATTR	= 4,
+	FUSE_READLINK	= 5,
+	FUSE_SYMLINK	= 6,
+	FUSE_GETDIR	= 7,
+	FUSE_MKNOD	= 8,
+	FUSE_MKDIR	= 9,
+	FUSE_UNLINK	= 10,
+	FUSE_RMDIR	= 11,
+	FUSE_RENAME	= 12,
+	FUSE_LINK	= 13,
+	FUSE_OPEN	= 14,
+	FUSE_READ	= 15,
+	FUSE_WRITE	= 16,
+	FUSE_STATFS	= 17,
+	FUSE_RELEASE    = 18, /* no reply */
+	FUSE_INVALIDATE = 19, /* user initiated */
+	FUSE_FSYNC      = 20,
+	FUSE_RELEASE2   = 21,  /* reply needed after all */
+
+	/* Cooperative Linux does things a little differently: */
+	FUSE_DIR_OPEN    = 22,
+	FUSE_DIR_READ    = 23,
+	FUSE_DIR_RELEASE = 24,
+
+	FUSE_MOUNT       = 25,
+};
+
+/* Conservative buffer size for the client */
+#define FUSE_MAX_IN 8192
+
+#define FUSE_NAME_MAX 1024
+#define FUSE_SYMLINK_MAX 4096
+
+struct fuse_lookup_out {
+	struct fuse_attr attr;
+	unsigned long ino;
+};
+
+struct fuse_forget_in {
+	int version;
+};
+
+struct fuse_getattr_out {
+	struct fuse_attr attr;
+};
+
+struct fuse_getdir_out {
+	int fd;
+	void *file; /* Used by kernel only */
+};
+
+/* FIXME: 2.6 needs 32 bit rdev */
+struct fuse_mknod_in {
+	unsigned short mode;
+	unsigned short rdev;
+};
+
+struct fuse_mknod_out {
+	struct fuse_attr attr;
+	unsigned long ino;
+};
+
+struct fuse_mkdir_in {
+	unsigned short mode;
+};
+
+struct fuse_rename_in {
+	unsigned long newdir;
+};
+
+struct fuse_link_in {
+	unsigned long newdir;
+};
+
+struct fuse_setattr_in {
+	struct fuse_attr attr;
+	unsigned int valid;
+};
+
+struct fuse_setattr_out {
+	struct fuse_attr attr;
+};
+
+struct fuse_open_in {
+	unsigned int flags;
+};
+
+struct fuse_read_in {
+	unsigned long long offset;
+	unsigned int size;
+};
+
+struct fuse_write_in {
+	unsigned long long offset;
+	unsigned int size;
+};
+
+struct fuse_statfs_out {
+	struct fuse_kstatfs st;
+};
+
+struct fuse_fsync_in {
+	int datasync;
+};
+
+struct fuse_in_header {
+	int unique;
+	enum fuse_opcode opcode;
+	unsigned long ino;
+	unsigned int uid;
+	unsigned int gid;
+};
+
+struct fuse_out_header {
+	int unique;
+	int error;
+};
+
+struct fuse_user_header {
+	int unique; /* zero */
+	enum fuse_opcode opcode;
+	unsigned long ino;
+};
+
+struct fuse_dirent {
+	unsigned long ino;
+	unsigned short namelen;
+	unsigned char type;
+	char name[256];
+};
+
+#define FUSE_S_IFMT   0170000
+#define FUSE_S_IFSOCK 0140000
+#define FUSE_S_IFLNK  0120000
+#define FUSE_S_IFREG  0100000
+#define FUSE_S_IFBLK  0060000
+#define FUSE_S_IFDIR  0040000
+#define FUSE_S_IFCHR  0020000
+#define FUSE_S_IFIFO  0010000
+#define FUSE_S_ISUID  0004000
+#define FUSE_S_ISGID  0002000
+#define FUSE_S_ISVTX  0001000
+
+#define FUSE_S_IRWXU 00700
+#define FUSE_S_IRUSR 00400
+#define FUSE_S_IWUSR 00200
+#define FUSE_S_IXUSR 00100
+
+#define FUSE_S_IRWXG 00070
+#define FUSE_S_IRGRP 00040
+#define FUSE_S_IWGRP 00020
+#define FUSE_S_IXGRP 00010
+
+#define FUSE_S_IRWXO 00007
+#define FUSE_S_IROTH 00004
+#define FUSE_S_IWOTH 00002
+#define FUSE_S_IXOTH 00001
+
+#define FUSE_DT_UNKNOWN	        0
+#define FUSE_DT_FIFO		1
+#define FUSE_DT_CHR		2
+#define FUSE_DT_DIR		4
+#define FUSE_DT_BLK		6
+#define FUSE_DT_REG		8
+#define FUSE_DT_LNK		10
+#define FUSE_DT_SOCK		12
+#define FUSE_DT_WHT		14
+
+#define FUSE_NAME_OFFSET ((unsigned int) ((struct fuse_dirent *) 0)->name)
+#define FUSE_DIRENT_ALIGN(x) (((x) + sizeof(long) - 1) & ~(sizeof(long) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+#pragma pack()
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: linux-2.6.25-source/arch/x86/pci/copci.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/arch/x86/pci/copci.c
@@ -0,0 +1,306 @@
+/*
+ *  Copyright (C) 2008 Steve Shoecraft
+ *
+ *  Cooperative Linux PCI Driver implementation
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/pci_regs.h>
+#include <linux/interrupt.h>
+#include <linux/cooperative_pci.h>
+#include <linux/cooperative_internal.h>
+#include "pci.h"
+
+#include <linux/copci.h>
+
+#define COPCI_DEBUG 0
+#define COPCI_DEBUG_IO 0
+
+/* For PCI or other memory-mapped resources */
+/* Symbol needed, dummy for coLinux. (copied from arch/x86/kernel/e820.c) */
+unsigned long pci_mem_start = 0x10000000;
+EXPORT_SYMBOL(pci_mem_start);
+
+struct device_list {
+	int type;
+	int bus;
+	int device;
+	int func;
+	unsigned char regs[256];
+	struct device_list *next;
+};
+
+static struct device_list *devices = 0, *last_device;
+
+#define pci_byte(r,l) *((unsigned char *)(&r[l]))
+#define pci_short(r,l) *((unsigned short *)(&r[l]))
+#define pci_long(r,l) *((unsigned long *)(&r[l]))
+
+static int copci_read(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 *value)
+{
+	int device, func;
+	struct device_list *dp;
+
+	/* Linux has encoded the device & func; split them */
+	device = devfn >> 3;
+	func = devfn & 7;
+
+	if (reg + len > 255) {
+		*value = -1;
+		return -EINVAL;
+	}
+
+	spin_lock(&pci_config_lock);
+
+	*value = 0;
+	for(dp = devices; dp; dp = dp->next) {
+		if (bus == dp->bus && device == dp->device && func == dp->func) {
+#if COPCI_DEBUG_IO
+			if (dp->type == CO_DEVICE_NETWORK) printk(KERN_INFO "copci_read: bus: %02x, devfn: %02x "
+				"(device: %02x, func: %02x), reg: %02x, len: %d\n", bus, devfn, device, func, reg, len);
+#endif
+			switch(len) {
+			case 1:
+				*value = pci_byte(dp->regs, reg);
+				break;
+			case 2:
+				*value = pci_short(dp->regs, reg);
+				break;
+			case 4:
+				*value = pci_long(dp->regs, reg);
+				break;
+			}
+#if COPCI_DEBUG_IO
+			if (dp->type == CO_DEVICE_NETWORK) printk(KERN_INFO "copci_read: value: 0x%08x\n", *value);
+#endif
+		}
+	}
+
+	spin_unlock(&pci_config_lock);
+
+	return 0;
+}
+
+static int copci_write(unsigned int seg, unsigned int bus, unsigned int devfn, int reg, int len, u32 value) {
+	struct device_list *dp;
+	int rc, device, func;
+
+	device = devfn >> 3;
+	func = devfn & 7;
+
+	if (reg + len > 255) return -EINVAL;
+
+	spin_lock(&pci_config_lock);
+
+	rc = -EPERM;
+	for(dp = devices; dp; dp = dp->next) {
+		if (bus == dp->bus && device == dp->device && func == dp->func) {
+#if COPCI_DEBUG_IO
+			if (dp->type == CO_DEVICE_NETWORK) printk(KERN_INFO "copci_read: bus: %02x, devfn: %02x "
+				"(device: %02x, func: %02x), reg: %02x, len: %d, value: %08X\n",
+				bus, devfn, device, func, reg, len, value);
+#endif
+			switch(len) {
+			case 1:
+//				pci_byte(dp->regs, reg) = *value;
+				break;
+			case 2:
+//				pci_short(dp->regs, reg) = *value;
+				break;
+			case 4:
+//				pci_long(dp->regs, reg) = value;
+				break;
+			}
+#if COPCI_DEBUG_IO
+			if (dp->type == CO_DEVICE_NETWORK) printk(KERN_INFO "copci_read: value: 0x%08x\n", value);
+#endif
+		}
+	}
+
+	spin_unlock(&pci_config_lock);
+
+	return rc;
+}
+
+struct pci_raw_ops copci_ops = {
+	.read =         copci_read,
+	.write =        copci_write,
+};
+
+static int get_mac(int unit, unsigned char *address)
+{
+	unsigned long flags;
+	co_network_request_t *net_request;
+	int result;
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_NETWORK;
+	net_request = (typeof(net_request))&co_passage_page->params[1];
+	net_request->unit = unit;
+	net_request->type = CO_NETWORK_GET_MAC;
+	co_switch_wrapper();
+	memcpy(address, net_request->mac_address, 6);
+	result = net_request->result;
+	co_passage_page_release(flags);
+
+	return result;
+}
+
+#if 0
+static int get_irq(int type) {
+	unsigned long flags;
+	co_network_request_t *net_request;
+	int result, irq;
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_IRQ;
+	co_passage_page->params[0] = type;
+	co_switch_wrapper();
+	irq = co_passage_page->params[0];
+	co_passage_page_release(flags);
+	result = co_passage_page->params[1];
+
+
+	return result;
+}
+#endif
+
+static int add_new(int b, int d, int f, int id, int class, int type, int irq) {
+	struct device_list *newdev;
+
+#if COPCI_DEBUG
+	printk("add_new: d: %d, f: %d, id: %d, class: %x, type: %d, irq: %d\n", d, f, id, class, type, irq);
+#endif
+	newdev = kzalloc(sizeof(struct device_list), GFP_KERNEL);
+	if (!newdev) {
+		printk(KERN_ERR "COPCI: no memory for device info!\n");
+		return -ENOMEM;
+	}
+	memset(newdev, 0, sizeof(*newdev));
+	newdev->type = type;
+	newdev->bus = b;
+	newdev->device = d;
+	newdev->func = f;
+	pci_short(newdev->regs, PCI_VENDOR_ID) = PCI_VENDOR_ID_CO;
+	pci_short(newdev->regs, PCI_DEVICE_ID) = id;
+	pci_short(newdev->regs, PCI_COMMAND) = PCI_COMMAND_FAST_BACK;
+	pci_short(newdev->regs, PCI_STATUS) = (PCI_STATUS_FAST_BACK | PCI_STATUS_DEVSEL_FAST);
+	pci_short(newdev->regs, PCI_HEADER_TYPE) = 0x80;
+	pci_short(newdev->regs, PCI_CLASS_DEVICE) = class;
+	pci_byte(newdev->regs, PCI_INTERRUPT_LINE) = irq;
+	pci_byte(newdev->regs, PCI_INTERRUPT_PIN) = 1;
+	if (devices) {
+		last_device->next = newdev;
+		last_device = newdev;
+	} else {
+		devices = newdev;
+		last_device = newdev;
+	}
+
+	return 0;
+}
+
+void pci_cooperative_init(void) {
+	struct device_list *dp;
+	copci_config_t *host_cp, *guest_cp, *cp;
+	unsigned char addr[6];
+	unsigned long flags;
+	int x,id,class,count,unit,irq;
+	const int max_count = COPCI_MAX_SLOTS * COPCI_MAX_FUNCS;
+
+#if COPCI_DEBUG
+	printk(KERN_INFO "COPCI: Initializing max slots:%d max func:%d size:%d\n",
+		COPCI_MAX_SLOTS, COPCI_MAX_FUNCS, COPCI_MAX_SLOTS*COPCI_MAX_FUNCS*sizeof(*cp));
+#endif
+
+	guest_cp = kmalloc(max_count * sizeof(*cp), GFP_KERNEL);
+	BUG_ON(!guest_cp);
+
+	/* Get our config */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_PCI;
+	co_passage_page->params[1] = COPCI_GET_CONFIG;
+	co_passage_page->params[2] = 0;
+	co_switch_wrapper();
+	count = co_passage_page->params[0];
+	BUG_ON(count>max_count);
+	host_cp = (copci_config_t *) &co_passage_page->params[1];
+	memcpy(guest_cp, host_cp, count * sizeof(*cp));
+	co_passage_page_release(flags);
+
+	cp = guest_cp;
+	for(x=0; x < count; x++, cp++) {
+		switch(cp->type) {
+#ifdef CONFIG_COOPERATIVE_VIDEO
+		case CO_DEVICE_VIDEO:
+			id = PCI_DEVICE_ID_COVIDEO;
+			class = PCI_CLASS_DISPLAY_OTHER;
+			irq = 0;
+			break;
+#endif
+#ifdef CONFIG_COOPERATIVE_AUDIO
+		case CO_DEVICE_AUDIO:
+			id = PCI_DEVICE_ID_COAUDIO;
+			class = PCI_CLASS_MULTIMEDIA_AUDIO;
+			irq = SOUND_IRQ;
+			break;
+#endif
+		case CO_DEVICE_SCSI:
+			id = PCI_DEVICE_ID_COSCSI;
+			class = PCI_CLASS_STORAGE_SCSI;
+			irq = SCSI_IRQ;
+			break;
+#ifdef CO_DEVICE_IDE
+		case CO_DEVICE_IDE:
+			id = PCI_DEVICE_ID_COIDE;
+			class = PCI_CLASS_STORAGE_IDE;
+			irq = 0x14;
+			break;
+#endif
+		case CO_DEVICE_NETWORK:
+			id = PCI_DEVICE_ID_CONET;
+			class = PCI_CLASS_NETWORK_ETHERNET;
+			irq = NETWORK_IRQ;
+			break;
+		default:
+			id = class = irq = 0;
+		}
+		if (id) {
+			add_new(0, cp->dev, cp->func, id, class, cp->type, irq);
+			pci_byte(last_device->regs, PCI_CO_UNIT) = cp->unit;
+		}
+	}
+	kfree(guest_cp);
+
+#if COPCI_DEBUG
+	printk(KERN_INFO "COPCI: config:\n");
+	for(dp = devices; dp; dp = dp->next)
+		printk(KERN_INFO "dev: %d, func: %d, type: %d\n", dp->device, dp->func, dp->type);
+#endif
+
+	/* For each network device, get the HW address */
+	for(dp = devices; dp; dp = dp->next) {
+		if (dp->type == CO_DEVICE_NETWORK) {
+			unit = pci_byte(dp->regs, PCI_CO_UNIT);
+			if (get_mac(unit, addr) != 0) {
+#if COPCI_DEBUG
+				printk(KERN_INFO "COPCI: got MAC for host unit %d\n", unit);
+#endif
+				pci_byte(dp->regs, PCI_CO_MAC1) = addr[0];
+				pci_byte(dp->regs, PCI_CO_MAC2) = addr[1];
+				pci_byte(dp->regs, PCI_CO_MAC3) = addr[2];
+				pci_byte(dp->regs, PCI_CO_MAC4) = addr[3];
+				pci_byte(dp->regs, PCI_CO_MAC5) = addr[4];
+				pci_byte(dp->regs, PCI_CO_MAC6) = addr[5];
+			}
+		}
+	}
+
+	raw_pci_ops = &copci_ops;
+}
Index: linux-2.6.25-source/arch/x86/pci/irq_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/arch/x86/pci/irq_cooperative.c
@@ -0,0 +1,26 @@
+/*
+ *	Low-Level PCI Support for PC -- Routing of Interrupts
+ *
+ *	(c) 1999--2000 Martin Mares <mj@ucw.cz>
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include "pci.h"
+
+/*
+ * Never use: 0, 1, 2 (timer, keyboard, and cascade)
+ */
+unsigned int pcibios_irq_mask = 0xfff8;
+
+static int copci_enable_irq(struct pci_dev *pdev) {
+	return 0;
+}
+
+static void copci_disable_irq(struct pci_dev *pdev) {
+	return;
+}
+
+int (*pcibios_enable_irq)(struct pci_dev *dev) = copci_enable_irq;
+void (*pcibios_disable_irq)(struct pci_dev *dev) = copci_disable_irq;
Index: linux-2.6.25-source/include/linux/cooperative_pci.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/include/linux/cooperative_pci.h
@@ -0,0 +1,22 @@
+
+#ifndef __LINUX_COOPERATIVE_PCI_H
+#define __LINUX_COOPERATIVE_PCI_H
+
+/* PCI ids */
+#define PCI_VENDOR_ID_CO        0x1a55
+#define PCI_DEVICE_ID_COVIDEO   0x0001
+#define PCI_DEVICE_ID_COIDE     0x0002
+#define PCI_DEVICE_ID_COSCSI    0x0003
+#define PCI_DEVICE_ID_COAUDIO   0x0004
+#define PCI_DEVICE_ID_CONET     0x0005
+
+/* NIC vendor registers */
+#define PCI_CO_UNIT             0x40
+#define PCI_CO_MAC1             0x41
+#define PCI_CO_MAC2             0x42
+#define PCI_CO_MAC3             0x43
+#define PCI_CO_MAC4             0x44
+#define PCI_CO_MAC5             0x45
+#define PCI_CO_MAC6             0x46
+
+#endif
Index: linux-2.6.25-source/include/linux/copci.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/include/linux/copci.h
@@ -0,0 +1,33 @@
+
+#ifndef _LINUX_COPCI_H_
+#define _LINUX_COPCI_H_
+
+#if defined(CO_KERNEL) || defined(CO_HOST_KERNEL)
+
+enum COPCI_DEVICE_REQUEST {
+	COPCI_GET_CONFIG,
+};
+
+typedef struct {
+	unsigned char dev;
+	unsigned char func;
+	unsigned char type;
+	unsigned char unit;
+} copci_config_t;
+
+#endif
+
+/* 32 devices, 8 funcs per device (fixed) */
+#define COPCI_MAX_SLOTS 32
+#define COPCI_MAX_FUNCS 8
+
+enum COPCI_DEVICE_TYPE {
+        COPCI_DT_NONE=0,
+        COPCI_DT_VIDEO,
+        COPCI_DT_AUDIO,
+        COPCI_DT_IDE,
+        COPCI_DT_SCSI,
+        COPCI_DT_NET,
+};
+
+#endif
Index: linux-2.6.25-source/drivers/scsi/coscsi.c
===================================================================
--- /dev/null
+++ linux-2.6.25-source/drivers/scsi/coscsi.c
@@ -0,0 +1,1179 @@
+/*
+ *  Copyright (C) 2008 Steve Shoecraft
+ *
+ *  Cooperative Linux SCSI Driver implementation
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/dma-mapping.h>
+#include <asm/string.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
+
+#include <linux/cdrom.h>
+#include <scsi/coscsi.h>
+
+/* Special pass through type */
+#define TYPE_PASS 0x1f
+
+#define COSCSI_VERSION "1.01"
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net>");
+MODULE_DESCRIPTION("Cooperative Linux SCSI Driver " COSCSI_VERSION);
+MODULE_LICENSE("GPL");
+
+#define COSCSI_DUMP_STATS 0
+#define COSCSI_DUMP_CONFIG 0
+#define COSCSI_DUMP_PARAMS 0
+
+#ifdef min
+#undef min
+#endif
+#define min(a,b) ((a) < (b) ? (a) : (b))
+
+/* Keep sg size to <= 1 page */
+#define COSCSI_SGSIZE ( 4096 / sizeof(struct scatterlist) )
+
+#define COSCSI_DEBUG 0
+#define COSCSI_DEBUG_PCI 0
+#define COSCSI_DEBUG_ISR 0
+#define COSCSI_DEBUG_HOST 0
+#define COSCSI_DEBUG_XFER 0
+#define COSCSI_DEBUG_COMM 0
+#define COSCSI_DEBUG_INQ 0
+#define COSCSI_DEBUG_SENSE 0
+#define COSCSI_DEBUG_PASS 0
+
+#if COSCSI_DEBUG_XFER || COSCSI_DEBUG_COMM || COSCSI_DEBUG_SENSE
+#define DUMP_DATA 1
+#else
+#define DUMP_DATA 0
+#endif
+
+/* OPs not found in scsi.h, use from cdrom.h */
+#define GET_CONFIGURATION	GPCMD_GET_CONFIGURATION
+#define GET_EVENT_STATUS	GPCMD_GET_EVENT_STATUS_NOTIFICATION
+#define READ_DISC_INFO		GPCMD_READ_DISC_INFO
+
+/* Sense codes */
+#define LOGICAL_UNIT_NOT_READY 0x4
+#define INVALID_FIELD_IN_CDB 0x24
+#define MEDIUM_NOT_PRESENT 0x3a
+
+#include "coscsi_rom.h"
+
+struct coscsi_device {
+	int unit;
+	int type;
+	coscsi_rom_t *rom;
+	unsigned long flags;
+	unsigned long long max_lba;
+	unsigned long long size;
+	void *os_handle;
+	int prevent;
+	int key;
+	int asc;
+	int asq;
+	int debug;
+	char msg[192];
+};
+typedef struct coscsi_device coscsi_device_t;
+
+/* Device flags */
+enum DEVICE_FLAG {
+	DFLAG_NONE,
+	DFLAG_DEBUG,			/* Allow debugging output for this dev */
+	DFLAG_OPEN,			/* Prevent medium removal */
+	DFLAG_CHECK,			/* Check condition */
+	DFLAG_PREVENT,			/* Prevent medium removal */
+	DFLAG_EVENT,			/* Outstanding Event */
+};
+
+#define DFLAG(d,f) ((d->flags & f) != 0)
+#define dprintk(m) if (DFLAG(dp, DFLAG_DEBUG)) printk(KERN_INFO "scsi%d: ", dp->unit), printk(KERN_INFO m)
+
+struct coscsi_worker {
+	coscsi_device_t *dp;
+	struct scsi_cmnd *scp;
+};
+typedef struct coscsi_worker coscsi_worker_t;
+
+/* Private info */
+char scsi_rev[5];
+static coscsi_device_t devices[CO_MODULE_MAX_COSCSI];
+
+#if DUMP_DATA
+static void _dump_data(int unit, char *str, void *data, int data_len) {
+	unsigned char *p;
+	int x,y,len;
+
+	printk(KERN_INFO "scsi%d: %s(%d bytes):\n",unit,str,data_len);
+	len = data_len;
+	p = data;
+	for(x=y=0; x < len; x++) {
+		printk(KERN_INFO " %02x", p[x]);
+		y++;
+		if (y > 15) {
+			printk(KERN_INFO "\n");
+			y = 0;
+		}
+	}
+	if (y) printk(KERN_INFO "\n");
+}
+#define dump_data(u, s,a,b) _dump_data(u,s,a,b)
+#else
+#define dump_data(u, s,a,b) /* noop */
+#endif
+
+static spinlock_t coscsi_isr_lock;
+
+static irqreturn_t coscsi_isr(int irq, void *dev_id)
+{
+	co_message_node_t *node_message;
+	co_linux_message_t *message;
+	co_scsi_intr_t *info;
+	struct scsi_cmnd *scp;
+
+	spin_lock(&coscsi_isr_lock);
+#if COSCSI_DEBUG_ISR
+	printk(KERN_INFO "coscsi_isr: getting messages!\n");
+#endif
+	while (co_get_message(&node_message, CO_DEVICE_SCSI)) {
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+
+		info = (co_scsi_intr_t *) &message->data;
+		scp = info->ctx;
+		scp->result = info->result;
+		scsi_set_resid(scp, info->delta);
+#if COSCSI_DEBUG_ISR
+		printk(KERN_INFO "coscsi_isr: scp: %p result: %d, delta: %d\n", scp, info->result, info->delta);
+#endif
+		scp->scsi_done(scp);
+		co_free_message(node_message);
+	}
+	spin_unlock(&coscsi_isr_lock);
+
+	return IRQ_HANDLED;
+}
+
+/****************************************************************************************************
+ *
+ *
+ * HOST functions
+ *
+ *
+ ****************************************************************************************************/
+
+/*
+ * Open handle
+*/
+static int host_open(coscsi_device_t *dp) {
+	unsigned long flags;
+	int rc = 0;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_open: handle: %p\n", dp->os_handle);
+#endif
+	if (!dp->os_handle) {
+		co_passage_page_assert_valid();
+		co_passage_page_acquire(&flags);
+		co_passage_page->operation = CO_OPERATION_DEVICE;
+		co_passage_page->params[0] = CO_DEVICE_SCSI;
+		co_passage_page->params[1] = CO_SCSI_OPEN;
+		co_passage_page->params[2] = dp->unit;
+
+		co_switch_wrapper();
+
+		rc = co_passage_page->params[0];
+		if (!rc) dp->os_handle = (void *) co_passage_page->params[1];
+		co_passage_page_release(flags);
+	}
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_open: rc: %d, handle: %p\n", rc, dp->os_handle);
+#endif
+	if (rc) printk(KERN_ERR "coscsi%d: unable to open device! rc: %x\n", dp->unit, rc);
+	return rc;
+}
+
+/*
+ * Close handle
+*/
+static int host_close(coscsi_device_t *dp) {
+	unsigned long flags;
+	int rc;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_close: handle: %p\n", dp->os_handle);
+#endif
+	if (!dp->os_handle) return 0;
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_SCSI;
+	co_passage_page->params[1] = CO_SCSI_CLOSE;
+	co_passage_page->params[2] = dp->unit;
+
+	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+	dp->os_handle = 0;
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_close: rc: %d\n", rc);
+#endif
+	return rc;
+}
+
+#if COSCSI_DUMP_STATS
+static unsigned int max_segs = 1;
+static unsigned int max_xfer = 4096;
+#endif
+
+/*
+ * Read/Write block(s)
+*/
+
+static int host_rw(coscsi_worker_t *wp, unsigned long long lba, unsigned long num, int write)
+{
+	struct scatterlist *sg = scsi_sglist(wp->scp);
+	struct scsi_cmnd *scp = wp->scp;
+	unsigned long flags;
+	co_scsi_io_t *iop;
+	int count,rc,total;
+
+#if COSCSI_DEBUG_HOST
+	if (wp->dp->debug) printk(KERN_INFO "host_rw: lba: %lld, sector_size: %d, num: %ld, write: %d\n",
+		lba, scp->device->sector_size, num, write);
+#endif
+
+	if (!wp->dp->os_handle) {
+		if (host_open(wp->dp))
+			return 1;
+	}
+
+	/* XXX needed when clustering is enabled */
+	count = dma_map_sg(&scp->device->host->shost_gendev, sg, scsi_sg_count(scp), scp->sc_data_direction);
+
+	/* Get passage page */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_SCSI;
+	co_passage_page->params[1] = CO_SCSI_IO;
+	co_passage_page->params[2] = wp->dp->unit;
+
+	/* Setup iop */
+	iop = (co_scsi_io_t *) &co_passage_page->params[3];
+	iop->scp = scp;
+	iop->offset = lba * scp->device->sector_size;
+	iop->count = count;
+	iop->write = write;
+	iop->sg = scsi_sglist(scp);
+	iop->reqlen = total = num * scp->device->sector_size;
+
+	/* Do it */
+	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+	dma_unmap_sg(&scp->device->host->shost_gendev, sg, scsi_sg_count(scp), scp->sc_data_direction);
+
+#if COSCSI_DUMP_STATS
+	if (rc == GOOD) {
+		if (count > max_segs) {
+			max_segs = count;
+			printk(KERN_WARN "COSCSI: max_segs: %d\n", max_segs);
+		}
+
+		if (total > max_xfer) {
+			max_xfer = total;
+			printk(KERN_WARN "COSCSI: max_xfer: %dKB\n", max_xfer >> 10);
+		}
+	}
+#endif
+
+#if COSCSI_DEBUG_HOST
+	if (wp->dp->debug) printk(KERN_INFO "host_rw: rc: %d\n", rc);
+#endif
+	return rc;
+}
+
+static int get_bs_bits(coscsi_device_t *dp, int sector_size) {
+	unsigned long mask = 0x80000000;
+	int bs_bits;
+
+	bs_bits = 31;
+	while(mask) {
+		if (sector_size & mask)
+			break;
+		mask >>= 1;
+		bs_bits--;
+	}
+
+	return bs_bits;
+}
+
+/*
+ * File/Device size
+*/
+static int host_size(coscsi_device_t *dp, struct scsi_cmnd *scp) {
+	unsigned long long s;
+	unsigned long flags;
+	int rc, bits;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_size: getting size...\n");
+#endif
+	if (!dp->os_handle) {
+		if (host_open(dp))
+			return 1;
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_SCSI;
+	co_passage_page->params[1] = CO_SCSI_SIZE;
+	co_passage_page->params[2] = dp->unit;
+
+	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+	dp->size = *((unsigned long long *)&co_passage_page->params[1]);
+	co_passage_page_release(flags);
+
+	bits = get_bs_bits(dp, scp->device->sector_size);
+
+	s = dp->size >> bits;
+	s *= scp->device->sector_size;
+	if (s < dp->size) s += scp->device->sector_size;
+
+	dp->max_lba = (s >> bits) - 1;
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_size: rc: %d, size: %lld, max_lba: %lld\n", rc, dp->size, dp->max_lba);
+#endif
+
+	return rc;
+}
+
+/*
+ * Pass-through
+*/
+static int host_pass(coscsi_device_t *dp, struct scsi_cmnd *scp) {
+	unsigned long flags;
+	void *buffer;
+	unsigned long buflen;
+	co_scsi_pass_t *pass;
+	int rc;
+
+	if (!dp->os_handle) {
+		if (host_open(dp))
+			return 1;
+	}
+
+	/* Scatter/Gather */
+	if (scsi_sg_count(scp)) {
+		struct scatterlist *sg;
+
+		/* Should never be more than 1 for non r/w transfers */
+		if (scsi_sg_count(scp) > 1) panic("COSCSI: host_pass: use_sg (%d) > 1!\n", scsi_sg_count(scp));
+
+		sg = scsi_sglist(scp);
+#if COSCSI_DEBUG_HOST
+		if (dp->debug) printk(KERN_INFO "host_pass: sg: page: %p, offset: %d, length: %d\n",
+			sg_page(sg), sg->offset, sg->length);
+#endif
+		buffer = sg_virt(sg);
+		buflen = sg->length;
+	/* Direct */
+	} else {
+		buffer = scsi_sglist(scp);
+		buflen = scsi_bufflen(scp);
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_SCSI;
+	co_passage_page->params[1] = CO_SCSI_PASS;
+	co_passage_page->params[2] = dp->unit;
+
+	pass = (co_scsi_pass_t *) &co_passage_page->params[3];
+	memcpy(&pass->cdb, &scp->cmnd, 16);
+	pass->cdb_len = scp->cmd_len;
+	pass->write = (scp->sc_data_direction == DMA_TO_DEVICE);
+	pass->buffer = buffer;
+	pass->buflen = buflen;
+
+	co_switch_wrapper();
+
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+#if COSCSI_DEBUG_PASS
+	if (rc == GOOD && dp->debug) dump_data(dp->unit, "host_pass", buffer, buflen);
+#endif
+
+#if COSCSI_DEBUG_HOST
+	if (dp->debug) printk(KERN_INFO "host_pass: rc: %d\n", rc);
+#endif
+
+	return rc;
+}
+
+/****************************************************************************************************
+ *
+ *
+ * SCSI functions
+ *
+ *
+ ****************************************************************************************************/
+
+static int check_condition(struct coscsi_device *dp, int key, int asc, int asq) {
+	dp->key = key;
+	dp->asc = asc;
+	dp->asq = asq;
+	return CHECK_CONDITION;
+}
+
+static int response(coscsi_worker_t *wp, void *data, int len) {
+	struct scsi_cmnd *scp = wp->scp;
+	void *buffer;
+	unsigned long buflen;
+	int act_len;
+
+	/* Scatter/Gather */
+	if (scsi_sg_count(scp)) {
+		struct scatterlist *sg;
+		int i;
+
+		/* scatter-gather list too long? */
+		BUG_ON(scsi_sg_count(scp) > COSCSI_SGSIZE);
+
+		scsi_for_each_sg(scp, sg, scsi_sg_count(scp), i) {
+#if COSCSI_DEBUG
+			if (wp->dp->debug) printk(KERN_INFO "response: sg: page: %p, offset: %d, length: %d\n",
+				sg_page(sg), sg->offset, sg->length);
+#endif
+			buffer = sg_virt(sg);
+			buflen = sg->length;
+			act_len = min(buflen, len);
+#if COSCSI_DEBUG_COMM
+			if (wp->dp->debug) dump_data(wp->dp->unit, "response", data, act_len);
+#endif
+			memcpy(buffer, data, act_len);
+			data += act_len;
+			len -= act_len;
+		}
+	/* Direct */
+	} else {
+		buffer = scsi_sglist(scp);
+		buflen = scsi_bufflen(scp);
+		if (!buflen) return GOOD;
+		act_len = min(buflen, len);
+#if COSCSI_DEBUG_COMM
+		if (wp->dp->debug) dump_data(wp->dp->unit, "response", data, act_len);
+#endif
+		memcpy(buffer, data, act_len);
+	}
+
+	return GOOD;
+}
+
+static int unit_ready(coscsi_worker_t *wp) {
+	int error, rc;
+
+	rc = GOOD;
+	error = (wp->dp->os_handle == 0 ? host_open(wp->dp) : GOOD);
+	if (error) {
+		switch(wp->dp->type) {
+		case TYPE_ROM:
+		case TYPE_TAPE:
+			rc = check_condition(wp->dp, NOT_READY, MEDIUM_NOT_PRESENT, 0x2);
+			break;
+		default:
+			rc = check_condition(wp->dp, NOT_READY, LOGICAL_UNIT_NOT_READY, 0x2);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+static int inquiry(coscsi_worker_t *wp) {
+	int x, alloc_len;
+	struct scsi_cmnd *scp = wp->scp;
+
+	alloc_len = (scp->cmnd[3] << 8) + scp->cmnd[4];
+#if COSCSI_DEBUG_INQ
+	if (wp->dp->debug) printk(KERN_INFO "scsi_inq: alloc_len: %d, buflen: %d\n", alloc_len, scsi_bufflen(scp));
+#endif
+
+	/* EVPD? */
+	if (scp->cmnd[1] & 1) {
+		coscsi_page_t *vpd = wp->dp->rom->vpd;
+		int page = scp->cmnd[2];
+
+#if COSCSI_DEBUG_INQ
+		if (wp->dp->debug) printk(KERN_INFO "scsi_inq: sending VPD page %d\n", page);
+#endif
+		/* For page 00, generate dynamically */
+		if (page == 0) {
+			unsigned char data[32];
+			int i;
+
+			memset(data, 0, sizeof(data));
+			data[0] = wp->dp->rom->std.page[0];
+			i = 4;
+			for(x=0; vpd[x].page; x++) data[i++] = vpd[x].num;
+			data[3] = i - 3;
+
+			return response(wp, data, min(alloc_len, sizeof(data)));
+		} else {
+			for(x=0; vpd[x].page; x++) {
+				if (vpd[x].num == page)
+					return response(wp, vpd[x].page, min(alloc_len, vpd[x].size));
+			}
+			return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		}
+
+	/* Standard page */
+	} else {
+		unsigned char *std = wp->dp->rom->std.page;
+
+#if COSCSI_DEBUG_INQ
+		printk(KERN_INFO "scsi_inq: sending STD page\n");
+#endif
+		strcpy((char *)&std[8], "coLinux");
+		std[1] = ((wp->dp->type == TYPE_ROM || wp->dp->type == TYPE_TAPE) ? 0x80 : 0);
+		memcpy(&std[16], wp->dp->rom->name, strlen(wp->dp->rom->name)+1);
+		memcpy(&std[32], scsi_rev, min(4, strlen(scsi_rev)+1));
+		return response(wp, std, min(alloc_len, wp->dp->rom->std.size));
+	}
+}
+
+static int read_capacity(coscsi_worker_t *wp) {
+	coscsi_device_t *dp = wp->dp;
+	struct scsi_cmnd *scp = wp->scp;
+
+	/* Get the size */
+	if (host_size(dp, scp)) return check_condition(dp, HARDWARE_ERROR, 0x3e, 1);
+
+	/* Convert to read_capacity format */
+	if (dp->max_lba > 0xfffffffe || scp->cmnd[8] & 1) {
+		dp->msg[0] = 0xff;
+		dp->msg[1] = 0xff;
+		dp->msg[2] = 0xff;
+		dp->msg[3] = 0xff;
+	} else {
+		dp->msg[0] = (wp->dp->max_lba >> 24);
+		dp->msg[1] = (wp->dp->max_lba >> 16) & 0xff;
+		dp->msg[2] = (wp->dp->max_lba >> 8) & 0xff;
+		dp->msg[3] = wp->dp->max_lba & 0xff;
+	}
+	dp->msg[4] = (scp->device->sector_size >> 24);
+	dp->msg[5] = (scp->device->sector_size >> 16) & 0xff;
+	dp->msg[6] = (scp->device->sector_size >> 8) & 0xff;
+	dp->msg[7] = scp->device->sector_size & 0xff;
+
+	return response(wp, &dp->msg, 8);
+}
+
+static int mode_sense(coscsi_worker_t *wp) {
+	unsigned char data[256],*ap;
+	int offset, bd_len, page;
+	coscsi_page_t *pages = wp->dp->rom->mode;
+	coscsi_device_t *dp = wp->dp;
+	struct scsi_cmnd *scp = wp->scp;
+	register int x;
+
+	memset(data, 0, sizeof(data));
+	offset = 4;
+	bd_len = 8;
+
+	data[2] = 0x10; /* DPOFUA */
+	data[3] = bd_len;
+
+	ap = data + offset;
+	if (dp->max_lba > 0xfffffffe) {
+		ap[0] = 0xff;
+		ap[1] = 0xff;
+		ap[2] = 0xff;
+		ap[3] = 0xff;
+	} else {
+		ap[0] = (dp->max_lba >> 24) & 0xff;
+		ap[1] = (dp->max_lba >> 16) & 0xff;
+		ap[2] = (dp->max_lba >> 8) & 0xff;
+		ap[3] = dp->max_lba & 0xff;
+	}
+	ap[5] = (scp->device->sector_size >> 16) & 0xff;
+	ap[6] = (scp->device->sector_size >> 8) & 0xff;
+	ap[7] = scp->device->sector_size & 0xff;
+
+	offset += bd_len;
+	ap = data + offset;
+#if COSCSI_DEBUG_SENSE
+	if (dp->debug) printk(KERN_INFO "mode_sense: ap: %p, offset: %d\n", ap, offset);
+#endif
+	page = scp->cmnd[2] & 0x3f;
+	if (page == 0x3f) {
+		/* All pages */
+		if (scp->cmnd[3] == 0 || scp->cmnd[3] == 0xFF) {
+			for(x=0; pages[x].page; x++) {
+#if COSCSI_DEBUG_SENSE
+				if (dp->debug) dump_data(dp->unit, "page", pages[x].page, pages[x].size);
+#endif
+				memcpy(ap, pages[x].page, pages[x].size);
+				ap += pages[x].size;
+				offset += pages[x].size;
+			}
+		} else {
+			return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		}
+	} else {
+		/* Specific page */
+		int found = 0;
+		for(x=0; pages[x].page; x++) {
+#if COSCSI_DEBUG_SENSE
+			if (dp->debug) printk(KERN_INFO "mode_sense: pages[%d].num: %d, page: %d\n", x, pages[x].num, page);
+#endif
+			if (pages[x].num == page) {
+#if COSCSI_DEBUG_SENSE
+				if (dp->debug) dump_data(dp->unit, "page", pages[x].page, pages[x].size);
+#endif
+				memcpy(ap, pages[x].page, pages[x].size);
+				offset += pages[x].size;
+				found = 1;
+				break;
+			}
+		}
+		if (!found) return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	}
+#if COSCSI_DEBUG_SENSE
+	if (dp->debug) printk(KERN_INFO "scsi_mode_sense: offset: %d\n", offset);
+#endif
+	data[0] = offset - 1;
+	return response(wp, data, min(scp->cmnd[4], offset));
+}
+
+/*
+The Logical Block Address field contains the LBA of the first block from which data shall be returned. If the
+Logical Block Address is beyond the range of recorded data, the Drive shall terminate the command with
+CHECK CONDITION status and SK/ASC/ASCQ values shall be set to ILLEGAL REQUEST/LOGICAL BLOCK
+ADDRESS OUT OF RANGE.
+*/
+
+static int read_write(coscsi_worker_t *wp) {
+	unsigned long long lba;
+	unsigned long num;
+	register unsigned char *p = wp->scp->cmnd;
+
+	lba = num = 0;
+	switch(*p) {
+	case READ_16:
+	case WRITE_16:
+		{
+			register int x;
+
+			for (x = 0; x < 8; x++) {
+				if (x) lba <<= 8;
+				lba |= (u32)(*(p+2+x));
+			}
+		}
+		num = *(p+10) << 24 | *(p+11) << 16 | *(p+12) << 8 | *(p+13);
+		break;
+	case READ_12:
+	case WRITE_12:
+		lba = (u32)(*(p+2) << 24 | *(p+3) << 16 | *(p+4) << 8 | *(p+5));
+		num = *(p+6) << 24 | *(p+7) << 16 | *(p+8) << 8 | *(p+9);
+		break;
+	case READ_10:
+	case WRITE_10:
+		lba = (u32)(*(p+2) << 24 | *(p+3) << 16 | *(p+4) << 8 | *(p+5));
+		num = *(p+7) << 8 | *(p+8);
+		break;
+	case READ_6:
+	case WRITE_6:
+		lba = (u32)((*(p+1) & 0x1f) << 16 | *(p+2) << 8 | *(p+3));
+		num = *(p+4) ? *(p+4) : 0xff;
+		break;
+	default:
+		printk(KERN_ERR "scsi%d: read_write: unknown opcode: %x\n", wp->dp->unit, *p);
+		return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	}
+
+#if COSCSI_DEBUG_XFER
+	if (wp->dp->debug) printk(KERN_INFO "read_write: lba: %lld, num: %ld\n", lba, num);
+#endif
+
+	if (host_rw(wp, lba, num, (wp->scp->cmnd[0] & 2) >> 1))
+		return check_condition(wp->dp, HARDWARE_ERROR, 0x3e, 1);
+	else
+		return GOOD;
+}
+
+static int request_sense(coscsi_worker_t *wp) {
+	coscsi_device_t *dp = wp->dp;
+
+	if (wp->scp->cmnd[1] & 1) {
+		dp->msg[0] = 0x72;
+		dp->msg[1] = dp->key;
+		dp->msg[2] = dp->asc;
+		dp->msg[3] = dp->asq;
+	} else {
+		dp->msg[0] = 0x70;
+		dp->msg[2] = dp->key;
+		dp->msg[7] = 0xa;
+		dp->msg[12] = dp->asc;
+		dp->msg[13] = dp->asq;
+	}
+	return response(wp, &dp->msg, min(wp->scp->cmnd[4], 18));
+}
+
+static int prevent_allow(coscsi_worker_t *wp) {
+	wp->dp->prevent = wp->scp->cmnd[4] & 1;
+	return GOOD;
+}
+
+static int get_config(coscsi_worker_t *wp) {
+	char buf[] = {
+		0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x10,
+		0x00,0x00,0x03,0x08,0x00,0x10,0x01,0x00,
+		0x00,0x08,0x00,0x00,0x00,0x01,0x03,0x04,
+		0x00,0x00,0x00,0x01,0x00,0x02,0x03,0x04
+	};
+
+	return response(wp, buf, sizeof(buf));
+}
+
+static int read_toc(coscsi_worker_t *wp) {
+	int msf = ((wp->scp->cmnd[1] >> 1) & 1);
+	int len = wp->scp->cmnd[7] << 8 | wp->scp->cmnd[8];
+	int start;
+	unsigned char data[12];
+
+	/* We only support format 0 when MSF is set */
+	if (msf && wp->scp->cmnd[2] & 0x0f) return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+
+	start = (msf ? 32 : 0);
+
+	/* TOC header */
+	data[0] = 0;		/* Len MSB */
+	data[1] = sizeof(data);	/* Len LSB */
+	data[2] = 1;		/* 1st track */
+	data[3] = 1;		/* Last track */
+
+	/* Track 1 descriptor */
+	data[4] = 0;		/* Reserved */
+	data[5] = 0x14;		/* ADR & CONTROL */
+	data[6] = 1;		/* Track # */
+	data[7] = 0;		/* Reserved */
+	data[8] = (start >> 24) & 0xff;	/* Start */
+	data[9] = (start >> 16) & 0xff;
+	data[10] = (start >> 8) & 0xff;
+	data[11] = start & 0xff;
+
+	return response(wp, data, min(len, sizeof(data)));
+}
+
+/*
+The Polled bit is used to select operational mode. When Polled is set to zero, the Host is requesting
+asynchronous operation. If the Drive does not support asynchronous operation, the command shall be
+terminated with CHECK CONDITION status and the values for SK/ASC/ASCQ shall be set to ILLEGAL
+REQUEST/INVALID FIELD IN CDB.
+Note 12. If Polled is zero while a Group 2 timeout command is executing, the GET EVENT STATUS
+NOTIFICATION command may be queued, but it never terminates.
+When Polled is set to one, the Host is requesting polled operation. The Drive shall return event information for
+the highest priority requested event. If no event has occurred, the Drive shall report the .No Change. event for
+the highest priority requested event class.
+*/
+
+static int event_status(coscsi_worker_t *wp) {
+	return check_condition(wp->dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+}
+
+static int coscsi_queue(struct scsi_cmnd *scp, void (*done)(struct scsi_cmnd *)) {
+	coscsi_device_t *dp;
+	coscsi_worker_t worker;
+	int rc;
+
+#if COSCSI_DEBUG
+	printk(KERN_INFO "coscsi_queue: id: %d, lun: %d, cdb[0]: 0x%02x\n",
+		scp->device->id, scp->device->lun, scp->cmnd[0]);
+#endif
+
+	/* Get device pointer */
+	dp = &devices[scp->device->id];
+
+#if COSCSI_DEBUG_COMM
+	if (dp->debug) dump_data(dp->unit, "request", &scp->cmnd, sizeof(scp->cmnd));
+#endif
+
+	/* Setup worker */
+	worker.dp = dp;
+	worker.scp = scp;
+
+	/* Do we have the requested device? */
+	if ((scp->device->id >= CO_MODULE_MAX_COSCSI) || (dp->rom == 0)) {
+		if (scp->cmnd[0] == INQUIRY) {
+			char temp[96];
+			memset(temp,0,sizeof(temp));
+			temp[0] = 0x7f;
+			temp[3] = 2;
+			temp[4] = 92;
+			scp->result = response(&worker, temp, min(scp->cmnd[4],96));
+		} else
+			scp->result = check_condition(dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+		goto req_done;
+	}
+
+	/* Set done for async funcs */
+	scp->scsi_done = done;
+
+	/* Pass-through? */
+	if (dp->type == SCSI_PTYPE_PASS) {
+		switch(scp->cmnd[0]) {
+		case READ_6:
+		case READ_10:
+		case READ_16:
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_16:
+			/* r/w may be async */
+			rc = read_write(&worker);
+#if COSCSI_ASYNC
+			if (rc == GOOD) goto req_out;
+#endif
+			break;
+		default:
+			rc = host_pass(dp, scp);
+			break;
+		}
+		scp->result = rc;
+		goto req_done;
+	}
+
+	/* Process command */
+	switch(scp->cmnd[0]) {
+	case INQUIRY:
+		scp->result = inquiry(&worker);
+		break;
+	case TEST_UNIT_READY:
+		scp->result = unit_ready(&worker);
+		break;
+	case REQUEST_SENSE:
+		scp->result = request_sense(&worker);
+		break;
+	case READ_CAPACITY:
+		scp->result = read_capacity(&worker);
+		break;
+	case REPORT_LUNS:
+		/* We only support 1 lun right now */
+		memset(dp->msg, 0, 16);
+		dp->msg[3] = 1;
+		scp->result = response(&worker, &dp->msg, 16);
+		break;
+	case MODE_SENSE:
+		scp->result = mode_sense(&worker);
+		break;
+	case ALLOW_MEDIUM_REMOVAL:
+		scp->result = prevent_allow(&worker);
+		break;
+	case READ_TOC:
+		scp->result = read_toc(&worker);
+		break;
+	case GET_CONFIGURATION:
+		scp->result = get_config(&worker);
+		break;
+	case GET_EVENT_STATUS:
+		scp->result = event_status(&worker);
+		break;
+	case READ_6:
+	case READ_10:
+	case READ_16:
+	case WRITE_6:
+	case WRITE_10:
+	case WRITE_16:
+		/* r/w may be async */
+		rc = read_write(&worker);
+#if COSCSI_ASYNC
+		if (rc == GOOD) goto req_out;
+#endif
+		scp->result = rc;
+		break;
+	case SYNCHRONIZE_CACHE:
+		scp->result = GOOD;
+		break;
+	case READ_DISC_INFO:
+		{
+			disc_information di = { 0, };
+
+			di.disc_information_length = cpu_to_be16(1);
+			/* di.erasable = 0; */
+			scp->result = response(&worker, &di, sizeof(di.disc_information_length) + 1);
+		}
+		break;
+	default:
+		printk(KERN_NOTICE "scsi%d: unhandled opcode: %x\n", dp->unit, scp->cmnd[0]);
+		scp->result = check_condition(dp, ILLEGAL_REQUEST, INVALID_FIELD_IN_CDB, 0);
+	}
+
+req_done:
+	done(scp);
+#if COSCSI_ASYNC
+req_out:
+#endif
+#if COSCSI_DEBUG_COMM
+	if (dp->debug) printk(KERN_INFO "coscsi_queue: scp->result: %02x (code: %x)\n", scp->result, scp->result & 0xffff);
+	if (dp->debug) printk(KERN_INFO "------------------------------------------------------------------------\n");
+#endif
+	return 0;
+}
+
+static int coscsi_config(struct scsi_device *sdev) {
+	switch(sdev->type) {
+	case TYPE_ROM:
+	case TYPE_WORM:
+		/* XXX required to get rid of "unaligned transfer" errors */
+		blk_queue_hardsect_size(sdev->request_queue, 2048);
+		break;
+	default:
+		break;
+	}
+
+	/* Don't have SAI_READ_CAPACITY_16 and other 16 byte commands at the moment */
+	if (sdev->type != SCSI_PTYPE_PASS)
+		sdev->scsi_level = SCSI_SPC_2;
+
+	return 0;
+}
+
+struct scsi_host_template coscsi_template = {
+	.module			= THIS_MODULE,
+	.name			= "Cooperative Linux SCSI Adapter",
+	.proc_name		= "coscsi",
+	.queuecommand		= coscsi_queue,
+	.slave_configure	= coscsi_config,
+	.this_id		= -1,
+	.sg_tablesize		= COSCSI_SGSIZE,
+	.max_sectors		= 0xFFFF,
+	.can_queue		= 65535,
+	.cmd_per_lun		= 2048,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.skip_settle_delay	= 1,
+	.max_host_blocked	= 1,
+};
+
+/****************************************************************************************************
+ *
+ *
+ * PCI functions
+ *
+ *
+ ****************************************************************************************************/
+
+/*
+ * PCI Probe - probe for a single device
+*/
+static int __devinit coscsi_pci_probe( struct pci_dev *pdev, const struct pci_device_id *ent )
+{
+	struct Scsi_Host *shost;
+	unsigned long flags;
+	coscsi_device_t *dp;
+	register int x;
+	int rc;
+
+#if COSCSI_DEBUG
+	printk(KERN_INFO "coscsi_pci_probe: adding host...\n");
+#endif
+
+	/* Get our config from the host */
+	memset(&devices, 0, sizeof(devices));
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_SCSI;
+	co_passage_page->params[1] = CO_SCSI_GET_CONFIG;
+	co_passage_page->params[2] = 0;
+	co_switch_wrapper();
+
+	/* Get the result */
+	if (!co_passage_page->params[0]) {
+		for(x=0; x < CO_MODULE_MAX_COSCSI; x++) {
+			if ((co_passage_page->params[x+1] & COSCSI_DEVICE_ENABLED) == 0)
+				continue;
+			dp = &devices[x];
+			dp->unit = x;
+			dp->type = co_passage_page->params[x+1] & 0x1f;
+			dp->debug = 1;
+			switch(dp->type) {
+			case TYPE_DISK:
+				dp->rom = &disk_rom;
+				break;
+			case TYPE_ROM:
+			case TYPE_WORM:
+				dp->rom = &cd_rom;
+				break;
+			case TYPE_PASS:
+				dp->rom = (void *) ~0L;
+				break;
+			case TYPE_MEDIUM_CHANGER:
+//				dp->rom = &changer_rom;
+				break;
+			case TYPE_TAPE:
+//				dp->rom = &tape_rom;
+				break;
+			default:
+				dp->unit = -1;
+				break;
+			}
+		}
+	}
+
+	/* Release the page */
+	co_passage_page_release(flags);
+
+#if COSCSI_DUMP_CONFIG
+	printk(KERN_INFO "SCSI: device configuration:\n");
+	for(x=0; x < CO_MODULE_MAX_COSCSI; x++) {
+		dp = &devices[x];
+		printk(KERN_INFO "scsi%02d: type: %02d, rom: %p\n", dp->unit, dp->type, dp->rom);
+	}
+#endif
+
+	/* Get shost */
+	shost = scsi_host_alloc(&coscsi_template, sizeof(void *));
+	if (!shost) {
+		printk(KERN_ERR "coscsi_pci_probe: scsi_host_alloc failed");
+		return -ENOMEM;
+	}
+
+	/* Set params */
+	shost->irq = SCSI_IRQ;
+	shost->max_id = CO_MODULE_MAX_COSCSI;
+	shost->max_lun = 1;
+	shost->max_channel = 0;
+
+#if COSCSI_DUMP_PARAMS
+#define SDUMP(s,f) printk(KERN_INFO "  %16s: %d\n", #f, (s)->f)
+	printk(KERN_INFO "COSCSI: host parameters:\n");
+	SDUMP(shost,max_id);
+	SDUMP(shost,max_lun);
+	SDUMP(shost,max_channel);
+	SDUMP(shost,unique_id);
+	SDUMP(&coscsi_template,can_queue);
+	SDUMP(&coscsi_template,cmd_per_lun);
+	SDUMP(&coscsi_template,sg_tablesize);
+	SDUMP(&coscsi_template,max_sectors);
+	SDUMP(&coscsi_template,use_clustering);
+	SDUMP(shost,use_blk_tcq);
+	SDUMP(shost,reverse_ordering);
+	SDUMP(&coscsi_template,ordered_tag);
+	SDUMP(&coscsi_template,max_host_blocked);
+#undef SDUMP
+#endif
+
+	/* Add host */
+	rc = scsi_add_host(shost, &pdev->dev);
+	if (rc) {
+		printk(KERN_ERR "coscsi_pci_probe: scsi_add_host failed");
+		goto err_put;
+	}
+	pci_set_drvdata(pdev, shost);
+
+	/* Scan devs */
+	scsi_scan_host(shost);
+
+	return 0;
+
+err_put:
+	scsi_host_put(shost);
+	return rc;
+}
+
+/*
+ * PCI Remove - hotplug removal
+*/
+static void __devexit coscsi_pci_remove(struct pci_dev *pdev)
+{
+	pci_set_drvdata(pdev, NULL);
+}
+
+/* We only support the COSCSI adapter :) */
+static struct pci_device_id coscsi_pci_ids[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_COSCSI) },
+	{ 0 }
+};
+
+static struct pci_driver coscsi_pci_driver = {
+	.name		= "coscsi",
+	.id_table	= coscsi_pci_ids,
+	.probe		= coscsi_pci_probe,			/* FIXME: Use bus_type methods */
+	.remove		= __devexit_p(coscsi_pci_remove),	/* FIXME: Use bus_type methods */
+};
+
+extern int coio_test(void);
+
+/*
+ * PCI Init - module load
+*/
+static int __init coscsi_pci_init(void) {
+	int rc;
+
+	/* XXX COSCSI_VERSION better be <= 4 bytes */
+	strncpy(scsi_rev, COSCSI_VERSION, 4);
+
+	memset(&devices, 0, sizeof(devices));
+
+	rc = request_irq(SCSI_IRQ, &coscsi_isr, IRQF_SAMPLE_RANDOM, "coscsi", NULL);
+	if (rc) {
+		printk(KERN_ERR "coscsi_pci_init: unable to get irq %d", SCSI_IRQ);
+		return rc;
+	}
+	spin_lock_init(&coscsi_isr_lock);
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_init: registering...\n");
+#endif
+	return pci_register_driver(&coscsi_pci_driver);
+}
+
+/*
+ * PCI Exit - module unload
+*/
+static void __exit coscsi_pci_exit(void) {
+	register int x;
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_exit: closing handles\n");
+#endif
+
+	/* Close the handles */
+	for(x=0; x < CO_MODULE_MAX_COSCSI; x++) host_close(&devices[x]);
+
+	/* Unmap the page */
+
+#if COSCSI_DEBUG_PCI
+	printk(KERN_INFO "coscsi_pci_exit: exiting\n");
+#endif
+	pci_unregister_driver(&coscsi_pci_driver);
+}
+
+module_init(coscsi_pci_init);
+module_exit(coscsi_pci_exit);
Index: linux-2.6.25-source/drivers/scsi/coscsi_rom.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/drivers/scsi/coscsi_rom.h
@@ -0,0 +1,142 @@
+
+#ifndef __COSCSI_ROM_H
+#define __COSCSI_ROM_H
+
+/* Mode/Inq page data */
+struct coscsi_page {
+	int num;
+	unsigned char *page;
+	int size;
+};
+typedef struct coscsi_page coscsi_page_t;
+
+#define COSCSI_ROM_PAGE(n,p) { n, p, sizeof(p) }
+
+struct coscsi_rom {
+        char *name;
+        coscsi_page_t std;
+        coscsi_page_t *vpd;
+	coscsi_page_t *mode;
+};
+typedef struct coscsi_rom coscsi_rom_t;
+
+/*
+ * Disk pages
+*/
+
+/* Standard Inquiry page */
+static unsigned char disk_std_page[] = {
+	0x00,0x00,0x05,0x02,0x5c,0x00,0x01,0x20,	/* 00 - 07 */
+	0x63,0x6f,0x4c,0x69,0x6e,0x75,0x78,0x00,	/* 08 - 15 */
+	0x43,0x4f,0x44,0x49,0x53,0x4b,0x00,0x00,	/* 16 - 23 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 24 - 31 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 32 - 39 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 40 - 47 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 48 - 55 */
+	0x00,0x00,0x00,0x77,0x00,0x14,0x03,0x3d,	/* 56 - 63 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 64 - 71 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 72 - 79 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 80 - 87 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 88 - 95 */
+};
+
+#if 0
+/* Supported VPD Pages */
+static unsigned char disk_vpd_00[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+#endif
+
+#if 0
+/* Unit Serial Number VPD page */
+static unsigned char disk_vpd_80[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+#endif
+
+/* Device Identification VPD page */
+static unsigned char disk_vpd_83[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+/* Block Limits VPD page */
+static unsigned char disk_vpd_b0[] = {
+	0x00,0xB0,0x00,0x10,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static coscsi_page_t disk_vpd_pages[] = {
+#if 0
+	COSCSI_ROM_PAGE(0x80, disk_vpd_80),		/* Unit Serial Number */
+#endif
+	COSCSI_ROM_PAGE(0x83, disk_vpd_83),		/* Device Identification */
+	COSCSI_ROM_PAGE(0xb0, disk_vpd_b0),		/* Block limits (SBC) */
+	{ 0, 0, 0 }
+};
+
+static unsigned char disk_mode_08[] = {
+	0x08, 0x12, 0x14, 0x00, 0xff, 0xff, 0x00, 0x00,
+	0xff, 0xff, 0xff, 0xff, 0x80, 0x14, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00
+};
+
+static coscsi_page_t disk_mode_pages[] = {
+	COSCSI_ROM_PAGE(0x08, disk_mode_08),
+	{ 0, 0, 0 }
+};
+
+static coscsi_rom_t disk_rom = {
+	.name =		"CODISK",
+	.std =		COSCSI_ROM_PAGE(0, disk_std_page),
+	.vpd =		disk_vpd_pages,
+	.mode =		disk_mode_pages,
+};
+
+/*
+ * CD pages
+*/
+
+static unsigned char cd_std_page[] = {
+	0x05,0x80,0x02,0x02,0x1f,0x00,0x00,0x10,	/* 00 - 07 */
+	0x4f,0x50,0x30,0x34,0x32,0x5a,0x20,0x49,	/* 08 - 15 */
+	0x52,0x53,0x30,0x36,0x50,0x20,0x20,0x20,	/* 16 - 23 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 24 - 31 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 24 - 31 */
+	0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,	/* 32 - 39 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 40 - 47 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 48 - 55 */
+	0x00,0x00,0x00,0x77,0x00,0x14,0x03,0x3d,	/* 56 - 63 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 64 - 71 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 72 - 79 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 80 - 87 */
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 88 - 95 */
+};
+
+/* Device Identification VPD page */
+static unsigned char cd_vpd_83[] = {
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,	/* 00 - 07 */
+};
+
+static coscsi_page_t cd_vpd_pages[] = {
+	COSCSI_ROM_PAGE(0x83, cd_vpd_83),		/* Device Identification */
+	{ 0, 0, 0 }
+};
+
+unsigned char cd_mode_2a[] = {
+	0x2a,0x18,0x3f,0x00,0x75,0x7f,0x29,0x00, 	/* 00 - 07 */
+	0x16,0x00,0x01,0x00,0x02,0x00,0x16,0x00,	/* 08 - 15 */
+	0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x01,	/* 16 - 23 */
+};
+
+static coscsi_page_t cd_mode_pages[] = {
+	COSCSI_ROM_PAGE(0x2a, cd_mode_2a),
+	{ 0, 0, 0 }
+};
+
+static coscsi_rom_t cd_rom = {
+	.name =		"COCD",
+	.std =		COSCSI_ROM_PAGE(0, cd_std_page),
+	.vpd = 		cd_vpd_pages,
+	.mode =		cd_mode_pages,
+};
+
+#endif
Index: linux-2.6.25-source/include/scsi/coscsi.h
===================================================================
--- /dev/null
+++ linux-2.6.25-source/include/scsi/coscsi.h
@@ -0,0 +1,66 @@
+
+#ifndef __SCSI_COSCSI_H
+#define __SCSI_COSCSI_H
+
+#if defined(CO_KERNEL) || defined(CO_HOST_KERNEL)
+
+/* Set this to 1 to enable background I/O in the host */
+#define COSCSI_ASYNC 		1
+
+typedef enum {
+	CO_SCSI_GET_CONFIG,
+	CO_SCSI_OPEN,
+	CO_SCSI_CLOSE,
+	CO_SCSI_SIZE,
+	CO_SCSI_IO,
+	CO_SCSI_PASS,
+	CO_SCSI_IOS,
+} CO_SCSI_OPS;
+
+#define COSCSI_DEVICE_ENABLED 0x80
+
+typedef struct {
+	void *scp;
+	unsigned long long offset;
+	vm_ptr_t sg;
+	int count;
+	int reqlen;
+	int write;
+} __attribute__((packed)) co_scsi_io_t;
+
+typedef struct {
+	void *ctx;
+	int result;
+	int delta;
+} __attribute__((packed)) co_scsi_intr_t;
+
+typedef struct {
+	unsigned char cdb[16];
+	unsigned cdb_len: 7;
+	unsigned write: 1;
+	vm_ptr_t buffer;
+	unsigned long buflen;
+} __attribute__((packed)) co_scsi_pass_t;
+
+#endif /* CO_KERNEL || CO_HOST_KERNEL */
+
+/* Device types */
+#define SCSI_PTYPE_DISK 		0x00
+#define SCSI_PTYPE_TAPE			0x01
+#define SCSI_PTYPE_PRINTER		0x02
+#define SCSI_PTYPE_PROC			0x03
+#define SCSI_PTYPE_WORM			0x04
+#define SCSI_PTYPE_CDDVD		0x05
+#define SCSI_PTYPE_SCANNER		0x06
+#define SCSI_PTYPE_OPTICAL		0x07
+#define SCSI_PTYPE_CHANGER		0x08
+#define SCSI_PTYPE_COMM			0x09
+#define SCSI_PTYPE_RAID			0x0C
+#define SCSI_PTYPE_ENC			0x0D
+#define SCSI_PTYPE_SDISK		0x0E
+#define SCSI_PTYPE_CARD			0x0F
+#define SCSI_PTYPE_BRIDGE		0x10
+#define SCSI_PTYPE_OSD			0x11
+#define SCSI_PTYPE_PASS			0x1F		/* Special */
+
+#endif
Index: linux-2.6.22-source/sound/pci/coaudio.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/sound/pci/coaudio.c
@@ -0,0 +1,208 @@
+
+#include <sound/driver.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/initval.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
+
+extern int pci_debug;
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net>");
+MODULE_DESCRIPTION("Cooperative Linux Audio Driver");
+MODULE_LICENSE("GPL");
+
+#define COAUDIO_DEBUG 0
+
+typedef struct {
+	struct pci_dev *pdev;
+	struct snd_card *card;
+	int irq;
+} coaudio_dev_t;
+
+static irqreturn_t coaudio_isr(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int coaudio_playback_open(struct snd_pcm_substream *substream)
+{
+        return -EIO;
+}
+
+static int coaudio_playback_close(struct snd_pcm_substream *substream)
+{
+	return -EIO;
+}
+
+static int coaudio_pcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *hw_params)
+{
+	return snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(hw_params));
+}
+
+static int coaudio_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static int coaudio_playback_prepare(struct snd_pcm_substream *substream)
+{
+	return -EIO;
+}
+
+static int coaudio_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	return -EIO;
+}
+
+static snd_pcm_uframes_t coaudio_pointer(struct snd_pcm_substream *substream)
+{
+	u16 current_ptr = 0;
+
+	return bytes_to_frames(substream->runtime, current_ptr);
+}
+
+static struct snd_pcm_ops coaudio_playback_ops = {
+	.open =		coaudio_playback_open,
+	.close =	coaudio_playback_close,
+	.ioctl =	snd_pcm_lib_ioctl,
+	.hw_params =	coaudio_pcm_hw_params,
+	.hw_free =	coaudio_pcm_hw_free,
+	.prepare =	coaudio_playback_prepare,
+	.trigger =	coaudio_trigger,
+	.pointer =	coaudio_pointer,
+};
+
+static int __devinit coaudio_new_pcm(coaudio_dev_t *dev)
+{
+	struct snd_pcm *pcm;
+	int err;
+
+	err = snd_pcm_new(dev->card, "COAUDIO", 0, 1, 1, &pcm);
+	if (err < 0) return err;
+	strcpy(pcm->name, "coaudio");
+
+	/* set operators */
+	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &coaudio_playback_ops);
+
+	/* pre-allocation of buffers */
+	snd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(dev->pdev), 64*1024, 64*1024);
+	return 0;
+}
+
+static int coaudio_dev_free(struct snd_device *device)
+{
+	struct coaudio_dev_t *dev = device->device_data;
+
+	kfree(dev);
+	return 0;
+}
+
+static struct snd_device_ops coaudio_device_ops = {
+	.dev_free = coaudio_dev_free,
+};
+
+/****************************************************************************************************
+ *
+ *
+ * PCI functions
+ *
+ *
+ ****************************************************************************************************/
+static int __devinit coaudio_pci_probe( struct pci_dev *pdev, const struct pci_device_id *ent )
+{
+	struct snd_card *card;
+	coaudio_dev_t *dev;
+	int err, irq;
+
+	irq = SOUND_IRQ;
+
+	card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, THIS_MODULE, sizeof(coaudio_dev_t));
+	if (!card) return -ENOMEM;
+
+	strcpy(card->driver, "coaudio");
+	sprintf(card->shortname, "coaudio");
+	sprintf(card->longname, "%s: Cooperative Audio Device using irq %d", card->shortname, irq);
+	if ((err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+	dev = card->private_data;
+	dev->pdev = pdev;
+	dev->card = card;
+	dev->irq = irq;
+
+	if ((err = coaudio_new_pcm(dev)) < 0) {
+		printk(KERN_WARNING "COAUDIO: could not create PCM\n");
+		snd_card_free(card);
+		kfree(dev);
+		return -EIO;
+	}
+
+	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, dev, &coaudio_device_ops)) < 0) {
+		snd_card_free(card);
+		kfree(dev);
+		return -EIO;
+	}
+
+	snd_card_set_dev(card, &pdev->dev);
+
+	if (request_irq(dev->irq, coaudio_isr, IRQF_SHARED, card->shortname, card)) {
+		printk(KERN_ERR "coaudio: unable to allocate IRQ %d\n", dev->irq);
+		snd_card_free(card);
+		kfree(dev);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static void __devexit coaudio_pci_remove(struct pci_dev *pdev)
+{
+	struct snd_card *card = pci_get_drvdata(pdev);
+	coaudio_dev_t *dev = card->private_data;
+
+	free_irq(dev->irq, card);
+        snd_card_free(card);
+        pci_set_drvdata(pdev, NULL);
+}
+
+static struct pci_device_id coaudio_pci_ids[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_COAUDIO) },
+	{ 0 }
+};
+
+static struct pci_driver coaudio_pci_driver = {
+	.name = 	"coaudio",
+	.id_table =	coaudio_pci_ids,
+	.probe =	coaudio_pci_probe,
+	.remove =	__devexit_p(coaudio_pci_remove),
+#ifdef CONFIG_PM
+	.suspend = 	coaudio_suspend,
+	.resume =	coaudio_resume,
+#endif
+};
+
+static int __init coaudio_pci_init(void)
+{
+	return pci_register_driver(&coaudio_pci_driver);
+}
+
+static void __exit coaudio_pci_exit(void)
+{
+	pci_unregister_driver(&coaudio_pci_driver);
+}
+
+module_init(coaudio_pci_init)
+module_exit(coaudio_pci_exit)
Index: linux-2.6.22-source/drivers/video/covideo.c
===================================================================
--- /dev/null
+++ linux-2.6.22-source/drivers/video/covideo.c
@@ -0,0 +1,589 @@
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/fb.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+#include <linux/cooperative_pci.h>
+
+#include <linux/covideo.h>
+
+#include <stdarg.h>
+
+MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net>");
+MODULE_DESCRIPTION("Cooperative Linux Video Driver");
+MODULE_LICENSE("GPL");
+
+#define COVIDEO_DEBUG 0
+#define COVIDEO_MEMTEST 0
+
+#if COVIDEO_DEBUG
+#define dprintk(m) printk m
+#else
+#define dprintk(m) /* noop */
+#endif
+
+/* Our info */
+struct covideo_par {
+	int unit;
+	void *buffer;
+	int size;
+	struct pci_dev *pdev;
+	struct mutex open_lock;
+};
+typedef struct covideo_par covideo_par_t;
+
+static void uprintk(int unit, char *fmt, ...) {
+	char line[1024],*p;
+	va_list ap;
+
+	sprintf(line,"covideo%d: ", unit);
+	p = line + strlen(line);
+
+	va_start(ap,fmt);
+	vsprintf(p,fmt,ap);
+	va_end(ap);
+}
+
+static struct fb_var_screeninfo covideo_default = {
+        .xres =         640,
+        .yres =         480,
+        .xres_virtual = 640,
+        .yres_virtual = 480,
+        .bits_per_pixel = 8,
+        .red =          { 0, 8, 0 },
+        .green =        { 0, 8, 0 },
+        .blue =         { 0, 8, 0 },
+        .activate =     FB_ACTIVATE_TEST,
+        .height =       -1,
+        .width =        -1,
+        .pixclock =     20000,
+        .left_margin =  64,
+        .right_margin = 64,
+        .upper_margin = 32,
+        .lower_margin = 32,
+        .hsync_len =    64,
+        .vsync_len =    2,
+        .vmode =        FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_fix_screeninfo covideo_fix = {
+        .id =           "CoVideo",
+        .type =         FB_TYPE_PACKED_PIXELS,
+        .visual =       FB_VISUAL_PSEUDOCOLOR,
+        .xpanstep =     1,
+        .ypanstep =     1,
+        .ywrapstep =    1,
+        .accel =        FB_ACCEL_NONE,
+};
+
+static int covideo_open(struct fb_info *info, int user)
+{
+	covideo_par_t *par = info->par;
+
+	printk(KERN_INFO "covideo%d: open: user: %d\n", par->unit, user);
+	return 0;
+}
+
+static int covideo_release(struct fb_info *info, int user)
+{
+	covideo_par_t *par = info->par;
+
+	printk(KERN_INFO "covideo%d: close: user: %d\n", par->unit, user);
+	return 0;
+}
+
+static u_long get_line_length(int xres_virtual, int bpp)
+{
+        u_long length;
+
+        length = xres_virtual * bpp;
+        length = (length + 31) & ~31;
+        length >>= 3;
+        return (length);
+}
+
+static int covideo_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct covideo_par *par = info->par;
+        u_long line_length;
+
+//	uprintk("checking var...\n");
+
+//	printk("check_var: xres: %d, yres: %d, bpp: %d\n", var->xres, var->yres, var->bits_per_pixel);
+
+	/* We only do 32 BPP */
+//	if (var->bits_per_pixel != 32) return -EINVAL;
+
+        /*
+         *  FB_VMODE_CONUPDATE and FB_VMODE_SMOOTH_XPAN are equal!
+         *  as FB_VMODE_SMOOTH_XPAN is only used internally
+         */
+        if (var->vmode & FB_VMODE_CONUPDATE) {
+                var->vmode |= FB_VMODE_YWRAP;
+                var->xoffset = info->var.xoffset;
+                var->yoffset = info->var.yoffset;
+        }
+
+        /*
+         *  Some very basic checks
+         */
+        if (!var->xres)
+                var->xres = 1;
+        if (!var->yres)
+                var->yres = 1;
+        if (var->xres > var->xres_virtual)
+                var->xres_virtual = var->xres;
+        if (var->yres > var->yres_virtual)
+                var->yres_virtual = var->yres;
+        if (var->bits_per_pixel <= 1)
+                var->bits_per_pixel = 1;
+        else if (var->bits_per_pixel <= 8)
+                var->bits_per_pixel = 8;
+        else if (var->bits_per_pixel <= 16)
+                var->bits_per_pixel = 16;
+        else if (var->bits_per_pixel <= 24)
+                var->bits_per_pixel = 24;
+        else if (var->bits_per_pixel <= 32)
+                var->bits_per_pixel = 32;
+        else
+                return -EINVAL;
+
+        if (var->xres_virtual < var->xoffset + var->xres)
+                var->xres_virtual = var->xoffset + var->xres;
+        if (var->yres_virtual < var->yoffset + var->yres)
+                var->yres_virtual = var->yoffset + var->yres;
+
+        line_length =
+            get_line_length(var->xres_virtual, var->bits_per_pixel);
+        if (line_length * var->yres_virtual > par->size)
+                return -ENOMEM;
+
+        /*
+         * Now that we checked it we alter var. The reason being is that the video
+         * mode passed in might not work but slight changes to it might make it
+         * work. This way we let the user know what is acceptable.
+         */
+        switch (var->bits_per_pixel) {
+        case 1:
+        case 8:
+                var->red.offset = 0;
+                var->red.length = 8;
+                var->green.offset = 0;
+                var->green.length = 8;
+                var->blue.offset = 0;
+                var->blue.length = 8;
+                var->transp.offset = 0;
+                var->transp.length = 0;
+                break;
+        case 16:                /* RGBA 5551 */
+                if (var->transp.length) {
+                        var->red.offset = 0;
+                        var->red.length = 5;
+                        var->green.offset = 5;
+                        var->green.length = 5;
+                        var->blue.offset = 10;
+                        var->blue.length = 5;
+                        var->transp.offset = 15;
+                        var->transp.length = 1;
+                } else {        /* RGB 565 */
+                        var->red.offset = 0;
+                        var->red.length = 5;
+                        var->green.offset = 5;
+                        var->green.length = 6;
+                        var->blue.offset = 11;
+                        var->blue.length = 5;
+                        var->transp.offset = 0;
+                        var->transp.length = 0;
+                }
+                break;
+        case 24:                /* RGB 888 */
+                var->red.offset = 0;
+                var->red.length = 8;
+                var->green.offset = 8;
+                var->green.length = 8;
+                var->blue.offset = 16;
+                var->blue.length = 8;
+                var->transp.offset = 0;
+                var->transp.length = 0;
+                break;
+        case 32:                /* RGBA 8888 */
+                var->red.offset = 0;
+                var->red.length = 8;
+                var->green.offset = 8;
+                var->green.length = 8;
+                var->blue.offset = 16;
+                var->blue.length = 8;
+                var->transp.offset = 24;
+                var->transp.length = 8;
+                break;
+        }
+        var->red.msb_right = 0;
+        var->green.msb_right = 0;
+        var->blue.msb_right = 0;
+        var->transp.msb_right = 0;
+
+	return 0;
+}
+
+static int covideo_set_par(struct fb_info *info)
+{
+//	struct covideo_par *par = info->par;
+
+//	uprintk(par->unit, "setting par...\n");
+
+	printk("set_par: xres: %d, yres: %d, bpp: %d\n", info->var.xres, info->var.yres, info->var.bits_per_pixel);
+        info->fix.line_length = get_line_length(info->var.xres_virtual, info->var.bits_per_pixel);
+	return 0;
+}
+
+static int covideo_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+	struct covideo_par *par = info->par;
+
+	uprintk(par->unit, "setting coloreg...\n");
+
+        if (regno >= 256)       /* no. of hw registers */
+                return 1;
+        /*
+         * Program hardware... do anything you want with transp
+         */
+
+        /* grayscale works only partially under directcolor */
+        if (info->var.grayscale) {
+                /* grayscale = 0.30*R + 0.59*G + 0.11*B */
+                red = green = blue =
+                    (red * 77 + green * 151 + blue * 28) >> 8;
+        }
+
+        /* Directcolor:
+         *   var->{color}.offset contains start of bitfield
+         *   var->{color}.length contains length of bitfield
+         *   {hardwarespecific} contains width of RAMDAC
+         *   cmap[X] is programmed to (X << red.offset) | (X << green.offset) | (X << blue.offset)
+         *   RAMDAC[X] is programmed to (red, green, blue)
+         *
+         * Pseudocolor:
+         *    uses offset = 0 && length = RAMDAC register width.
+         *    var->{color}.offset is 0
+         *    var->{color}.length contains widht of DAC
+         *    cmap is not used
+         *    RAMDAC[X] is programmed to (red, green, blue)
+         * Truecolor:
+         *    does not use DAC. Usually 3 are present.
+         *    var->{color}.offset contains start of bitfield
+         *    var->{color}.length contains length of bitfield
+         *    cmap is programmed to (red << red.offset) | (green << green.offset) |
+         *                      (blue << blue.offset) | (transp << transp.offset)
+         *    RAMDAC does not exist
+         */
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+        switch (info->fix.visual) {
+        case FB_VISUAL_TRUECOLOR:
+        case FB_VISUAL_PSEUDOCOLOR:
+                red = CNVT_TOHW(red, info->var.red.length);
+                green = CNVT_TOHW(green, info->var.green.length);
+                blue = CNVT_TOHW(blue, info->var.blue.length);
+                transp = CNVT_TOHW(transp, info->var.transp.length);
+                break;
+        case FB_VISUAL_DIRECTCOLOR:
+                red = CNVT_TOHW(red, 8);        /* expect 8 bit DAC */
+                green = CNVT_TOHW(green, 8);
+                blue = CNVT_TOHW(blue, 8);
+                /* hey, there is bug in transp handling... */
+                transp = CNVT_TOHW(transp, 8);
+                break;
+        }
+#undef CNVT_TOHW
+        /* Truecolor has hardware independent palette */
+        if (info->fix.visual == FB_VISUAL_TRUECOLOR) {
+                u32 v;
+
+                if (regno >= 16)
+                        return 1;
+
+                v = (red << info->var.red.offset) |
+                    (green << info->var.green.offset) |
+                    (blue << info->var.blue.offset) |
+                    (transp << info->var.transp.offset);
+                switch (info->var.bits_per_pixel) {
+                case 8:
+                        break;
+                case 16:
+                        ((u32 *) (info->pseudo_palette))[regno] = v;
+                        break;
+                case 24:
+                case 32:
+                        ((u32 *) (info->pseudo_palette))[regno] = v;
+                        break;
+                }
+        }
+
+	return 0;
+}
+
+static int covideo_blank(int blank_mode, struct fb_info *info)
+{
+	return 0;
+}
+
+static int covideo_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+        unsigned long start = vma->vm_start;
+        unsigned long size  = vma->vm_end-vma->vm_start;
+        unsigned long page, pos;
+
+	if (size > info->screen_size) return -EINVAL;
+
+        pos = (unsigned long) info->screen_base;
+        while (size > 0) {
+                page = vmalloc_to_pfn((void *)pos);
+                if (remap_pfn_range(vma, start, page, PAGE_SIZE, PAGE_SHARED))
+                        return -EAGAIN;
+
+                start += PAGE_SIZE;
+                pos += PAGE_SIZE;
+                if (size > PAGE_SIZE)
+                        size -= PAGE_SIZE;
+                else
+                        size = 0;
+        }
+
+        return 0;
+}
+
+/* Frame buffer operations */
+static struct fb_ops covideo_ops = {
+	.owner		= THIS_MODULE,
+	.fb_open	= covideo_open,
+	.fb_release	= covideo_release,
+	.fb_read	= fb_sys_read,
+	.fb_write	= fb_sys_write,
+	.fb_check_var	= covideo_check_var,
+	.fb_set_par	= covideo_set_par,
+	.fb_setcolreg	= covideo_setcolreg,
+	.fb_blank	= covideo_blank,
+	.fb_fillrect	= sys_fillrect,
+	.fb_copyarea	= sys_copyarea,
+	.fb_imageblit	= sys_imageblit,
+	.fb_mmap	= covideo_mmap,
+
+#if 0
+	/* XXX currently not implemented */
+	.fb_setcmap	= covideo_setcmap,
+	.fb_pan_display = covideo_pan_display,
+	.fb_cursor	= covideo_cursor,
+	.fb_rotate 	= covideo_rotate,
+        .fb_get_caps    = svga_get_caps,
+#endif
+};
+
+#if COVIDEO_MEMTEST
+/* Simple page-level checkerboard test */
+static int test_buffer(void *buffer, int unit, int size) {
+	unsigned char *p, *t, *t0, *t1;
+	unsigned long flags;
+	int npages,rc;
+	register int i;
+
+	printk(KERN_INFO "covideo%d: testing buffer at 0x%p (size: %d)\n", unit, buffer, size);
+	rc = 1;
+	t1 = 0;
+	if ((t0 = kmalloc(PAGE_SIZE, GFP_KERNEL)) == 0) goto test_out;
+	memset(t0, 0, PAGE_SIZE);
+	if ((t1 = kmalloc(PAGE_SIZE, GFP_KERNEL)) == 0) goto test_out;
+	memset(t1, 0xFF, PAGE_SIZE);
+	npages = size >> PAGE_SHIFT;
+
+	p = buffer;
+	for(i=0; i < npages; i++) {
+		t = (i & 1 ? t1 : t0);
+		memcpy(p, t, PAGE_SIZE);
+		p += PAGE_SIZE;
+	}
+
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_VIDEO;
+	co_passage_page->params[1] = CO_VIDEO_TEST;
+	co_passage_page->params[2] = unit;
+	co_switch_wrapper();
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+
+	/* Fail on host side? */
+	if (rc) goto test_out;
+
+	p = buffer;
+	for(i=0; i < npages; i++) {
+		t = (i & 1 ? t0 : t1);
+		if (memcmp(p, t, PAGE_SIZE) != 0)
+			goto test_out;
+		p += PAGE_SIZE;
+	}
+
+	rc = 0;
+
+test_out:
+	if (t0) kfree(t0);
+	if (t1) kfree(t1);
+	printk(KERN_INFO "covideo%d: test %s!\n", unit, (rc ? "failed" : "passed"));
+	return rc;
+}
+#endif
+
+/*
+ * PCI Probe - probe for a single device
+*/
+static int __devinit covideo_pci_probe( struct pci_dev *pdev, const struct pci_device_id *id )
+{
+	unsigned long flags;
+	covideo_config_t *cp;
+        struct fb_info *info;
+        covideo_par_t *par;
+	void *host_buffer, *buffer;
+	u8 unit;
+        int rc, size;
+
+	/* Get our host unit */
+	pci_read_config_byte(pdev, PCI_CO_UNIT, &unit);
+
+	/* Get our config */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_DEVICE;
+	co_passage_page->params[0] = CO_DEVICE_VIDEO;
+	co_passage_page->params[1] = CO_VIDEO_GET_CONFIG;
+	co_passage_page->params[2] = unit;
+	co_switch_wrapper();
+	rc = co_passage_page->params[0];
+	cp = (covideo_config_t *) &co_passage_page->params[1];
+	host_buffer = cp->buffer;
+	size = cp->size;
+	co_passage_page_release(flags);
+
+	/* If unable to get size, silently skip this device */
+	if (rc) return 0;
+
+	/* Map host buffer into our space */
+	buffer = co_map_buffer(host_buffer, size);
+	if (!buffer) {
+		printk(KERN_ERR "covideo%d: unable to map video buffer!\n", unit);
+		return 0;
+	}
+
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "covideo%d: buffer: %p, size: %d\n", unit, buffer, size);
+#endif
+
+#if COVIDEO_MEMTEST
+	/* Test buffer */
+	if (test_buffer(buffer, unit, size)) return -EIO;
+#endif
+
+	/* Allocate and fill driver data structure */
+	info = framebuffer_alloc(sizeof(covideo_par_t), &pdev->dev);
+	if (!info) {
+		printk(KERN_ERR "covideo%d: framebuffer alloc failed!!", unit);
+		return -ENOMEM;
+	}
+
+	/* Need to set the base and ops before find_mode */
+	info->screen_base = (char __iomem *)buffer;
+	info->screen_size = size;
+	info->fbops = &covideo_ops;
+
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "covideo%d: calling find_mode...\n", unit);
+#endif
+	rc = fb_find_mode(&info->var, info, NULL, NULL, 0, NULL, 8);
+	if (!rc || (rc == 4)) info->var = covideo_default;
+
+	info->fix = covideo_fix;
+	info->fix.smem_start = (unsigned long) buffer;
+	info->fix.smem_len = size;
+	info->pseudo_palette = NULL;
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	rc = fb_alloc_cmap(&info->cmap, 256, 0);
+	if (rc < 0) goto err1;
+
+	rc = register_framebuffer(info);
+	if (rc < 0) goto err2;
+
+	par = info->par;
+	par->pdev = pdev;
+	par->unit = unit;
+	par->buffer = buffer;
+	par->size = size;
+	mutex_init(&par->open_lock);
+
+	printk(KERN_INFO "fb%d: Cooperative video at: %p, size: %dK\n", info->node,
+		buffer, size >> 10);
+
+	pci_set_drvdata(pdev, info);
+	return 0;
+
+err2:
+	fb_dealloc_cmap(&info->cmap);
+
+err1:
+        framebuffer_release(info);
+
+	return 0;
+}
+
+
+/*
+ * PCI Remove - hotplug removal
+*/
+static void __devexit covideo_pci_remove(struct pci_dev *pdev)
+{
+	pci_set_drvdata(pdev, NULL);
+}
+
+static struct pci_device_id covideo_pci_ids[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CO, PCI_DEVICE_ID_COVIDEO) },
+	{ 0 }
+};
+
+static struct pci_driver covideo_pci_driver = {
+	.name		= "covideo",
+	.id_table	= covideo_pci_ids,
+	.probe		= covideo_pci_probe,
+	.remove		= __devexit_p(covideo_pci_remove),
+};
+
+extern int coio_test(void);
+
+/*
+ * PCI Init - module load
+*/
+static int __init covideo_pci_init(void) {
+#if 0
+	rc = request_irq(VIDEO_IRQ, &covideo_isr, IRQF_SAMPLE_RANDOM, "covideo", NULL);
+	if (rc) {
+		printk(KERN_ERR "covideo_pci_init: unable to get irq %d", VIDEO_IRQ);
+		return rc;
+	}
+#endif
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "covideo_pci_init: registering...\n");
+#endif
+	return pci_register_driver(&covideo_pci_driver);
+}
+
+/*
+ * PCI Exit - module unload
+*/
+static void __exit covideo_pci_exit(void) {
+#if COVIDEO_DEBUG
+	printk(KERN_INFO "covideo_pci_exit: exiting\n");
+#endif
+        pci_unregister_driver(&covideo_pci_driver);
+}
+
+module_init(covideo_pci_init);
+module_exit(covideo_pci_exit);
Index: linux-2.6.22-source/include/linux/covideo.h
===================================================================
--- /dev/null
+++ linux-2.6.22-source/include/linux/covideo.h
@@ -0,0 +1,17 @@
+
+#ifndef _LINUX_COVIDEO_H_
+#define _LINUX_COVIDEO_H_
+
+enum CO_VIDEO_FUNC {
+	CO_VIDEO_GET_CONFIG,
+	CO_VIDEO_TEST,
+};
+
+struct covideo_config {
+	void *buffer;
+	int size;
+};
+
+typedef struct covideo_config covideo_config_t;
+
+#endif
# For kernel >= 2.6.28, 24-Sep-2009 download from:
# http://debian-knoppix.alioth.debian.org/sources/cloop_2.631-1.tar.gz

Index: linux-2.6.33-source/drivers/block/compressed_loop.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/drivers/block/compressed_loop.c
@@ -0,0 +1,1042 @@
+/*
+ *  compressed_loop.c: Read-only compressed loop blockdevice
+ *  hacked up by Rusty in 1999, extended and maintained by Klaus Knopper
+ *
+ *  A cloop file looks like this:
+ *  [32-bit uncompressed block size: network order]
+ *  [32-bit number of blocks (n_blocks): network order]
+ *  [64-bit file offsets of start of blocks: network order]
+ *    ...
+ *    (n_blocks + 1).
+ * n_blocks consisting of:
+ *   [compressed block]
+ *
+ * Every version greatly inspired by code seen in loop.c
+ * by Theodore Ts'o, 3/29/93.
+ *
+ * Copyright 1999-2009 by Paul `Rusty' Russell & Klaus Knopper.
+ * Redistribution of this file is permitted under the GNU Public License.
+ *
+ */
+
+#define CLOOP_NAME "cloop"
+#define CLOOP_VERSION "2.631"
+#define CLOOP_MAX 8
+
+#ifndef KBUILD_MODNAME
+#define KBUILD_MODNAME cloop
+#endif
+
+#ifndef KBUILD_BASENAME
+#define KBUILD_BASENAME cloop
+#endif
+
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/major.h>
+#include <linux/vmalloc.h>
+#include <linux/slab.h>
+#include <asm/div64.h> /* do_div() for 64bit division */
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+/* Use zlib_inflate from lib/zlib_inflate */
+#include <linux/zutil.h>
+#include <linux/loop.h>
+#include <linux/kthread.h>
+#include "compressed_loop.h"
+
+/* New License scheme */
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+#ifdef MODULE_AUTHOR
+MODULE_AUTHOR("Klaus Knopper (current maintainer), Paul Russel (initial Kernel 2.2 version)");
+#endif
+#ifdef MODULE_DESCRIPTION
+MODULE_DESCRIPTION("Transparently decompressing loopback block device");
+#endif
+
+#ifndef MIN
+#define MIN(x,y) ((x) < (y) ? (x) : (y))
+#endif
+
+#ifndef MAX
+#define MAX(x,y) ((x) > (y) ? (x) : (y))
+#endif
+
+/* Use experimental major for now */
+#define MAJOR_NR 240
+
+/* #define DEVICE_NAME CLOOP_NAME */
+/* #define DEVICE_NR(device) (MINOR(device)) */
+/* #define DEVICE_ON(device) */
+/* #define DEVICE_OFF(device) */
+/* #define DEVICE_NO_RANDOM */
+/* #define TIMEOUT_VALUE (6 * HZ) */
+
+#include <linux/blkdev.h>
+#include <linux/buffer_head.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(format, x...)
+#endif
+
+/* One file can be opened at module insertion time */
+/* insmod cloop file=/path/to/file */
+static char *file=NULL;
+static unsigned int preload=0;
+module_param(file, charp, 0);
+module_param(preload, uint, 0);
+MODULE_PARM_DESC(file, "Initial cloop image file (full path) for /dev/cloop");
+MODULE_PARM_DESC(preload, "Preload n blocks of cloop data into memory");
+
+static struct file *initial_file=NULL;
+static int cloop_major=MAJOR_NR;
+
+/* Number of buffered decompressed blocks */
+#define BUFFERED_BLOCKS 8
+struct cloop_device
+{
+ /* Copied straight from the file */
+ struct cloop_head head;
+
+ /* An array of offsets of compressed blocks within the file */
+ loff_t *offsets;
+
+ /* We buffer some uncompressed blocks for performance */
+ int buffered_blocknum[BUFFERED_BLOCKS];
+ int current_bufnum;
+ void *buffer[BUFFERED_BLOCKS];
+ void *compressed_buffer;
+ size_t preload_array_size; /* Size of pointer array in blocks */
+ size_t preload_size;       /* Number of successfully allocated blocks */
+ char **preload_cache;      /* Pointers to preloaded blocks */
+
+ z_stream zstream;
+
+ struct file   *backing_file;  /* associated file */
+ struct inode  *backing_inode; /* for bmap */
+
+ unsigned long largest_block;
+ unsigned int underlying_blksize;
+ int clo_number;
+ int refcnt;
+ struct block_device *bdev;
+ int isblkdev;
+ /* Lock for kernel block device queue */
+ spinlock_t queue_lock;
+ struct list_head clo_list;
+ struct task_struct *clo_thread;
+ wait_queue_head_t clo_event;
+ struct request_queue *clo_queue;
+ struct gendisk *clo_disk;
+ int suspended;
+ char clo_file_name[LO_NAME_SIZE];
+};
+
+static struct cloop_device cloop_dev[CLOOP_MAX];
+static const char *cloop_name=CLOOP_NAME;
+static const int cloop_max = CLOOP_MAX;
+static int cloop_count = 0;
+
+#if (!(defined(CONFIG_ZLIB_INFLATE) || defined(CONFIG_ZLIB_INFLATE_MODULE))) /* Must be compiled into kernel. */
+#error  "Invalid Kernel configuration. CONFIG_ZLIB_INFLATE support is needed for cloop."
+#endif
+
+/* Use __get_free_pages instead of vmalloc, allows up to 32 pages,
+ * 2MB in one piece */
+static void *cloop_malloc(size_t size)
+{
+ int order = get_order(size);
+ if(order <= KMALLOC_MAX_ORDER)
+   return (void *)kmalloc(size, GFP_KERNEL);
+ else if(order < MAX_ORDER)
+   return (void *)__get_free_pages(GFP_KERNEL, order);
+ return (void *)vmalloc(size);
+}
+
+static void cloop_free(void *mem, size_t size)
+{
+ int order = get_order(size);
+ if(order <= KMALLOC_MAX_ORDER)
+   kfree(mem);
+ else if(order < MAX_ORDER)
+   free_pages((unsigned long)mem, order);
+ else vfree(mem);
+}
+
+static int uncompress(struct cloop_device *clo,
+                      unsigned char *dest, unsigned long *destLen,
+                      unsigned char *source, unsigned long sourceLen)
+{
+ /* Most of this code can be found in fs/cramfs/uncompress.c */
+ int err;
+ clo->zstream.next_in = source;
+ clo->zstream.avail_in = sourceLen;
+ clo->zstream.next_out = dest;
+ clo->zstream.avail_out = *destLen;
+ err = zlib_inflateReset(&clo->zstream);
+ if (err != Z_OK)
+  {
+   printk(KERN_ERR "%s: zlib_inflateReset error %d\n", cloop_name, err);
+   zlib_inflateEnd(&clo->zstream); zlib_inflateInit(&clo->zstream);
+  }
+ err = zlib_inflate(&clo->zstream, Z_FINISH);
+ *destLen = clo->zstream.total_out;
+ if (err != Z_STREAM_END) return err;
+ return Z_OK;
+}
+
+static ssize_t cloop_read_from_file(struct cloop_device *clo, struct file *f, char *buf,
+  loff_t pos, size_t buf_len)
+{
+ size_t buf_done=0;
+ while (buf_done < buf_len)
+  {
+   size_t size = buf_len - buf_done, size_read;
+   /* kernel_read() only supports 32 bit offsets, so we use vfs_read() instead. */
+   /* int size_read = kernel_read(f, pos, buf + buf_done, size); */
+   mm_segment_t old_fs = get_fs();
+   set_fs(get_ds());
+   size_read = vfs_read(f, (void __user *)(buf + buf_done), size, &pos);
+   set_fs(old_fs);
+
+   if(size_read <= 0)
+    {
+     printk(KERN_ERR "%s: Read error %d at pos %Lu in file %s, "
+                     "%d bytes lost.\n", cloop_name, size_read, pos,
+		     file, size);
+     memset(buf + buf_len - size, 0, size);
+     break;
+    }
+   buf_done += size_read;
+  }
+ return buf_done;
+}
+
+/* This looks more complicated than it is */
+/* Returns number of block buffer to use for this request */
+static int cloop_load_buffer(struct cloop_device *clo, int blocknum)
+{
+ unsigned int buf_done = 0;
+ unsigned long buflen;
+ unsigned int buf_length;
+ int ret;
+ int i;
+ if(blocknum > ntohl(clo->head.num_blocks) || blocknum < 0)
+  {
+   printk(KERN_WARNING "%s: Invalid block number %d requested.\n",
+                       cloop_name, blocknum);
+   return -1;
+  }
+
+ /* Quick return if the block we seek is already in one of the buffers. */
+ /* Return number of buffer */
+ for(i=0; i<BUFFERED_BLOCKS; i++)
+  if (blocknum == clo->buffered_blocknum[i])
+   {
+    DEBUGP(KERN_INFO "cloop_load_buffer: Found buffered block %d\n", i);
+    return i;
+   }
+
+ buf_length = be64_to_cpu(clo->offsets[blocknum+1]) - be64_to_cpu(clo->offsets[blocknum]);
+
+/* Load one compressed block from the file. */
+ cloop_read_from_file(clo, clo->backing_file, (char *)clo->compressed_buffer,
+                    be64_to_cpu(clo->offsets[blocknum]), buf_length);
+
+ buflen = ntohl(clo->head.block_size);
+
+ /* Go to next position in the block ring buffer */
+ clo->current_bufnum++;
+ if(clo->current_bufnum >= BUFFERED_BLOCKS) clo->current_bufnum = 0;
+
+ /* Do the uncompression */
+ ret = uncompress(clo, clo->buffer[clo->current_bufnum], &buflen, clo->compressed_buffer,
+                  buf_length);
+ /* DEBUGP("cloop: buflen after uncompress: %ld\n",buflen); */
+ if (ret != 0)
+  {
+   printk(KERN_ERR "%s: zlib decompression error %i uncompressing block %u %u/%lu/%u/%u "
+          "%Lu-%Lu\n", cloop_name, ret, blocknum,
+	  ntohl(clo->head.block_size), buflen, buf_length, buf_done,
+	  be64_to_cpu(clo->offsets[blocknum]), be64_to_cpu(clo->offsets[blocknum+1]));
+   clo->buffered_blocknum[clo->current_bufnum] = -1;
+   return -1;
+  }
+ clo->buffered_blocknum[clo->current_bufnum] = blocknum;
+ return clo->current_bufnum;
+}
+
+/* This function does all the real work. */
+/* returns "uptodate" */
+static int cloop_handle_request(struct cloop_device *clo, struct request *req)
+{
+ int buffered_blocknum = -1;
+ int preloaded = 0;
+ loff_t offset     = (loff_t) blk_rq_pos(req)<<9; /* req->sector<<9 */
+ struct bio_vec *bvec;
+ struct req_iterator iter;
+ rq_for_each_segment(bvec, req, iter)
+  {
+   unsigned long len = bvec->bv_len;
+   char *to_ptr      = kmap(bvec->bv_page) + bvec->bv_offset;
+   while(len > 0)
+    {
+     u_int32_t length_in_buffer;
+     loff_t block_offset = offset;
+     u_int32_t offset_in_buffer;
+     char *from_ptr;
+     /* do_div (div64.h) returns the 64bit division remainder and  */
+     /* puts the result in the first argument, i.e. block_offset   */
+     /* becomes the blocknumber to load, and offset_in_buffer the  */
+     /* position in the buffer */
+     offset_in_buffer = do_div(block_offset, ntohl(clo->head.block_size));
+     /* Lookup preload cache */
+     if(block_offset < clo->preload_size && clo->preload_cache != NULL &&
+        clo->preload_cache[block_offset] != NULL)
+      { /* Copy from cache */
+       preloaded = 1;
+       from_ptr = clo->preload_cache[block_offset];
+      }
+     else
+      {
+       preloaded = 0;
+       buffered_blocknum = cloop_load_buffer(clo,block_offset);
+       if(buffered_blocknum == -1) break; /* invalid data, leave inner loop */
+       /* Copy from buffer */
+       from_ptr = clo->buffer[buffered_blocknum];
+      }
+     /* Now, at least part of what we want will be in the buffer. */
+     length_in_buffer = ntohl(clo->head.block_size) - offset_in_buffer;
+     if(length_in_buffer > len)
+      {
+/*   DEBUGP("Warning: length_in_buffer=%u > len=%u\n",
+                      length_in_buffer,len); */
+       length_in_buffer = len;
+      }
+     memcpy(to_ptr, from_ptr + offset_in_buffer, length_in_buffer);
+     to_ptr      += length_in_buffer;
+     len         -= length_in_buffer;
+     offset      += length_in_buffer;
+    } /* while inner loop */
+   kunmap(bvec->bv_page);
+  } /* end rq_for_each_segment*/
+ return ((buffered_blocknum!=-1) || preloaded);
+}
+
+/* Adopted from loop.c, a kernel thread to handle physical reads and
+ * decompression. */
+static int cloop_thread(void *data)
+{
+ struct cloop_device *clo = data;
+ current->flags |= PF_NOFREEZE;
+ set_user_nice(current, -15);
+ while (!kthread_should_stop()||!list_empty(&clo->clo_list))
+  {
+   int err;
+   err = wait_event_interruptible(clo->clo_event, !list_empty(&clo->clo_list) ||
+                                  kthread_should_stop());
+   if(unlikely(err))
+    {
+     DEBUGP(KERN_ERR "cloop thread activated on error!? Continuing.\n");
+     continue;
+    }
+   if(!list_empty(&clo->clo_list))
+    {
+     struct request *req;
+     unsigned long flags;
+     int uptodate;
+     spin_lock_irq(&clo->queue_lock);
+     req = list_entry(clo->clo_list.next, struct request, queuelist);
+     list_del_init(&req->queuelist);
+     spin_unlock_irq(&clo->queue_lock);
+     uptodate = cloop_handle_request(clo, req);
+     spin_lock_irqsave(&clo->queue_lock, flags);
+     __blk_end_request_all(req, uptodate ? 0 : -EIO);
+     spin_unlock_irqrestore(&clo->queue_lock, flags);
+    }
+  }
+ DEBUGP(KERN_ERR "cloop_thread exited.\n");
+ return 0;
+}
+
+/* This is called by the kernel block queue management every now and then,
+ * with successive read requests qeued and sorted in a (hopefully)
+ * "most efficient way". spin_lock_irq() is being held by the kernel. */
+static void cloop_do_request(struct request_queue *q)
+{
+ struct request *req;
+ while((req = blk_fetch_request(q)) != NULL)
+  {
+   struct cloop_device *clo;
+   int rw;
+ /* quick sanity checks */
+   if (unlikely(!blk_fs_request(req))) goto error_continue;
+   rw = rq_data_dir(req);
+   if (unlikely(rw != READ && rw != READA))
+    {
+     DEBUGP("cloop_do_request: bad command\n");
+     goto error_continue;
+    }
+   clo = req->rq_disk->private_data;
+   if (unlikely(!clo->backing_file && !clo->suspended))
+    {
+     DEBUGP("cloop_do_request: not connected to a file\n");
+     goto error_continue;
+    }
+   list_add_tail(&req->queuelist, &clo->clo_list); /* Add to working list for thread */
+   wake_up(&clo->clo_event);    /* Wake up cloop_thread */
+   continue; /* next request */
+  error_continue:
+   DEBUGP(KERN_ERR "cloop_do_request: Discarding request %p.\n", req);
+   req->errors++;
+   __blk_end_request_all(req, -EIO);
+  }
+}
+
+/* Read header and offsets from already opened file */
+static int cloop_set_file(int cloop_num, struct file *file, char *filename)
+{
+ struct cloop_device *clo=&cloop_dev[cloop_num];
+ struct inode *inode;
+ char *bbuf=NULL;
+ unsigned int i, offsets_read, total_offsets;
+ int isblkdev;
+ int error = 0;
+ inode = file->f_dentry->d_inode;
+ isblkdev=S_ISBLK(inode->i_mode)?1:0;
+ if(!isblkdev&&!S_ISREG(inode->i_mode))
+  {
+   printk(KERN_ERR "%s: %s not a regular file or block device\n",
+		   cloop_name, filename);
+   error=-EBADF; goto error_release;
+  }
+ clo->backing_file = file;
+ clo->backing_inode= inode ;
+ if(!isblkdev&&inode->i_size<sizeof(struct cloop_head))
+  {
+   printk(KERN_ERR "%s: %lu bytes (must be >= %u bytes)\n",
+                   cloop_name, (unsigned long)inode->i_size,
+		   (unsigned)sizeof(struct cloop_head));
+   error=-EBADF; goto error_release;
+  }
+ /* In suspended mode, we have done all checks necessary - FF */
+ if (clo->suspended)
+   return error;
+ if(isblkdev)
+  {
+   struct request_queue *q = bdev_get_queue(inode->i_bdev);
+   blk_queue_max_sectors(clo->clo_queue, queue_max_sectors(q));
+   blk_queue_max_phys_segments(clo->clo_queue, queue_max_phys_segments(q));
+   blk_queue_max_hw_segments(clo->clo_queue, queue_max_hw_segments(q));
+   blk_queue_max_segment_size(clo->clo_queue, queue_max_segment_size(q));
+   blk_queue_segment_boundary(clo->clo_queue, queue_segment_boundary(q));
+   blk_queue_merge_bvec(clo->clo_queue, q->merge_bvec_fn);
+   clo->underlying_blksize = block_size(inode->i_bdev);
+  }
+ else
+   clo->underlying_blksize = PAGE_SIZE;
+ DEBUGP("Underlying blocksize is %u\n", clo->underlying_blksize);
+ bbuf = cloop_malloc(clo->underlying_blksize);
+ if(!bbuf)
+  {
+   printk(KERN_ERR "%s: out of kernel mem for block buffer (%lu bytes)\n",
+                   cloop_name, (unsigned long)clo->underlying_blksize);
+   error=-ENOMEM; goto error_release;
+  }
+ total_offsets = 1; /* Dummy total_offsets: will be filled in first time around */
+ for (i = 0, offsets_read = 0; offsets_read < total_offsets; i++)
+  {
+   unsigned int offset = 0, num_readable;
+   size_t bytes_read = cloop_read_from_file(clo, file, bbuf,
+                                          i*clo->underlying_blksize,
+                                          clo->underlying_blksize);
+   if(bytes_read != clo->underlying_blksize)
+    {
+     printk(KERN_ERR "%s: Bad file, read() of first %lu bytes returned %d.\n",
+                   cloop_name, (unsigned long)clo->underlying_blksize, (int)bytes_read);
+     error=-EBADF;
+     goto error_release;
+    }
+   /* Header will be in block zero */
+   if(i==0)
+    {
+     memcpy(&clo->head, bbuf, sizeof(struct cloop_head));
+     offset = sizeof(struct cloop_head);
+     if (ntohl(clo->head.block_size) % 512 != 0)
+      {
+       printk(KERN_ERR "%s: blocksize %u not multiple of 512\n",
+              cloop_name, ntohl(clo->head.block_size));
+       error=-EBADF; goto error_release;
+      }
+     if (clo->head.preamble[0x0B]!='V'||clo->head.preamble[0x0C]<'1')
+      {
+       printk(KERN_ERR "%s: Cannot read old 32-bit (version 0.68) images, "
+		       "please use an older version of %s for this file.\n",
+		       cloop_name, cloop_name);
+       error=-EBADF; goto error_release;
+      }
+     if (clo->head.preamble[0x0C]<'2')
+      {
+       printk(KERN_ERR "%s: Cannot read old architecture-dependent "
+		       "(format <= 1.0) images, please use an older "
+		       "version of %s for this file.\n",
+		       cloop_name, cloop_name);
+       error=-EBADF; goto error_release;
+      }
+     total_offsets=ntohl(clo->head.num_blocks)+1;
+     if (!isblkdev && (sizeof(struct cloop_head)+sizeof(loff_t)*
+                       total_offsets > inode->i_size))
+      {
+       printk(KERN_ERR "%s: file too small for %u blocks\n",
+              cloop_name, ntohl(clo->head.num_blocks));
+       error=-EBADF; goto error_release;
+      }
+     clo->offsets = cloop_malloc(sizeof(loff_t) * total_offsets);
+     if (!clo->offsets)
+      {
+       printk(KERN_ERR "%s: out of kernel mem for offsets\n", cloop_name);
+       error=-ENOMEM; goto error_release;
+      }
+    }
+   num_readable = MIN(total_offsets - offsets_read,
+                      (clo->underlying_blksize - offset)
+                      / sizeof(loff_t));
+   memcpy(&clo->offsets[offsets_read], bbuf+offset, num_readable * sizeof(loff_t));
+   offsets_read += num_readable;
+  }
+  { /* Search for largest block rather than estimate. KK. */
+   int i;
+   for(i=0;i<total_offsets-1;i++)
+    {
+     loff_t d=be64_to_cpu(clo->offsets[i+1]) - be64_to_cpu(clo->offsets[i]);
+     clo->largest_block=MAX(clo->largest_block,d);
+    }
+   printk(KERN_INFO "%s: %s: %u blocks, %u bytes/block, largest block is %lu bytes.\n",
+          cloop_name, filename, ntohl(clo->head.num_blocks),
+          ntohl(clo->head.block_size), clo->largest_block);
+  }
+/* Combo kmalloc used too large chunks (>130000). */
+ {
+  int i;
+  for(i=0;i<BUFFERED_BLOCKS;i++)
+   {
+    clo->buffer[i] = cloop_malloc(ntohl(clo->head.block_size));
+    if(!clo->buffer[i])
+     {
+      printk(KERN_ERR "%s: out of memory for buffer %lu\n",
+             cloop_name, (unsigned long) ntohl(clo->head.block_size));
+      error=-ENOMEM; goto error_release_free;
+     }
+   }
+ }
+ clo->compressed_buffer = cloop_malloc(clo->largest_block);
+ if(!clo->compressed_buffer)
+  {
+   printk(KERN_ERR "%s: out of memory for compressed buffer %lu\n",
+          cloop_name, clo->largest_block);
+   error=-ENOMEM; goto error_release_free_buffer;
+  }
+ clo->zstream.workspace = cloop_malloc(zlib_inflate_workspacesize());
+ if(!clo->zstream.workspace)
+  {
+   printk(KERN_ERR "%s: out of mem for zlib working area %u\n",
+          cloop_name, zlib_inflate_workspacesize());
+   error=-ENOMEM; goto error_release_free_all;
+  }
+ zlib_inflateInit(&clo->zstream);
+ if(!isblkdev &&
+    be64_to_cpu(clo->offsets[ntohl(clo->head.num_blocks)]) != inode->i_size)
+  {
+   printk(KERN_ERR "%s: final offset wrong (%Lu not %Lu)\n",
+          cloop_name,
+          be64_to_cpu(clo->offsets[ntohl(clo->head.num_blocks)]),
+          inode->i_size);
+   cloop_free(clo->zstream.workspace, zlib_inflate_workspacesize()); clo->zstream.workspace=NULL;
+   goto error_release_free_all;
+  }
+ {
+  int i;
+  for(i=0; i<BUFFERED_BLOCKS; i++) clo->buffered_blocknum[i] = -1;
+  clo->current_bufnum=0;
+ }
+ set_capacity(clo->clo_disk, (sector_t)(ntohl(clo->head.num_blocks)*
+              (ntohl(clo->head.block_size)>>9)));
+ clo->clo_thread = kthread_create(cloop_thread, clo, "cloop%d", cloop_num);
+ if(IS_ERR(clo->clo_thread))
+  {
+   error = PTR_ERR(clo->clo_thread);
+   clo->clo_thread=NULL;
+   goto error_release_free_all;
+  }
+ if(preload > 0)
+  {
+   clo->preload_array_size = ((preload<=ntohl(clo->head.num_blocks))?preload:ntohl(clo->head.num_blocks));
+   clo->preload_size = 0;
+   if((clo->preload_cache = cloop_malloc(clo->preload_array_size * sizeof(char *))) != NULL)
+    {
+     int i;
+     for(i=0; i<clo->preload_array_size; i++)
+      {
+       if((clo->preload_cache[i] = cloop_malloc(ntohl(clo->head.block_size))) == NULL)
+        { /* Out of memory */
+         printk(KERN_WARNING "%s: cloop_malloc(%d) failed for preload_cache[%d] (ignored).\n",
+                             cloop_name, ntohl(clo->head.block_size), i);
+	 break;
+	}
+      }
+     clo->preload_size = i;
+     for(i=0; i<clo->preload_size; i++)
+      {
+       int buffered_blocknum = cloop_load_buffer(clo,i);
+       if(buffered_blocknum >= 0)
+        {
+	 memcpy(clo->preload_cache[i], clo->buffer[buffered_blocknum],
+	        ntohl(clo->head.block_size));
+	}
+       else
+        {
+         printk(KERN_WARNING "%s: can't read block %d into preload cache, set to zero.\n",
+	                     cloop_name, i);
+	 memset(clo->preload_cache[i], 0, ntohl(clo->head.block_size));
+	}
+      }
+     printk(KERN_INFO "%s: preloaded %d blocks into cache.\n", cloop_name,
+                      clo->preload_size);
+    }
+   else
+    {
+     /* It is not a fatal error if cloop_malloc(clo->preload_size)
+      * fails, then we just go without cache, but we should at least
+      * let the user know. */
+     printk(KERN_WARNING "%s: cloop_malloc(%d) failed, continuing without preloaded buffers.\n",
+            cloop_name, clo->preload_size * sizeof(char *));
+     clo->preload_array_size = clo->preload_size = 0;
+    }
+  }
+ wake_up_process(clo->clo_thread);
+ /* Uncheck */
+ return error;
+error_release_free_all:
+ cloop_free(clo->compressed_buffer, clo->largest_block);
+ clo->compressed_buffer=NULL;
+error_release_free_buffer:
+ {
+  int i;
+  for(i=0; i<BUFFERED_BLOCKS; i++)
+   {
+    if(clo->buffer[i])
+     {
+      cloop_free(clo->buffer[i], ntohl(clo->head.block_size));
+      clo->buffer[i]=NULL;
+     }
+   }
+ }
+error_release_free:
+ cloop_free(clo->offsets, sizeof(loff_t) * total_offsets);
+ clo->offsets=NULL;
+error_release:
+ if(bbuf) cloop_free(bbuf, clo->underlying_blksize);
+ clo->backing_file=NULL;
+ return error;
+}
+
+/* Get file from ioctl arg (only losetup) */
+static int cloop_set_fd(int cloop_num, struct file *clo_file,
+                        struct block_device *bdev, unsigned int arg)
+{
+ struct cloop_device *clo=&cloop_dev[cloop_num];
+ struct file *file=NULL;
+ int error = 0;
+
+ /* Already an allocated file present */
+ if(clo->backing_file) return -EBUSY;
+ file = fget(arg); /* get filp struct from ioctl arg fd */
+ if(!file) return -EBADF;
+ error=cloop_set_file(cloop_num,file,"losetup_file");
+ if(error) fput(file);
+ return error;
+}
+
+/* Drop file and free buffers, both ioctl and initial_file */
+static int cloop_clr_fd(int cloop_num, struct block_device *bdev)
+{
+ struct cloop_device *clo = &cloop_dev[cloop_num];
+ struct file *filp = clo->backing_file;
+ int i;
+ if(clo->refcnt > 1)	/* we needed one fd for the ioctl */
+   return -EBUSY;
+ if(filp==NULL) return -EINVAL;
+ if(clo->clo_thread) { kthread_stop(clo->clo_thread); clo->clo_thread=NULL; }
+ if(filp!=initial_file) fput(filp);
+ else { filp_close(initial_file,0); initial_file=NULL; }
+ clo->backing_file  = NULL;
+ clo->backing_inode = NULL;
+ if(clo->offsets) { cloop_free(clo->offsets, clo->underlying_blksize); clo->offsets = NULL; }
+ if(clo->preload_cache)
+  {
+   for(i=0; i < clo->preload_size; i++)
+    cloop_free(clo->preload_cache[i], ntohl(clo->head.block_size));
+   cloop_free(clo->preload_cache, clo->preload_array_size * sizeof(char *));
+   clo->preload_cache = NULL;
+   clo->preload_size = clo->preload_array_size = 0;
+  }
+ for(i=0; i<BUFFERED_BLOCKS; i++)
+      if(clo->buffer[i]) { cloop_free(clo->buffer[i], ntohl(clo->head.block_size)); clo->buffer[i]=NULL; }
+ if(clo->compressed_buffer) { cloop_free(clo->compressed_buffer, clo->largest_block); clo->compressed_buffer = NULL; }
+ zlib_inflateEnd(&clo->zstream);
+ if(clo->zstream.workspace) { cloop_free(clo->zstream.workspace, zlib_inflate_workspacesize()); clo->zstream.workspace = NULL; }
+ if(bdev) invalidate_bdev(bdev);
+ if(clo->clo_disk) set_capacity(clo->clo_disk, 0);
+ return 0;
+}
+
+static int clo_suspend_fd(int cloop_num)
+{
+ struct cloop_device *clo = &cloop_dev[cloop_num];
+ struct file *filp = clo->backing_file;
+ if(filp==NULL || clo->suspended) return -EINVAL;
+ /* Suspend all running requests - FF */
+ clo->suspended=1;
+ if(filp!=initial_file) fput(filp);
+ else { filp_close(initial_file,0); initial_file=NULL; }
+ clo->backing_file  = NULL;
+ clo->backing_inode = NULL;
+ return 0;
+}
+
+/* Copied from loop.c, stripped down to the really necessary */
+static int cloop_set_status(struct cloop_device *clo,
+                            const struct loop_info64 *info)
+{
+ if (!clo->backing_file) return -ENXIO;
+ memcpy(clo->clo_file_name, info->lo_file_name, LO_NAME_SIZE);
+ clo->clo_file_name[LO_NAME_SIZE-1] = 0;
+ return 0;
+}
+
+static int cloop_get_status(struct cloop_device *clo,
+                            struct loop_info64 *info)
+{
+ struct file *file = clo->backing_file;
+ struct kstat stat;
+ int err;
+ if (!file) return -ENXIO;
+ err = vfs_getattr(file->f_path.mnt, file->f_path.dentry, &stat);
+ if (err) return err;
+ memset(info, 0, sizeof(*info));
+ info->lo_number  = clo->clo_number;
+ info->lo_device  = huge_encode_dev(stat.dev);
+ info->lo_inode   = stat.ino;
+ info->lo_rdevice = huge_encode_dev(clo->isblkdev ? stat.rdev : stat.dev);
+ info->lo_offset  = 0;
+ info->lo_sizelimit = 0;
+ info->lo_flags   = 0;
+ memcpy(info->lo_file_name, clo->clo_file_name, LO_NAME_SIZE);
+ return 0;
+}
+
+static void cloop_info64_from_old(const struct loop_info *info,
+                                  struct loop_info64 *info64)
+{
+ memset(info64, 0, sizeof(*info64));
+ info64->lo_number = info->lo_number;
+ info64->lo_device = info->lo_device;
+ info64->lo_inode = info->lo_inode;
+ info64->lo_rdevice = info->lo_rdevice;
+ info64->lo_offset = info->lo_offset;
+ info64->lo_sizelimit = 0;
+ info64->lo_flags = info->lo_flags;
+ info64->lo_init[0] = info->lo_init[0];
+ info64->lo_init[1] = info->lo_init[1];
+ memcpy(info64->lo_file_name, info->lo_name, LO_NAME_SIZE);
+}
+
+static int cloop_info64_to_old(const struct loop_info64 *info64,
+                               struct loop_info *info)
+{
+ memset(info, 0, sizeof(*info));
+ info->lo_number = info64->lo_number;
+ info->lo_device = info64->lo_device;
+ info->lo_inode = info64->lo_inode;
+ info->lo_rdevice = info64->lo_rdevice;
+ info->lo_offset = info64->lo_offset;
+ info->lo_flags = info64->lo_flags;
+ info->lo_init[0] = info64->lo_init[0];
+ info->lo_init[1] = info64->lo_init[1];
+ memcpy(info->lo_name, info64->lo_file_name, LO_NAME_SIZE);
+ return 0;
+}
+
+static int cloop_set_status_old(struct cloop_device *clo,
+                                const struct loop_info __user *arg)
+{
+ struct loop_info info;
+ struct loop_info64 info64;
+
+ if (copy_from_user(&info, arg, sizeof (struct loop_info))) return -EFAULT;
+ cloop_info64_from_old(&info, &info64);
+ return cloop_set_status(clo, &info64);
+}
+
+static int cloop_set_status64(struct cloop_device *clo,
+                              const struct loop_info64 __user *arg)
+{
+ struct loop_info64 info64;
+ if (copy_from_user(&info64, arg, sizeof (struct loop_info64)))
+  return -EFAULT;
+ return cloop_set_status(clo, &info64);
+}
+
+static int cloop_get_status_old(struct cloop_device *clo,
+                                struct loop_info __user *arg)
+{
+ struct loop_info info;
+ struct loop_info64 info64;
+ int err = 0;
+
+ if (!arg) err = -EINVAL;
+ if (!err) err = cloop_get_status(clo, &info64);
+ if (!err) err = cloop_info64_to_old(&info64, &info);
+ if (!err && copy_to_user(arg, &info, sizeof(info))) err = -EFAULT;
+ return err;
+}
+
+static int cloop_get_status64(struct cloop_device *clo,
+                              struct loop_info64 __user *arg)
+{
+ struct loop_info64 info64;
+ int err = 0;
+ if (!arg) err = -EINVAL;
+ if (!err) err = cloop_get_status(clo, &info64);
+ if (!err && copy_to_user(arg, &info64, sizeof(info64))) err = -EFAULT;
+ return err;
+}
+/* EOF get/set_status */
+
+
+static int cloop_ioctl(struct block_device *bdev, fmode_t mode,
+	unsigned int cmd, unsigned long arg)
+{
+ struct cloop_device *clo;
+ int cloop_num, err=0;
+ if (!bdev) return -EINVAL;
+ cloop_num = MINOR(bdev->bd_dev);
+ if (cloop_num < 0 || cloop_num > cloop_count-1) return -ENODEV;
+ clo = &cloop_dev[cloop_num];
+ switch (cmd)
+  { /* We use the same ioctls that loop does */
+   case LOOP_CHANGE_FD:
+   case LOOP_SET_FD:
+    err = cloop_set_fd(cloop_num, NULL, bdev, arg);
+    if (err == 0 && clo->suspended)
+     {
+      /* Okay, we have again a backing file - get reqs again - FF */
+      clo->suspended=0;
+     }
+     break;
+   case LOOP_CLR_FD:
+     err = cloop_clr_fd(cloop_num, bdev);
+     break;
+   case LOOP_SET_STATUS:
+    err = cloop_set_status_old(clo, (struct loop_info __user *) arg);
+    break;
+   case LOOP_GET_STATUS:
+    err = cloop_get_status_old(clo, (struct loop_info __user *) arg);
+    break;
+   case LOOP_SET_STATUS64:
+    err = cloop_set_status64(clo, (struct loop_info64 __user *) arg);
+    break;
+   case LOOP_GET_STATUS64:
+    err = cloop_get_status64(clo, (struct loop_info64 __user *) arg);
+    break;
+   case CLOOP_SUSPEND:
+     err = clo_suspend_fd(cloop_num);
+     break;
+   default:
+     err = -EINVAL;
+  }
+ return err;
+}
+
+static int cloop_open(struct block_device *bdev, fmode_t mode)
+{
+ int cloop_num;
+ if(!bdev) return -EINVAL;
+ cloop_num=MINOR(bdev->bd_dev);
+ if(cloop_num > cloop_count-1) return -ENODEV;
+ /* Allow write open for ioctl, but not for mount. */
+ /* losetup uses write-open and flags=0x8002 to set a new file */
+ if(mode & FMODE_WRITE)
+  {
+   printk(KERN_WARNING "%s: Can't open device read-write in mode 0x%x\n", cloop_name, mode);
+   return -EROFS;
+  }
+ cloop_dev[cloop_num].refcnt+=1;
+ return 0;
+}
+
+static int cloop_close(struct gendisk *disk, fmode_t mode)
+{
+ int cloop_num, err=0;
+ if(!disk) return 0;
+ cloop_num=((struct cloop_device *)disk->private_data)->clo_number;
+ if(cloop_num < 0 || cloop_num > (cloop_count-1)) return 0;
+ cloop_dev[cloop_num].refcnt-=1;
+ return err;
+}
+
+static struct block_device_operations clo_fops =
+{
+        owner:		THIS_MODULE,
+        open:           cloop_open,
+        release:        cloop_close,
+	locked_ioctl:   cloop_ioctl
+};
+
+static int cloop_register_blkdev(int major_nr)
+{
+ return register_blkdev(major_nr, cloop_name);
+}
+
+static int cloop_unregister_blkdev(void)
+{
+ unregister_blkdev(cloop_major, cloop_name);
+ return 0;
+}
+
+static int cloop_alloc(int cloop_num)
+{
+ struct cloop_device *clo = &cloop_dev[cloop_num];
+ memset(clo, 0, sizeof(struct cloop_device));
+ clo->clo_number = cloop_num;
+ clo->clo_thread = NULL;
+ init_waitqueue_head(&clo->clo_event);
+ spin_lock_init(&clo->queue_lock);
+ INIT_LIST_HEAD(&clo->clo_list);
+ clo->clo_queue = blk_init_queue(cloop_do_request, &clo->queue_lock);
+ if(!clo->clo_queue)
+  {
+   printk(KERN_ERR "%s: Unable to alloc queue[%d]\n", cloop_name, cloop_num);
+   goto error_out;
+  }
+ clo->clo_queue->queuedata = clo;
+ clo->clo_disk = alloc_disk(1);
+ if(!clo->clo_disk)
+  {
+   printk(KERN_ERR "%s: Unable to alloc disk[%d]\n", cloop_name, cloop_num);
+   goto error_disk;
+  }
+ clo->clo_disk->major = cloop_major;
+ clo->clo_disk->first_minor = cloop_num;
+ clo->clo_disk->fops = &clo_fops;
+ clo->clo_disk->queue = clo->clo_queue;
+ clo->clo_disk->private_data = clo;
+ sprintf(clo->clo_disk->disk_name, "%s%d", cloop_name, cloop_num);
+ add_disk(clo->clo_disk);
+ return 0;
+error_disk:
+ blk_cleanup_queue(clo->clo_queue);
+error_out:
+ return -ENOMEM;
+}
+
+static void cloop_dealloc(int cloop_num)
+{
+ struct cloop_device *clo = &cloop_dev[cloop_num];
+ del_gendisk(clo->clo_disk);
+ blk_cleanup_queue(clo->clo_queue);
+ put_disk(clo->clo_disk);
+}
+
+static int __init cloop_init(void)
+{
+ int error=0;
+ printk("%s: Initializing %s v"CLOOP_VERSION"\n", cloop_name, cloop_name);
+ cloop_count=0;
+ cloop_major=MAJOR_NR;
+ if(cloop_register_blkdev(MAJOR_NR))
+  {
+   printk(KERN_WARNING "%s: Unable to get major device %d\n", cloop_name,
+          MAJOR_NR);
+   /* Try dynamic allocation */
+   if((cloop_major=cloop_register_blkdev(0))<0)
+    {
+     printk(KERN_ERR "%s: Unable to get dynamic major device\n", cloop_name);
+     return -EIO;
+    }
+   printk(KERN_INFO "%s: Got dynamic major device %d, "
+                    "mknod /dev/%s b %d 0\n",
+          cloop_name, cloop_major, cloop_name, cloop_major);
+  }
+ while(cloop_count<cloop_max)
+  if((error=cloop_alloc(cloop_count))!=0) break;
+  else ++cloop_count;
+ if(!cloop_count) goto init_out_dealloc;
+ printk(KERN_INFO "%s: loaded (max %d devices)\n", cloop_name, cloop_count);
+ if(file) /* global file name for first cloop-Device is a module option string. */
+  {
+   int namelen = strlen(file);
+   if(namelen<1 ||
+      (initial_file=filp_open(file,O_RDONLY|O_LARGEFILE,0x00))==NULL ||
+      IS_ERR(initial_file))
+    {
+     error=PTR_ERR(initial_file);
+     if(!error) error=-EINVAL;
+     initial_file=NULL; /* if IS_ERR, it's NOT open. */
+    }
+   else
+     error=cloop_set_file(0,initial_file,file);
+   if(error)
+    {
+     printk(KERN_ERR
+            "%s: Unable to get file %s for cloop device, error %d\n",
+            cloop_name, file, error);
+     goto init_out_dealloc;
+    }
+   if(namelen >= LO_NAME_SIZE) namelen = LO_NAME_SIZE-1;
+   memcpy(cloop_dev[0].clo_file_name, file, namelen);
+   cloop_dev[0].clo_file_name[namelen] = 0;
+  }
+ return 0;
+init_out_dealloc:
+ while (cloop_count>0) cloop_dealloc(--cloop_count);
+ cloop_unregister_blkdev();
+ return error;
+}
+
+static void __exit cloop_exit(void)
+{
+ int error=0;
+ if((error=cloop_unregister_blkdev())!=0)
+  {
+   printk(KERN_ERR "%s: cannot unregister block device\n", cloop_name);
+   return;
+  }
+ while(cloop_count>0)
+  {
+   --cloop_count;
+   if(cloop_dev[cloop_count].backing_file) cloop_clr_fd(cloop_count, NULL);
+   cloop_dealloc(cloop_count);
+  }
+ printk("%s: unloaded.\n", cloop_name);
+}
+
+/* The cloop init and exit function registration (especially needed for Kernel 2.6) */
+module_init(cloop_init);
+module_exit(cloop_exit);
+
+#include <linux/vermagic.h>
+#include <linux/compiler.h>
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
Index: linux-2.6.33-source/drivers/block/compressed_loop.h
===================================================================
--- /dev/null
+++ linux-2.6.33-source/drivers/block/compressed_loop.h
@@ -0,0 +1,26 @@
+#ifndef _COMPRESSED_LOOP_H
+#define _COMPRESSED_LOOP_H
+
+#define CLOOP_HEADROOM 128
+
+/* The cloop header usually looks like this:          */
+/* #!/bin/sh                                          */
+/* #V2.00 Format                                      */
+/* ...padding up to CLOOP_HEADROOM...                 */
+/* block_size (32bit number, network order)           */
+/* num_blocks (32bit number, network order)           */
+
+struct cloop_head
+{
+	char preamble[CLOOP_HEADROOM];
+	u_int32_t block_size;
+	u_int32_t num_blocks;
+};
+
+/* data_index (num_blocks 64bit pointers, network order)...      */
+/* compressed data (gzip block compressed format)...             */
+
+/* Cloop suspend IOCTL */
+#define CLOOP_SUSPEND 0x4C07
+
+#endif /*_COMPRESSED_LOOP_H*/
* Homepage: http://www.filesystems.org/project-unionfs.html
# URL: http://download.filesystems.org/unionfs/unionfs-2.x/unionfs-2.5.4_for_2.6.33.diff.gz

diff --git a/Documentation/filesystems/00-INDEX b/Documentation/filesystems/00-INDEX
index 875d496..0a9acac 100644
--- a/Documentation/filesystems/00-INDEX
+++ b/Documentation/filesystems/00-INDEX
@@ -106,6 +106,8 @@ udf.txt
 	- info and mount options for the UDF filesystem.
 ufs.txt
 	- info on the ufs filesystem.
+unionfs/
+	- info on the unionfs filesystem
 vfat.txt
 	- info on using the VFAT filesystem used in Windows NT and Windows 95
 vfs.txt
diff --git a/Documentation/filesystems/unionfs/00-INDEX b/Documentation/filesystems/unionfs/00-INDEX
new file mode 100644
index 0000000..96fdf67
--- /dev/null
+++ b/Documentation/filesystems/unionfs/00-INDEX
@@ -0,0 +1,10 @@
+00-INDEX
+	- this file.
+concepts.txt
+	- A brief introduction of concepts.
+issues.txt
+	- A summary of known issues with unionfs.
+rename.txt
+	- Information regarding rename operations.
+usage.txt
+	- Usage information and examples.
diff --git a/Documentation/filesystems/unionfs/concepts.txt b/Documentation/filesystems/unionfs/concepts.txt
new file mode 100644
index 0000000..b853788
--- /dev/null
+++ b/Documentation/filesystems/unionfs/concepts.txt
@@ -0,0 +1,287 @@
+Unionfs 2.x CONCEPTS:
+=====================
+
+This file describes the concepts needed by a namespace unification file
+system.
+
+
+Branch Priority:
+================
+
+Each branch is assigned a unique priority - starting from 0 (highest
+priority).  No two branches can have the same priority.
+
+
+Branch Mode:
+============
+
+Each branch is assigned a mode - read-write or read-only. This allows
+directories on media mounted read-write to be used in a read-only manner.
+
+
+Whiteouts:
+==========
+
+A whiteout removes a file name from the namespace. Whiteouts are needed when
+one attempts to remove a file on a read-only branch.
+
+Suppose we have a two-branch union, where branch 0 is read-write and branch
+1 is read-only. And a file 'foo' on branch 1:
+
+./b0/
+./b1/
+./b1/foo
+
+The unified view would simply be:
+
+./union/
+./union/foo
+
+Since 'foo' is stored on a read-only branch, it cannot be removed. A
+whiteout is used to remove the name 'foo' from the unified namespace. Again,
+since branch 1 is read-only, the whiteout cannot be created there. So, we
+try on a higher priority (lower numerically) branch and create the whiteout
+there.
+
+./b0/
+./b0/.wh.foo
+./b1/
+./b1/foo
+
+Later, when Unionfs traverses branches (due to lookup or readdir), it
+eliminate 'foo' from the namespace (as well as the whiteout itself.)
+
+
+Opaque Directories:
+===================
+
+Assume we have a unionfs mount comprising of two branches.  Branch 0 is
+empty; branch 1 has the directory /a and file /a/f.  Let's say we mount a
+union of branch 0 as read-write and branch 1 as read-only.  Now, let's say
+we try to perform the following operation in the union:
+
+	rm -fr a
+
+Because branch 1 is not writable, we cannot physically remove the file /a/f
+or the directory /a.  So instead, we will create a whiteout in branch 0
+named /.wh.a, masking out the name "a" from branch 1.  Next, let's say we
+try to create a directory named "a" as follows:
+
+	mkdir a
+
+Because we have a whiteout for "a" already, Unionfs behaves as if "a"
+doesn't exist, and thus will delete the whiteout and replace it with an
+actual directory named "a".
+
+The problem now is that if you try to "ls" in the union, Unionfs will
+perform is normal directory name unification, for *all* directories named
+"a" in all branches.  This will cause the file /a/f from branch 1 to
+re-appear in the union's namespace, which violates Unix semantics.
+
+To avoid this problem, we have a different form of whiteouts for
+directories, called "opaque directories" (same as BSD Union Mount does).
+Whenever we replace a whiteout with a directory, that directory is marked as
+opaque.  In Unionfs 2.x, it means that we create a file named
+/a/.wh.__dir_opaque in branch 0, after having created directory /a there.
+When unionfs notices that a directory is opaque, it stops all namespace
+operations (including merging readdir contents) at that opaque directory.
+This prevents re-exposing names from masked out directories.
+
+
+Duplicate Elimination:
+======================
+
+It is possible for files on different branches to have the same name.
+Unionfs then has to select which instance of the file to show to the user.
+Given the fact that each branch has a priority associated with it, the
+simplest solution is to take the instance from the highest priority
+(numerically lowest value) and "hide" the others.
+
+
+Unlinking:
+=========
+
+Unlink operation on non-directory instances is optimized to remove the
+maximum possible objects in case multiple underlying branches have the same
+file name.  The unlink operation will first try to delete file instances
+from highest priority branch and then move further to delete from remaining
+branches in order of their decreasing priority.  Consider a case (F..D..F),
+where F is a file and D is a directory of the same name; here, some
+intermediate branch could have an empty directory instance with the same
+name, so this operation also tries to delete this directory instance and
+proceed further to delete from next possible lower priority branch.  The
+unionfs unlink operation will smoothly delete the files with same name from
+all possible underlying branches.  In case if some error occurs, it creates
+whiteout in highest priority branch that will hide file instance in rest of
+the branches.  An error could occur either if an unlink operations in any of
+the underlying branch failed or if a branch has no write permission.
+
+This unlinking policy is known as "delete all" and it has the benefit of
+overall reducing the number of inodes used by duplicate files, and further
+reducing the total number of inodes consumed by whiteouts.  The cost is of
+extra processing, but testing shows this extra processing is well worth the
+savings.
+
+
+Copyup:
+=======
+
+When a change is made to the contents of a file's data or meta-data, they
+have to be stored somewhere.  The best way is to create a copy of the
+original file on a branch that is writable, and then redirect the write
+though to this copy.  The copy must be made on a higher priority branch so
+that lookup and readdir return this newer "version" of the file rather than
+the original (see duplicate elimination).
+
+An entire unionfs mount can be read-only or read-write.  If it's read-only,
+then none of the branches will be written to, even if some of the branches
+are physically writeable.  If the unionfs mount is read-write, then the
+leftmost (highest priority) branch must be writeable (for copyup to take
+place); the remaining branches can be any mix of read-write and read-only.
+
+In a writeable mount, unionfs will create new files/dir in the leftmost
+branch.  If one tries to modify a file in a read-only branch/media, unionfs
+will copyup the file to the leftmost branch and modify it there.  If you try
+to modify a file from a writeable branch which is not the leftmost branch,
+then unionfs will modify it in that branch; this is useful if you, say,
+unify differnet packages (e.g., apache, sendmail, ftpd, etc.) and you want
+changes to specific package files to remain logically in the directory where
+they came from.
+
+Cache Coherency:
+================
+
+Unionfs users often want to be able to modify files and directories directly
+on the lower branches, and have those changes be visible at the Unionfs
+level.  This means that data (e.g., pages) and meta-data (dentries, inodes,
+open files, etc.) have to be synchronized between the upper and lower
+layers.  In other words, the newest changes from a layer below have to be
+propagated to the Unionfs layer above.  If the two layers are not in sync, a
+cache incoherency ensues, which could lead to application failures and even
+oopses.  The Linux kernel, however, has a rather limited set of mechanisms
+to ensure this inter-layer cache coherency---so Unionfs has to do most of
+the hard work on its own.
+
+Maintaining Invariants:
+
+The way Unionfs ensures cache coherency is as follows.  At each entry point
+to a Unionfs file system method, we call a utility function to validate the
+primary objects of this method.  Generally, we call unionfs_file_revalidate
+on open files, and __unionfs_d_revalidate_chain on dentries (which also
+validates inodes).  These utility functions check to see whether the upper
+Unionfs object is in sync with any of the lower objects that it represents.
+The checks we perform include whether the Unionfs superblock has a newer
+generation number, or if any of the lower objects mtime's or ctime's are
+newer.  (Note: generation numbers change when branch-management commands are
+issued, so in a way, maintaining cache coherency is also very important for
+branch-management.)  If indeed we determine that any Unionfs object is no
+longer in sync with its lower counterparts, then we rebuild that object
+similarly to how we do so for branch-management.
+
+While rebuilding Unionfs's objects, we also purge any page mappings and
+truncate inode pages (see fs/unionfs/dentry.c:purge_inode_data).  This is to
+ensure that Unionfs will re-get the newer data from the lower branches.  We
+perform this purging only if the Unionfs operation in question is a reading
+operation; if Unionfs is performing a data writing operation (e.g., ->write,
+->commit_write, etc.) then we do NOT flush the lower mappings/pages: this is
+because (1) a self-deadlock could occur and (2) the upper Unionfs pages are
+considered more authoritative anyway, as they are newer and will overwrite
+any lower pages.
+
+Unionfs maintains the following important invariant regarding mtime's,
+ctime's, and atime's: the upper inode object's times are the max() of all of
+the lower ones.  For non-directory objects, there's only one object below,
+so the mapping is simple; for directory objects, there could me multiple
+lower objects and we have to sync up with the newest one of all the lower
+ones.  This invariant is important to maintain, especially for directories
+(besides, we need this to be POSIX compliant).  A union could comprise
+multiple writable branches, each of which could change.  If we don't reflect
+the newest possible mtime/ctime, some applications could fail.  For example,
+NFSv2/v3 exports check for newer directory mtimes on the server to determine
+if the client-side attribute cache should be purged.
+
+To maintain these important invariants, of course, Unionfs carefully
+synchronizes upper and lower times in various places.  For example, if we
+copy-up a file to a top-level branch, the parent directory where the file
+was copied up to will now have a new mtime: so after a successful copy-up,
+we sync up with the new top-level branch's parent directory mtime.
+
+Implementation:
+
+This cache-coherency implementation is efficient because it defers any
+synchronizing between the upper and lower layers until absolutely needed.
+Consider the example a common situation where users perform a lot of lower
+changes, such as untarring a whole package.  While these take place,
+typically the user doesn't access the files via Unionfs; only after the
+lower changes are done, does the user try to access the lower files.  With
+our cache-coherency implementation, the entirety of the changes to the lower
+branches will not result in a single CPU cycle spent at the Unionfs level
+until the user invokes a system call that goes through Unionfs.
+
+We have considered two alternate cache-coherency designs.  (1) Using the
+dentry/inode notify functionality to register interest in finding out about
+any lower changes.  This is a somewhat limited and also a heavy-handed
+approach which could result in many notifications to the Unionfs layer upon
+each small change at the lower layer (imagine a file being modified multiple
+times in rapid succession).  (2) Rewriting the VFS to support explicit
+callbacks from lower objects to upper objects.  We began exploring such an
+implementation, but found it to be very complicated--it would have resulted
+in massive VFS/MM changes which are unlikely to be accepted by the LKML
+community.  We therefore believe that our current cache-coherency design and
+implementation represent the best approach at this time.
+
+Limitations:
+
+Our implementation works in that as long as a user process will have caused
+Unionfs to be called, directly or indirectly, even to just do
+->d_revalidate; then we will have purged the current Unionfs data and the
+process will see the new data.  For example, a process that continually
+re-reads the same file's data will see the NEW data as soon as the lower
+file had changed, upon the next read(2) syscall (even if the file is still
+open!)  However, this doesn't work when the process re-reads the open file's
+data via mmap(2) (unless the user unmaps/closes the file and remaps/reopens
+it).  Once we respond to ->readpage(s), then the kernel maps the page into
+the process's address space and there doesn't appear to be a way to force
+the kernel to invalidate those pages/mappings, and force the process to
+re-issue ->readpage.  If there's a way to invalidate active mappings and
+force a ->readpage, let us know please (invalidate_inode_pages2 doesn't do
+the trick).
+
+Our current Unionfs code has to perform many file-revalidation calls.  It
+would be really nice if the VFS would export an optional file system hook
+->file_revalidate (similarly to dentry->d_revalidate) that will be called
+before each VFS op that has a "struct file" in it.
+
+Certain file systems have micro-second granularity (or better) for inode
+times, and asynchronous actions could cause those times to change with some
+small delay.  In such cases, Unionfs may see a changed inode time that only
+differs by a tiny fraction of a second: such a change may be a false
+positive indication that the lower object has changed, whereas if unionfs
+waits a little longer, that false indication will not be seen.  (These false
+positives are harmless, because they would at most cause unionfs to
+re-validate an object that may need no revalidation, and print a debugging
+message that clutters the console/logs.)  Therefore, to minimize the chances
+of these situations, we delay the detection of changed times by a small
+factor of a few seconds, called UNIONFS_MIN_CC_TIME (which defaults to 3
+seconds, as does NFS).  This means that we will detect the change, only a
+couple of seconds later, if indeed the time change persists in the lower
+file object.  This delayed detection has an added performance benefit: we
+reduce the number of times that unionfs has to revalidate objects, in case
+there's a lot of concurrent activity on both the upper and lower objects,
+for the same file(s).  Lastly, this delayed time attribute detection is
+similar to how NFS clients operate (e.g., acregmin).
+
+Finally, there is no way currently in Linux to prevent lower directories
+from being moved around (i.e., topology changes); there's no way to prevent
+modifications to directory sub-trees of whole file systems which are mounted
+read-write.  It is therefore possible for in-flight operations in unionfs to
+take place, while a lower directory is being moved around.  Therefore, if
+you try to, say, create a new file in a directory through unionfs, while the
+directory is being moved around directly, then the new file may get created
+in the new location where that directory was moved to.  This is a somewhat
+similar behaviour in NFS: an NFS client could be creating a new file while
+th NFS server is moving th directory around; the file will get successfully
+created in the new location.  (The one exception in unionfs is that if the
+branch is marked read-only by unionfs, then a copyup will take place.)
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/Documentation/filesystems/unionfs/issues.txt b/Documentation/filesystems/unionfs/issues.txt
new file mode 100644
index 0000000..f4b7e7e
--- /dev/null
+++ b/Documentation/filesystems/unionfs/issues.txt
@@ -0,0 +1,28 @@
+KNOWN Unionfs 2.x ISSUES:
+=========================
+
+1. Unionfs should not use lookup_one_len() on the underlying f/s as it
+   confuses NFSv4.  Currently, unionfs_lookup() passes lookup intents to the
+   lower file-system, this eliminates part of the problem.  The remaining
+   calls to lookup_one_len may need to be changed to pass an intent.  We are
+   currently introducing VFS changes to fs/namei.c's do_path_lookup() to
+   allow proper file lookup and opening in stackable file systems.
+
+2. Lockdep (a debugging feature) isn't aware of stacking, and so it
+   incorrectly complains about locking problems.  The problem boils down to
+   this: Lockdep considers all objects of a certain type to be in the same
+   class, for example, all inodes.  Lockdep doesn't like to see a lock held
+   on two inodes within the same task, and warns that it could lead to a
+   deadlock.  However, stackable file systems do precisely that: they lock
+   an upper object, and then a lower object, in a strict order to avoid
+   locking problems; in addition, Unionfs, as a fan-out file system, may
+   have to lock several lower inodes.  We are currently looking into Lockdep
+   to see how to make it aware of stackable file systems.  For now, we
+   temporarily disable lockdep when calling vfs methods on lower objects,
+   but only for those places where lockdep complained.  While this solution
+   may seem unclean, it is not without precedent: other places in the kernel
+   also do similar temporary disabling, of course after carefully having
+   checked that it is the right thing to do.  Anyway, you get any warnings
+   from Lockdep, please report them to the Unionfs maintainers.
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/Documentation/filesystems/unionfs/rename.txt b/Documentation/filesystems/unionfs/rename.txt
new file mode 100644
index 0000000..e20bb82
--- /dev/null
+++ b/Documentation/filesystems/unionfs/rename.txt
@@ -0,0 +1,31 @@
+Rename is a complex beast. The following table shows which rename(2) operations
+should succeed and which should fail.
+
+o: success
+E: error (either unionfs or vfs)
+X: EXDEV
+
+none = file does not exist
+file = file is a file
+dir  = file is a empty directory
+child= file is a non-empty directory
+wh   = file is a directory containing only whiteouts; this makes it logically
+		empty
+
+                      none    file    dir     child   wh
+file                  o       o       E       E       E
+dir                   o       E       o       E       o
+child                 X       E       X       E       X
+wh                    o       E       o       E       o
+
+
+Renaming directories:
+=====================
+
+Whenever a empty (either physically or logically) directory is being renamed,
+the following sequence of events should take place:
+
+1) Remove whiteouts from both source and destination directory
+2) Rename source to destination
+3) Make destination opaque to prevent anything under it from showing up
+
diff --git a/Documentation/filesystems/unionfs/usage.txt b/Documentation/filesystems/unionfs/usage.txt
new file mode 100644
index 0000000..1adde69
--- /dev/null
+++ b/Documentation/filesystems/unionfs/usage.txt
@@ -0,0 +1,134 @@
+Unionfs is a stackable unification file system, which can appear to merge
+the contents of several directories (branches), while keeping their physical
+content separate.  Unionfs is useful for unified source tree management,
+merged contents of split CD-ROM, merged separate software package
+directories, data grids, and more.  Unionfs allows any mix of read-only and
+read-write branches, as well as insertion and deletion of branches anywhere
+in the fan-out.  To maintain Unix semantics, Unionfs handles elimination of
+duplicates, partial-error conditions, and more.
+
+GENERAL SYNTAX
+==============
+
+# mount -t unionfs -o <OPTIONS>,<BRANCH-OPTIONS> none MOUNTPOINT
+
+OPTIONS can be any legal combination of:
+
+- ro		# mount file system read-only
+- rw		# mount file system read-write
+- remount	# remount the file system (see Branch Management below)
+- incgen	# increment generation no. (see Cache Consistency below)
+
+BRANCH-OPTIONS can be either (1) a list of branches given to the "dirs="
+option, or (2) a list of individual branch manipulation commands, combined
+with the "remount" option, and is further described in the "Branch
+Management" section below.
+
+The syntax for the "dirs=" mount option is:
+
+	dirs=branch[=ro|=rw][:...]
+
+The "dirs=" option takes a colon-delimited list of directories to compose
+the union, with an optional branch mode for each of those directories.
+Directories that come earlier (specified first, on the left) in the list
+have a higher precedence than those which come later.  Additionally,
+read-only or read-write permissions of the branch can be specified by
+appending =ro or =rw (default) to each directory.  See the Copyup section in
+concepts.txt, for a description of Unionfs's behavior when mixing read-only
+and read-write branches and mounts.
+
+Syntax:
+
+	dirs=/branch1[=ro|=rw]:/branch2[=ro|=rw]:...:/branchN[=ro|=rw]
+
+Example:
+
+	dirs=/writable_branch=rw:/read-only_branch=ro
+
+
+BRANCH MANAGEMENT
+=================
+
+Once you mount your union for the first time, using the "dirs=" option, you
+can then change the union's overall mode or reconfigure the branches, using
+the remount option, as follows.
+
+To downgrade a union from read-write to read-only:
+
+# mount -t unionfs -o remount,ro none MOUNTPOINT
+
+To upgrade a union from read-only to read-write:
+
+# mount -t unionfs -o remount,rw none MOUNTPOINT
+
+To delete a branch /foo, regardless where it is in the current union:
+
+# mount -t unionfs -o remount,del=/foo none MOUNTPOINT
+
+To insert (add) a branch /foo before /bar:
+
+# mount -t unionfs -o remount,add=/bar:/foo none MOUNTPOINT
+
+To insert (add) a branch /foo (with the "rw" mode flag) before /bar:
+
+# mount -t unionfs -o remount,add=/bar:/foo=rw none MOUNTPOINT
+
+To insert (add) a branch /foo (in "rw" mode) at the very beginning (i.e., a
+new highest-priority branch), you can use the above syntax, or use a short
+hand version as follows:
+
+# mount -t unionfs -o remount,add=/foo none MOUNTPOINT
+
+To append a branch to the very end (new lowest-priority branch):
+
+# mount -t unionfs -o remount,add=:/foo none MOUNTPOINT
+
+To append a branch to the very end (new lowest-priority branch), in
+read-only mode:
+
+# mount -t unionfs -o remount,add=:/foo=ro none MOUNTPOINT
+
+Finally, to change the mode of one existing branch, say /foo, from read-only
+to read-write, and change /bar from read-write to read-only:
+
+# mount -t unionfs -o remount,mode=/foo=rw,mode=/bar=ro none MOUNTPOINT
+
+Note: in Unionfs 2.x, you cannot set the leftmost branch to readonly because
+then Unionfs won't have any writable place for copyups to take place.
+Moreover, the VFS can get confused when it tries to modify something in a
+file system mounted read-write, but isn't permitted to write to it.
+Instead, you should set the whole union as readonly, as described above.
+If, however, you must set the leftmost branch as readonly, perhaps so you
+can get a snapshot of it at a point in time, then you should insert a new
+writable top-level branch, and mark the one you want as readonly.  This can
+be accomplished as follows, assuming that /foo is your current leftmost
+branch:
+
+# mount -t tmpfs -o size=NNN /new
+# mount -t unionfs -o remount,add=/new,mode=/foo=ro none MOUNTPOINT
+<do what you want safely in /foo>
+# mount -t unionfs -o remount,del=/new,mode=/foo=rw none MOUNTPOINT
+<check if there's anything in /new you want to preserve>
+# umount /new
+
+CACHE CONSISTENCY
+=================
+
+If you modify any file on any of the lower branches directly, while there is
+a Unionfs 2.x mounted above any of those branches, you should tell Unionfs
+to purge its caches and re-get the objects.  To do that, you have to
+increment the generation number of the superblock using the following
+command:
+
+# mount -t unionfs -o remount,incgen none MOUNTPOINT
+
+Note that the older way of incrementing the generation number using an
+ioctl, is no longer supported in Unionfs 2.0 and newer.  Ioctls in general
+are not encouraged.  Plus, an ioctl is per-file concept, whereas the
+generation number is a per-file-system concept.  Worse, such an ioctl
+requires an open file, which then has to be invalidated by the very nature
+of the generation number increase (read: the old generation increase ioctl
+was pretty racy).
+
+
+For more information, see <http://unionfs.filesystems.org/>.
diff --git a/MAINTAINERS b/MAINTAINERS
index 2533fc4..23bc981 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5446,6 +5446,14 @@ F:	Documentation/cdrom/
 F:	drivers/cdrom/cdrom.c
 F:	include/linux/cdrom.h
 
+UNIONFS
+P:	Erez Zadok
+M:	ezk@cs.sunysb.edu
+L:	unionfs@filesystems.org
+W:	http://unionfs.filesystems.org/
+T:	git git.kernel.org/pub/scm/linux/kernel/git/ezk/unionfs.git
+S:	Maintained
+
 UNSORTED BLOCK IMAGES (UBI)
 M:	Artem Bityutskiy <dedekind1@gmail.com>
 W:	http://www.linux-mtd.infradead.org/
diff --git a/fs/Kconfig b/fs/Kconfig
index 64d44ef..b69e2f2 100644
--- a/fs/Kconfig
+++ b/fs/Kconfig
@@ -169,6 +169,7 @@ if MISC_FILESYSTEMS
 source "fs/adfs/Kconfig"
 source "fs/affs/Kconfig"
 source "fs/ecryptfs/Kconfig"
+source "fs/unionfs/Kconfig"
 source "fs/hfs/Kconfig"
 source "fs/hfsplus/Kconfig"
 source "fs/befs/Kconfig"
diff --git a/fs/Makefile b/fs/Makefile
index af6d047..6c254d5 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -84,6 +84,7 @@ obj-$(CONFIG_ISO9660_FS)	+= isofs/
 obj-$(CONFIG_HFSPLUS_FS)	+= hfsplus/ # Before hfs to find wrapped HFS+
 obj-$(CONFIG_HFS_FS)		+= hfs/
 obj-$(CONFIG_ECRYPT_FS)		+= ecryptfs/
+obj-$(CONFIG_UNION_FS)		+= unionfs/
 obj-$(CONFIG_VXFS_FS)		+= freevxfs/
 obj-$(CONFIG_NFS_FS)		+= nfs/
 obj-$(CONFIG_EXPORTFS)		+= exportfs/
diff --git a/fs/namei.c b/fs/namei.c
index a4855af..948c5e5 100644
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -387,6 +387,7 @@ void release_open_intent(struct nameidata *nd)
 	else
 		fput(nd->intent.open.file);
 }
+EXPORT_SYMBOL_GPL(release_open_intent);
 
 static inline struct dentry *
 do_revalidate(struct dentry *dentry, struct nameidata *nd)
diff --git a/fs/splice.c b/fs/splice.c
index 3920866..488e3ba 100644
--- a/fs/splice.c
+++ b/fs/splice.c
@@ -1053,8 +1053,8 @@ EXPORT_SYMBOL(generic_splice_sendpage);
 /*
  * Attempt to initiate a splice from pipe to file.
  */
-static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
-			   loff_t *ppos, size_t len, unsigned int flags)
+long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,
+		     loff_t *ppos, size_t len, unsigned int flags)
 {
 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *,
 				loff_t *, size_t, unsigned int);
@@ -1077,13 +1077,14 @@ static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,
 
 	return splice_write(pipe, out, ppos, len, flags);
 }
+EXPORT_SYMBOL_GPL(vfs_splice_from);
 
 /*
  * Attempt to initiate a splice from a file to a pipe.
  */
-static long do_splice_to(struct file *in, loff_t *ppos,
-			 struct pipe_inode_info *pipe, size_t len,
-			 unsigned int flags)
+long vfs_splice_to(struct file *in, loff_t *ppos,
+		   struct pipe_inode_info *pipe, size_t len,
+		   unsigned int flags)
 {
 	ssize_t (*splice_read)(struct file *, loff_t *,
 			       struct pipe_inode_info *, size_t, unsigned int);
@@ -1103,6 +1104,7 @@ static long do_splice_to(struct file *in, loff_t *ppos,
 
 	return splice_read(in, ppos, pipe, len, flags);
 }
+EXPORT_SYMBOL_GPL(vfs_splice_to);
 
 /**
  * splice_direct_to_actor - splices data directly between two non-pipes
@@ -1172,7 +1174,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,
 		size_t read_len;
 		loff_t pos = sd->pos, prev_pos = pos;
 
-		ret = do_splice_to(in, &pos, pipe, len, flags);
+		ret = vfs_splice_to(in, &pos, pipe, len, flags);
 		if (unlikely(ret <= 0))
 			goto out_release;
 
@@ -1231,7 +1233,7 @@ static int direct_splice_actor(struct pipe_inode_info *pipe,
 {
 	struct file *file = sd->u.file;
 
-	return do_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);
+	return vfs_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);
 }
 
 /**
@@ -1329,7 +1331,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 		} else
 			off = &out->f_pos;
 
-		ret = do_splice_from(ipipe, out, off, len, flags);
+		ret = vfs_splice_from(ipipe, out, off, len, flags);
 
 		if (off_out && copy_to_user(off_out, off, sizeof(loff_t)))
 			ret = -EFAULT;
@@ -1350,7 +1352,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,
 		} else
 			off = &in->f_pos;
 
-		ret = do_splice_to(in, off, opipe, len, flags);
+		ret = vfs_splice_to(in, off, opipe, len, flags);
 
 		if (off_in && copy_to_user(off_in, off, sizeof(loff_t)))
 			ret = -EFAULT;
diff --git a/fs/stack.c b/fs/stack.c
index 4a6f7f4..7eeef12 100644
--- a/fs/stack.c
+++ b/fs/stack.c
@@ -1,8 +1,20 @@
+/*
+ * Copyright (c) 2006-2009 Erez Zadok
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006-2009 Stony Brook University
+ * Copyright (c) 2006-2009 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/fs_stack.h>
 
-/* does _NOT_ require i_mutex to be held.
+/*
+ * does _NOT_ require i_mutex to be held.
  *
  * This function cannot be inlined since i_size_{read,write} is rather
  * heavy-weight on 32-bit systems
diff --git a/fs/super.c b/fs/super.c
index aff046b..ad6dc74 100644
--- a/fs/super.c
+++ b/fs/super.c
@@ -95,6 +95,7 @@ static struct super_block *alloc_super(struct file_system_type *type)
 		s->s_count = S_BIAS;
 		atomic_set(&s->s_active, 1);
 		mutex_init(&s->s_vfs_rename_mutex);
+		lockdep_set_class(&s->s_vfs_rename_mutex, &type->s_vfs_rename_key);
 		mutex_init(&s->s_dquot.dqio_mutex);
 		mutex_init(&s->s_dquot.dqonoff_mutex);
 		init_rwsem(&s->s_dquot.dqptr_sem);
diff --git a/fs/unionfs/Kconfig b/fs/unionfs/Kconfig
new file mode 100644
index 0000000..f3c1ac4
--- /dev/null
+++ b/fs/unionfs/Kconfig
@@ -0,0 +1,24 @@
+config UNION_FS
+	tristate "Union file system (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  Unionfs is a stackable unification file system, which appears to
+	  merge the contents of several directories (branches), while keeping
+	  their physical content separate.
+
+	  See <http://unionfs.filesystems.org> for details
+
+config UNION_FS_XATTR
+	bool "Unionfs extended attributes"
+	depends on UNION_FS
+	help
+	  Extended attributes are name:value pairs associated with inodes by
+	  the kernel or by users (see the attr(5) manual page).
+
+	  If unsure, say N.
+
+config UNION_FS_DEBUG
+	bool "Debug Unionfs"
+	depends on UNION_FS
+	help
+	  If you say Y here, you can turn on debugging output from Unionfs.
diff --git a/fs/unionfs/Makefile b/fs/unionfs/Makefile
new file mode 100644
index 0000000..1ef873e
--- /dev/null
+++ b/fs/unionfs/Makefile
@@ -0,0 +1,17 @@
+UNIONFS_VERSION="2.5.4 (for 2.6.33)"
+
+EXTRA_CFLAGS += -DUNIONFS_VERSION=\"$(UNIONFS_VERSION)\"
+
+obj-$(CONFIG_UNION_FS) += unionfs.o
+
+unionfs-y := subr.o dentry.o file.o inode.o main.o super.o \
+	rdstate.o copyup.o dirhelper.o rename.o unlink.o \
+	lookup.o commonfops.o dirfops.o sioq.o mmap.o whiteout.o
+
+unionfs-$(CONFIG_UNION_FS_XATTR) += xattr.o
+
+unionfs-$(CONFIG_UNION_FS_DEBUG) += debug.o
+
+ifeq ($(CONFIG_UNION_FS_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c
new file mode 100644
index 0000000..740c4ad
--- /dev/null
+++ b/fs/unionfs/commonfops.c
@@ -0,0 +1,896 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * 1) Copyup the file
+ * 2) Rename the file to '.unionfs<original inode#><counter>' - obviously
+ * stolen from NFS's silly rename
+ */
+static int copyup_deleted_file(struct file *file, struct dentry *dentry,
+			       struct dentry *parent, int bstart, int bindex)
+{
+	static unsigned int counter;
+	const int i_inosize = sizeof(dentry->d_inode->i_ino) * 2;
+	const int countersize = sizeof(counter) * 2;
+	const int nlen = sizeof(".unionfs") + i_inosize + countersize - 1;
+	char name[nlen + 1];
+	int err;
+	struct dentry *tmp_dentry = NULL;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bstart);
+
+	sprintf(name, ".unionfs%*.*lx",
+		i_inosize, i_inosize, lower_dentry->d_inode->i_ino);
+
+	/*
+	 * Loop, looking for an unused temp name to copyup to.
+	 *
+	 * It's somewhat silly that we look for a free temp tmp name in the
+	 * source branch (bstart) instead of the dest branch (bindex), where
+	 * the final name will be created.  We _will_ catch it if somehow
+	 * the name exists in the dest branch, but it'd be nice to catch it
+	 * sooner than later.
+	 */
+retry:
+	tmp_dentry = NULL;
+	do {
+		char *suffix = name + nlen - countersize;
+
+		dput(tmp_dentry);
+		counter++;
+		sprintf(suffix, "%*.*x", countersize, countersize, counter);
+
+		pr_debug("unionfs: trying to rename %s to %s\n",
+			 dentry->d_name.name, name);
+
+		tmp_dentry = lookup_lck_len(name, lower_dentry->d_parent,
+					    nlen);
+		if (IS_ERR(tmp_dentry)) {
+			err = PTR_ERR(tmp_dentry);
+			goto out;
+		}
+	} while (tmp_dentry->d_inode != NULL);	/* need negative dentry */
+	dput(tmp_dentry);
+
+	err = copyup_named_file(parent->d_inode, file, name, bstart, bindex,
+				i_size_read(file->f_path.dentry->d_inode));
+	if (err) {
+		if (unlikely(err == -EEXIST))
+			goto retry;
+		goto out;
+	}
+
+	/* bring it to the same state as an unlinked file */
+	lower_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));
+	if (!unionfs_lower_inode_idx(dentry->d_inode, bindex)) {
+		atomic_inc(&lower_dentry->d_inode->i_count);
+		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+					    lower_dentry->d_inode);
+	}
+	lower_dir_dentry = lock_parent(lower_dentry);
+	err = vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);
+	unlock_dir(lower_dir_dentry);
+
+out:
+	if (!err)
+		unionfs_check_dentry(dentry);
+	return err;
+}
+
+/*
+ * put all references held by upper struct file and free lower file pointer
+ * array
+ */
+static void cleanup_file(struct file *file)
+{
+	int bindex, bstart, bend;
+	struct file **lower_files;
+	struct file *lower_file;
+	struct super_block *sb = file->f_path.dentry->d_sb;
+
+	lower_files = UNIONFS_F(file)->lower_files;
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		int i;	/* holds (possibly) updated branch index */
+		int old_bid;
+
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		if (!lower_file)
+			continue;
+
+		/*
+		 * Find new index of matching branch with an open
+		 * file, since branches could have been added or
+		 * deleted causing the one with open files to shift.
+		 */
+		old_bid = UNIONFS_F(file)->saved_branch_ids[bindex];
+		i = branch_id_to_idx(sb, old_bid);
+		if (unlikely(i < 0)) {
+			printk(KERN_ERR "unionfs: no superblock for "
+			       "file %p\n", file);
+			continue;
+		}
+
+		/* decrement count of open files */
+		branchput(sb, i);
+		/*
+		 * fput will perform an mntput for us on the correct branch.
+		 * Although we're using the file's old branch configuration,
+		 * bindex, which is the old index, correctly points to the
+		 * right branch in the file's branch list.  In other words,
+		 * we're going to mntput the correct branch even if branches
+		 * have been added/removed.
+		 */
+		fput(lower_file);
+		UNIONFS_F(file)->lower_files[bindex] = NULL;
+		UNIONFS_F(file)->saved_branch_ids[bindex] = -1;
+	}
+
+	UNIONFS_F(file)->lower_files = NULL;
+	kfree(lower_files);
+	kfree(UNIONFS_F(file)->saved_branch_ids);
+	/* set to NULL because caller needs to know if to kfree on error */
+	UNIONFS_F(file)->saved_branch_ids = NULL;
+}
+
+/* open all lower files for a given file */
+static int open_all_files(struct file *file)
+{
+	int bindex, bstart, bend, err = 0;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct dentry *dentry = file->f_path.dentry;
+	struct super_block *sb = dentry->d_sb;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		dget(lower_dentry);
+		unionfs_mntget(dentry, bindex);
+		branchget(sb, bindex);
+
+		lower_file =
+			dentry_open(lower_dentry,
+				    unionfs_lower_mnt_idx(dentry, bindex),
+				    file->f_flags, current_cred());
+		if (IS_ERR(lower_file)) {
+			branchput(sb, bindex);
+			err = PTR_ERR(lower_file);
+			goto out;
+		} else {
+			unionfs_set_lower_file_idx(file, bindex, lower_file);
+		}
+	}
+out:
+	return err;
+}
+
+/* open the highest priority file for a given upper file */
+static int open_highest_file(struct file *file, bool willwrite)
+{
+	int bindex, bstart, bend, err = 0;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent = dget_parent(dentry);
+	struct inode *parent_inode = parent->d_inode;
+	struct super_block *sb = dentry->d_sb;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+	if (willwrite && IS_WRITE_FLAG(file->f_flags) && is_robranch(dentry)) {
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_file(parent_inode, file, bstart, bindex,
+					  i_size_read(dentry->d_inode));
+			if (!err)
+				break;
+		}
+		atomic_set(&UNIONFS_F(file)->generation,
+			   atomic_read(&UNIONFS_I(dentry->d_inode)->
+				       generation));
+		goto out;
+	}
+
+	dget(lower_dentry);
+	unionfs_mntget(dentry, bstart);
+	lower_file = dentry_open(lower_dentry,
+				 unionfs_lower_mnt_idx(dentry, bstart),
+				 file->f_flags, current_cred());
+	if (IS_ERR(lower_file)) {
+		err = PTR_ERR(lower_file);
+		goto out;
+	}
+	branchget(sb, bstart);
+	unionfs_set_lower_file(file, lower_file);
+	/* Fix up the position. */
+	lower_file->f_pos = file->f_pos;
+
+	memcpy(&lower_file->f_ra, &file->f_ra, sizeof(struct file_ra_state));
+out:
+	dput(parent);
+	return err;
+}
+
+/* perform a delayed copyup of a read-write file on a read-only branch */
+static int do_delayed_copyup(struct file *file, struct dentry *parent)
+{
+	int bindex, bstart, bend, err = 0;
+	struct dentry *dentry = file->f_path.dentry;
+	struct inode *parent_inode = parent->d_inode;
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	BUG_ON(!S_ISREG(dentry->d_inode->i_mode));
+
+	unionfs_check_file(file);
+	for (bindex = bstart - 1; bindex >= 0; bindex--) {
+		if (!d_deleted(dentry))
+			err = copyup_file(parent_inode, file, bstart,
+					  bindex,
+					  i_size_read(dentry->d_inode));
+		else
+			err = copyup_deleted_file(file, dentry, parent,
+						  bstart, bindex);
+		/* if succeeded, set lower open-file flags and break */
+		if (!err) {
+			struct file *lower_file;
+			lower_file = unionfs_lower_file_idx(file, bindex);
+			lower_file->f_flags = file->f_flags;
+			break;
+		}
+	}
+	if (err || (bstart <= fbstart(file)))
+		goto out;
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		if (unionfs_lower_file_idx(file, bindex)) {
+			branchput(dentry->d_sb, bindex);
+			fput(unionfs_lower_file_idx(file, bindex));
+			unionfs_set_lower_file_idx(file, bindex, NULL);
+		}
+	}
+	path_put_lowers(dentry, bstart, bend, false);
+	iput_lowers(dentry->d_inode, bstart, bend, false);
+	/* for reg file, we only open it "once" */
+	fbend(file) = fbstart(file);
+	dbend(dentry) = dbstart(dentry);
+	ibend(dentry->d_inode) = ibstart(dentry->d_inode);
+
+out:
+	unionfs_check_file(file);
+	return err;
+}
+
+/*
+ * Helper function for unionfs_file_revalidate/locked.
+ * Expects dentry/parent to be locked already, and revalidated.
+ */
+static int __unionfs_file_revalidate(struct file *file, struct dentry *dentry,
+				     struct dentry *parent,
+				     struct super_block *sb, int sbgen,
+				     int dgen, bool willwrite)
+{
+	int fgen;
+	int bstart, bend, orig_brid;
+	int size;
+	int err = 0;
+
+	fgen = atomic_read(&UNIONFS_F(file)->generation);
+
+	/*
+	 * There are two cases we are interested in.  The first is if the
+	 * generation is lower than the super-block.  The second is if
+	 * someone has copied up this file from underneath us, we also need
+	 * to refresh things.
+	 */
+	if (d_deleted(dentry) ||
+	    (sbgen <= fgen &&
+	     dbstart(dentry) == fbstart(file) &&
+	     unionfs_lower_file(file)))
+		goto out_may_copyup;
+
+	/* save orig branch ID */
+	orig_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];
+
+	/* First we throw out the existing files. */
+	cleanup_file(file);
+
+	/* Now we reopen the file(s) as in unionfs_open. */
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	size = sizeof(struct file *) * sbmax(sb);
+	UNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->lower_files)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(int) * sbmax(sb);
+	UNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (S_ISDIR(dentry->d_inode->i_mode)) {
+		/* We need to open all the files. */
+		err = open_all_files(file);
+		if (err)
+			goto out;
+	} else {
+		int new_brid;
+		/* We only open the highest priority branch. */
+		err = open_highest_file(file, willwrite);
+		if (err)
+			goto out;
+		new_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];
+		if (unlikely(new_brid != orig_brid && sbgen > fgen)) {
+			/*
+			 * If we re-opened the file on a different branch
+			 * than the original one, and this was due to a new
+			 * branch inserted, then update the mnt counts of
+			 * the old and new branches accordingly.
+			 */
+			unionfs_mntget(dentry, bstart);
+			unionfs_mntput(sb->s_root,
+				       branch_id_to_idx(sb, orig_brid));
+		}
+		/* regular files have only one open lower file */
+		fbend(file) = fbstart(file);
+	}
+	atomic_set(&UNIONFS_F(file)->generation,
+		   atomic_read(&UNIONFS_I(dentry->d_inode)->generation));
+
+out_may_copyup:
+	/* Copyup on the first write to a file on a readonly branch. */
+	if (willwrite && IS_WRITE_FLAG(file->f_flags) &&
+	    !IS_WRITE_FLAG(unionfs_lower_file(file)->f_flags) &&
+	    is_robranch(dentry)) {
+		pr_debug("unionfs: do delay copyup of \"%s\"\n",
+			 dentry->d_name.name);
+		err = do_delayed_copyup(file, parent);
+		/* regular files have only one open lower file */
+		if (!err && !S_ISDIR(dentry->d_inode->i_mode))
+			fbend(file) = fbstart(file);
+	}
+
+out:
+	if (err) {
+		kfree(UNIONFS_F(file)->lower_files);
+		kfree(UNIONFS_F(file)->saved_branch_ids);
+	}
+	return err;
+}
+
+/*
+ * Revalidate the struct file
+ * @file: file to revalidate
+ * @parent: parent dentry (locked by caller)
+ * @willwrite: true if caller may cause changes to the file; false otherwise.
+ * Caller must lock/unlock dentry's branch configuration.
+ */
+int unionfs_file_revalidate(struct file *file, struct dentry *parent,
+			    bool willwrite)
+{
+	struct super_block *sb;
+	struct dentry *dentry;
+	int sbgen, dgen;
+	int err = 0;
+
+	dentry = file->f_path.dentry;
+	sb = dentry->d_sb;
+	verify_locked(dentry);
+	verify_locked(parent);
+
+	/*
+	 * First revalidate the dentry inside struct file,
+	 * but not unhashed dentries.
+	 */
+	if (!d_deleted(dentry) &&
+	    !__unionfs_d_revalidate(dentry, parent, willwrite)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	sbgen = atomic_read(&UNIONFS_SB(sb)->generation);
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+
+	if (unlikely(sbgen > dgen)) { /* XXX: should never happen */
+		pr_debug("unionfs: failed to revalidate dentry (%s)\n",
+			 dentry->d_name.name);
+		err = -ESTALE;
+		goto out;
+	}
+
+	err = __unionfs_file_revalidate(file, dentry, parent, sb,
+					sbgen, dgen, willwrite);
+out:
+	return err;
+}
+
+/* unionfs_open helper function: open a directory */
+static int __open_dir(struct inode *inode, struct file *file)
+{
+	struct dentry *lower_dentry;
+	struct file *lower_file;
+	int bindex, bstart, bend;
+	struct vfsmount *mnt;
+
+	bstart = fbstart(file) = dbstart(file->f_path.dentry);
+	bend = fbend(file) = dbend(file->f_path.dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry =
+			unionfs_lower_dentry_idx(file->f_path.dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		dget(lower_dentry);
+		unionfs_mntget(file->f_path.dentry, bindex);
+		mnt = unionfs_lower_mnt_idx(file->f_path.dentry, bindex);
+		lower_file = dentry_open(lower_dentry, mnt, file->f_flags,
+					 current_cred());
+		if (IS_ERR(lower_file))
+			return PTR_ERR(lower_file);
+
+		unionfs_set_lower_file_idx(file, bindex, lower_file);
+
+		/*
+		 * The branchget goes after the open, because otherwise
+		 * we would miss the reference on release.
+		 */
+		branchget(inode->i_sb, bindex);
+	}
+
+	return 0;
+}
+
+/* unionfs_open helper function: open a file */
+static int __open_file(struct inode *inode, struct file *file,
+		       struct dentry *parent)
+{
+	struct dentry *lower_dentry;
+	struct file *lower_file;
+	int lower_flags;
+	int bindex, bstart, bend;
+
+	lower_dentry = unionfs_lower_dentry(file->f_path.dentry);
+	lower_flags = file->f_flags;
+
+	bstart = fbstart(file) = dbstart(file->f_path.dentry);
+	bend = fbend(file) = dbend(file->f_path.dentry);
+
+	/*
+	 * check for the permission for lower file.  If the error is
+	 * COPYUP_ERR, copyup the file.
+	 */
+	if (lower_dentry->d_inode && is_robranch(file->f_path.dentry)) {
+		/*
+		 * if the open will change the file, copy it up otherwise
+		 * defer it.
+		 */
+		if (lower_flags & O_TRUNC) {
+			int size = 0;
+			int err = -EROFS;
+
+			/* copyup the file */
+			for (bindex = bstart - 1; bindex >= 0; bindex--) {
+				err = copyup_file(parent->d_inode, file,
+						  bstart, bindex, size);
+				if (!err)
+					break;
+			}
+			return err;
+		} else {
+			/*
+			 * turn off writeable flags, to force delayed copyup
+			 * by caller.
+			 */
+			lower_flags &= ~(OPEN_WRITE_FLAGS);
+		}
+	}
+
+	dget(lower_dentry);
+
+	/*
+	 * dentry_open will decrement mnt refcnt if err.
+	 * otherwise fput() will do an mntput() for us upon file close.
+	 */
+	unionfs_mntget(file->f_path.dentry, bstart);
+	lower_file =
+		dentry_open(lower_dentry,
+			    unionfs_lower_mnt_idx(file->f_path.dentry, bstart),
+			    lower_flags, current_cred());
+	if (IS_ERR(lower_file))
+		return PTR_ERR(lower_file);
+
+	unionfs_set_lower_file(file, lower_file);
+	branchget(inode->i_sb, bstart);
+
+	return 0;
+}
+
+int unionfs_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	int bindex = 0, bstart = 0, bend = 0;
+	int size;
+	int valid = 0;
+
+	unionfs_read_lock(inode->i_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/* don't open unhashed/deleted files */
+	if (d_deleted(dentry)) {
+		err = -ENOENT;
+		goto out_nofree;
+	}
+
+	/* XXX: should I change 'false' below to the 'willwrite' flag? */
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out_nofree;
+	}
+
+	file->private_data =
+		kzalloc(sizeof(struct unionfs_file_info), GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file))) {
+		err = -ENOMEM;
+		goto out_nofree;
+	}
+	fbstart(file) = -1;
+	fbend(file) = -1;
+	atomic_set(&UNIONFS_F(file)->generation,
+		   atomic_read(&UNIONFS_I(inode)->generation));
+
+	size = sizeof(struct file *) * sbmax(inode->i_sb);
+	UNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->lower_files)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	size = sizeof(int) * sbmax(inode->i_sb);
+	UNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	/*
+	 * open all directories and make the unionfs file struct point to
+	 * these lower file structs
+	 */
+	if (S_ISDIR(inode->i_mode))
+		err = __open_dir(inode, file);	/* open a dir */
+	else
+		err = __open_file(inode, file, parent);	/* open a file */
+
+	/* freeing the allocated resources, and fput the opened files */
+	if (err) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			lower_file = unionfs_lower_file_idx(file, bindex);
+			if (!lower_file)
+				continue;
+
+			branchput(dentry->d_sb, bindex);
+			/* fput calls dput for lower_dentry */
+			fput(lower_file);
+		}
+	}
+
+out:
+	if (err) {
+		kfree(UNIONFS_F(file)->lower_files);
+		kfree(UNIONFS_F(file)->saved_branch_ids);
+		kfree(UNIONFS_F(file));
+	}
+out_nofree:
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_copy_attr_times(inode);
+		unionfs_check_file(file);
+		unionfs_check_inode(inode);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(inode->i_sb);
+	return err;
+}
+
+/*
+ * release all lower object references & free the file info structure
+ *
+ * No need to grab sb info's rwsem.
+ */
+int unionfs_file_release(struct inode *inode, struct file *file)
+{
+	struct file *lower_file = NULL;
+	struct unionfs_file_info *fileinfo;
+	struct unionfs_inode_info *inodeinfo;
+	struct super_block *sb = inode->i_sb;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	int bindex, bstart, bend;
+	int fgen, err = 0;
+
+	/*
+	 * Since mm/memory.c:might_fault() (under PROVE_LOCKING) was
+	 * modified in 2.6.29-rc1 to call might_lock_read on mmap_sem, this
+	 * has been causing false positives in file system stacking layers.
+	 * In particular, our ->mmap is called after sys_mmap2 already holds
+	 * mmap_sem, then we lock our own mutexes; but earlier, it's
+	 * possible for lockdep to have locked our mutexes first, and then
+	 * we call a lower ->readdir which could call might_fault.  The
+	 * different ordering of the locks is what lockdep complains about
+	 * -- unnecessarily.  Therefore, we have no choice but to tell
+	 * lockdep to temporarily turn off lockdep here.  Note: the comments
+	 * inside might_sleep also suggest that it would have been
+	 * nicer to only annotate paths that needs that might_lock_read.
+	 */
+	lockdep_off();
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/*
+	 * We try to revalidate, but the VFS ignores return return values
+	 * from file->release, so we must always try to succeed here,
+	 * including to do the kfree and dput below.  So if revalidation
+	 * failed, all we can do is print some message and keep going.
+	 */
+	err = unionfs_file_revalidate(file, parent,
+				      UNIONFS_F(file)->wrote_to_file);
+	if (!err)
+		unionfs_check_file(file);
+	fileinfo = UNIONFS_F(file);
+	BUG_ON(file->f_path.dentry->d_inode != inode);
+	inodeinfo = UNIONFS_I(inode);
+
+	/* fput all the lower files */
+	fgen = atomic_read(&fileinfo->generation);
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+
+		if (lower_file) {
+			unionfs_set_lower_file_idx(file, bindex, NULL);
+			fput(lower_file);
+			branchput(sb, bindex);
+		}
+
+		/* if there are no more refs to the dentry, dput it */
+		if (d_deleted(dentry)) {
+			dput(unionfs_lower_dentry_idx(dentry, bindex));
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+		}
+	}
+
+	kfree(fileinfo->lower_files);
+	kfree(fileinfo->saved_branch_ids);
+
+	if (fileinfo->rdstate) {
+		fileinfo->rdstate->access = jiffies;
+		spin_lock(&inodeinfo->rdlock);
+		inodeinfo->rdcount++;
+		list_add_tail(&fileinfo->rdstate->cache,
+			      &inodeinfo->readdircache);
+		mark_inode_dirty(inode);
+		spin_unlock(&inodeinfo->rdlock);
+		fileinfo->rdstate = NULL;
+	}
+	kfree(fileinfo);
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(sb);
+	lockdep_on();
+	return err;
+}
+
+/* pass the ioctl to the lower fs */
+static long do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	struct file *lower_file;
+	int err;
+
+	lower_file = unionfs_lower_file(file);
+
+	err = -ENOTTY;
+	if (!lower_file || !lower_file->f_op)
+		goto out;
+	if (lower_file->f_op->unlocked_ioctl) {
+		err = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);
+	} else if (lower_file->f_op->ioctl) {
+		lock_kernel();
+		err = lower_file->f_op->ioctl(
+			lower_file->f_path.dentry->d_inode,
+			lower_file, cmd, arg);
+		unlock_kernel();
+	}
+
+out:
+	return err;
+}
+
+/*
+ * return to user-space the branch indices containing the file in question
+ *
+ * We use fd_set and therefore we are limited to the number of the branches
+ * to FD_SETSIZE, which is currently 1024 - plenty for most people
+ */
+static int unionfs_ioctl_queryfile(struct file *file, struct dentry *parent,
+				   unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	fd_set branchlist;
+	int bstart = 0, bend = 0, bindex = 0;
+	int orig_bstart, orig_bend;
+	struct dentry *dentry, *lower_dentry;
+	struct vfsmount *mnt;
+
+	dentry = file->f_path.dentry;
+	orig_bstart = dbstart(dentry);
+	orig_bend = dbend(dentry);
+	err = unionfs_partial_lookup(dentry, parent);
+	if (err)
+		goto out;
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	FD_ZERO(&branchlist);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (likely(lower_dentry->d_inode))
+			FD_SET(bindex, &branchlist);
+		/* purge any lower objects after partial_lookup */
+		if (bindex < orig_bstart || bindex > orig_bend) {
+			dput(lower_dentry);
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+			iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
+			unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+						    NULL);
+			mnt = unionfs_lower_mnt_idx(dentry, bindex);
+			if (!mnt)
+				continue;
+			unionfs_mntput(dentry, bindex);
+			unionfs_set_lower_mnt_idx(dentry, bindex, NULL);
+		}
+	}
+	/* restore original dentry's offsets */
+	dbstart(dentry) = orig_bstart;
+	dbend(dentry) = orig_bend;
+	ibstart(dentry->d_inode) = orig_bstart;
+	ibend(dentry->d_inode) = orig_bend;
+
+	err = copy_to_user((void __user *)arg, &branchlist, sizeof(fd_set));
+	if (unlikely(err))
+		err = -EFAULT;
+
+out:
+	return err < 0 ? err : bend;
+}
+
+long unionfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long err;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, true);
+	if (unlikely(err))
+		goto out;
+
+	/* check if asked for local commands */
+	switch (cmd) {
+	case UNIONFS_IOCTL_INCGEN:
+		/* Increment the superblock generation count */
+		pr_info("unionfs: incgen ioctl deprecated; "
+			"use \"-o remount,incgen\"\n");
+		err = -ENOSYS;
+		break;
+
+	case UNIONFS_IOCTL_QUERYFILE:
+		/* Return list of branches containing the given file */
+		err = unionfs_ioctl_queryfile(file, parent, cmd, arg);
+		break;
+
+	default:
+		/* pass the ioctl down */
+		err = do_ioctl(file, cmd, arg);
+		break;
+	}
+
+out:
+	unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+int unionfs_flush(struct file *file, fl_owner_t id)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	int bindex, bstart, bend;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent,
+				      UNIONFS_F(file)->wrote_to_file);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+
+		if (lower_file && lower_file->f_op &&
+		    lower_file->f_op->flush) {
+			err = lower_file->f_op->flush(lower_file, id);
+			if (err)
+				goto out;
+		}
+
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c
new file mode 100644
index 0000000..9c7b2ac
--- /dev/null
+++ b/fs/unionfs/copyup.c
@@ -0,0 +1,897 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * For detailed explanation of copyup see:
+ * Documentation/filesystems/unionfs/concepts.txt
+ */
+
+#ifdef CONFIG_UNION_FS_XATTR
+/* copyup all extended attrs for a given dentry */
+static int copyup_xattrs(struct dentry *old_lower_dentry,
+			 struct dentry *new_lower_dentry)
+{
+	int err = 0;
+	ssize_t list_size = -1;
+	char *name_list = NULL;
+	char *attr_value = NULL;
+	char *name_list_buf = NULL;
+
+	/* query the actual size of the xattr list */
+	list_size = vfs_listxattr(old_lower_dentry, NULL, 0);
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	/* allocate space for the actual list */
+	name_list = unionfs_xattr_alloc(list_size + 1, XATTR_LIST_MAX);
+	if (unlikely(!name_list || IS_ERR(name_list))) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+
+	name_list_buf = name_list; /* save for kfree at end */
+
+	/* now get the actual xattr list of the source file */
+	list_size = vfs_listxattr(old_lower_dentry, name_list, list_size);
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	/* allocate space to hold each xattr's value */
+	attr_value = unionfs_xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);
+	if (unlikely(!attr_value || IS_ERR(attr_value))) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+
+	/* in a loop, get and set each xattr from src to dst file */
+	while (*name_list) {
+		ssize_t size;
+
+		/* Lock here since vfs_getxattr doesn't lock for us */
+		mutex_lock(&old_lower_dentry->d_inode->i_mutex);
+		size = vfs_getxattr(old_lower_dentry, name_list,
+				    attr_value, XATTR_SIZE_MAX);
+		mutex_unlock(&old_lower_dentry->d_inode->i_mutex);
+		if (size < 0) {
+			err = size;
+			goto out;
+		}
+		if (size > XATTR_SIZE_MAX) {
+			err = -E2BIG;
+			goto out;
+		}
+		/* Don't lock here since vfs_setxattr does it for us. */
+		err = vfs_setxattr(new_lower_dentry, name_list, attr_value,
+				   size, 0);
+		/*
+		 * Selinux depends on "security.*" xattrs, so to maintain
+		 * the security of copied-up files, if Selinux is active,
+		 * then we must copy these xattrs as well.  So we need to
+		 * temporarily get FOWNER privileges.
+		 * XXX: move entire copyup code to SIOQ.
+		 */
+		if (err == -EPERM && !capable(CAP_FOWNER)) {
+			const struct cred *old_creds;
+			struct cred *new_creds;
+
+			new_creds = prepare_creds();
+			if (unlikely(!new_creds)) {
+				err = -ENOMEM;
+				goto out;
+			}
+			cap_raise(new_creds->cap_effective, CAP_FOWNER);
+			old_creds = override_creds(new_creds);
+			err = vfs_setxattr(new_lower_dentry, name_list,
+					   attr_value, size, 0);
+			revert_creds(old_creds);
+		}
+		if (err < 0)
+			goto out;
+		name_list += strlen(name_list) + 1;
+	}
+out:
+	unionfs_xattr_kfree(name_list_buf);
+	unionfs_xattr_kfree(attr_value);
+	/* Ignore if xattr isn't supported */
+	if (err == -ENOTSUPP || err == -EOPNOTSUPP)
+		err = 0;
+	return err;
+}
+#endif /* CONFIG_UNION_FS_XATTR */
+
+/*
+ * Determine the mode based on the copyup flags, and the existing dentry.
+ *
+ * Handle file systems which may not support certain options.  For example
+ * jffs2 doesn't allow one to chmod a symlink.  So we ignore such harmless
+ * errors, rather than propagating them up, which results in copyup errors
+ * and errors returned back to users.
+ */
+static int copyup_permissions(struct super_block *sb,
+			      struct dentry *old_lower_dentry,
+			      struct dentry *new_lower_dentry)
+{
+	struct inode *i = old_lower_dentry->d_inode;
+	struct iattr newattrs;
+	int err;
+
+	newattrs.ia_atime = i->i_atime;
+	newattrs.ia_mtime = i->i_mtime;
+	newattrs.ia_ctime = i->i_ctime;
+	newattrs.ia_gid = i->i_gid;
+	newattrs.ia_uid = i->i_uid;
+	newattrs.ia_valid = ATTR_CTIME | ATTR_ATIME | ATTR_MTIME |
+		ATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_FORCE |
+		ATTR_GID | ATTR_UID;
+	mutex_lock(&new_lower_dentry->d_inode->i_mutex);
+	err = notify_change(new_lower_dentry, &newattrs);
+	if (err)
+		goto out;
+
+	/* now try to change the mode and ignore EOPNOTSUPP on symlinks */
+	newattrs.ia_mode = i->i_mode;
+	newattrs.ia_valid = ATTR_MODE | ATTR_FORCE;
+	err = notify_change(new_lower_dentry, &newattrs);
+	if (err == -EOPNOTSUPP &&
+	    S_ISLNK(new_lower_dentry->d_inode->i_mode)) {
+		printk(KERN_WARNING
+		       "unionfs: changing \"%s\" symlink mode unsupported\n",
+		       new_lower_dentry->d_name.name);
+		err = 0;
+	}
+
+out:
+	mutex_unlock(&new_lower_dentry->d_inode->i_mutex);
+	return err;
+}
+
+/*
+ * create the new device/file/directory - use copyup_permission to copyup
+ * times, and mode
+ *
+ * if the object being copied up is a regular file, the file is only created,
+ * the contents have to be copied up separately
+ */
+static int __copyup_ndentry(struct dentry *old_lower_dentry,
+			    struct dentry *new_lower_dentry,
+			    struct dentry *new_lower_parent_dentry,
+			    char *symbuf)
+{
+	int err = 0;
+	umode_t old_mode = old_lower_dentry->d_inode->i_mode;
+	struct sioq_args args;
+
+	if (S_ISDIR(old_mode)) {
+		args.mkdir.parent = new_lower_parent_dentry->d_inode;
+		args.mkdir.dentry = new_lower_dentry;
+		args.mkdir.mode = old_mode;
+
+		run_sioq(__unionfs_mkdir, &args);
+		err = args.err;
+	} else if (S_ISLNK(old_mode)) {
+		args.symlink.parent = new_lower_parent_dentry->d_inode;
+		args.symlink.dentry = new_lower_dentry;
+		args.symlink.symbuf = symbuf;
+
+		run_sioq(__unionfs_symlink, &args);
+		err = args.err;
+	} else if (S_ISBLK(old_mode) || S_ISCHR(old_mode) ||
+		   S_ISFIFO(old_mode) || S_ISSOCK(old_mode)) {
+		args.mknod.parent = new_lower_parent_dentry->d_inode;
+		args.mknod.dentry = new_lower_dentry;
+		args.mknod.mode = old_mode;
+		args.mknod.dev = old_lower_dentry->d_inode->i_rdev;
+
+		run_sioq(__unionfs_mknod, &args);
+		err = args.err;
+	} else if (S_ISREG(old_mode)) {
+		struct nameidata nd;
+		err = init_lower_nd(&nd, LOOKUP_CREATE);
+		if (unlikely(err < 0))
+			goto out;
+		args.create.nd = &nd;
+		args.create.parent = new_lower_parent_dentry->d_inode;
+		args.create.dentry = new_lower_dentry;
+		args.create.mode = old_mode;
+
+		run_sioq(__unionfs_create, &args);
+		err = args.err;
+		release_lower_nd(&nd, err);
+	} else {
+		printk(KERN_CRIT "unionfs: unknown inode type %d\n",
+		       old_mode);
+		BUG();
+	}
+
+out:
+	return err;
+}
+
+static int __copyup_reg_data(struct dentry *dentry,
+			     struct dentry *new_lower_dentry, int new_bindex,
+			     struct dentry *old_lower_dentry, int old_bindex,
+			     struct file **copyup_file, loff_t len)
+{
+	struct super_block *sb = dentry->d_sb;
+	struct file *input_file;
+	struct file *output_file;
+	struct vfsmount *output_mnt;
+	mm_segment_t old_fs;
+	char *buf = NULL;
+	ssize_t read_bytes, write_bytes;
+	loff_t size;
+	int err = 0;
+
+	/* open old file */
+	unionfs_mntget(dentry, old_bindex);
+	branchget(sb, old_bindex);
+	/* dentry_open calls dput and mntput if it returns an error */
+	input_file = dentry_open(old_lower_dentry,
+				 unionfs_lower_mnt_idx(dentry, old_bindex),
+				 O_RDONLY | O_LARGEFILE, current_cred());
+	if (IS_ERR(input_file)) {
+		dput(old_lower_dentry);
+		err = PTR_ERR(input_file);
+		goto out;
+	}
+	if (unlikely(!input_file->f_op || !input_file->f_op->read)) {
+		err = -EINVAL;
+		goto out_close_in;
+	}
+
+	/* open new file */
+	dget(new_lower_dentry);
+	output_mnt = unionfs_mntget(sb->s_root, new_bindex);
+	branchget(sb, new_bindex);
+	output_file = dentry_open(new_lower_dentry, output_mnt,
+				  O_RDWR | O_LARGEFILE, current_cred());
+	if (IS_ERR(output_file)) {
+		err = PTR_ERR(output_file);
+		goto out_close_in2;
+	}
+	if (unlikely(!output_file->f_op || !output_file->f_op->write)) {
+		err = -EINVAL;
+		goto out_close_out;
+	}
+
+	/* allocating a buffer */
+	buf = kmalloc(PAGE_SIZE, GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out_close_out;
+	}
+
+	input_file->f_pos = 0;
+	output_file->f_pos = 0;
+
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+
+	size = len;
+	err = 0;
+	do {
+		if (len >= PAGE_SIZE)
+			size = PAGE_SIZE;
+		else if ((len < PAGE_SIZE) && (len > 0))
+			size = len;
+
+		len -= PAGE_SIZE;
+
+		read_bytes =
+			input_file->f_op->read(input_file,
+					       (char __user *)buf, size,
+					       &input_file->f_pos);
+		if (read_bytes <= 0) {
+			err = read_bytes;
+			break;
+		}
+
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		write_bytes =
+			output_file->f_op->write(output_file,
+						 (char __user *)buf,
+						 read_bytes,
+						 &output_file->f_pos);
+		lockdep_on();
+		if ((write_bytes < 0) || (write_bytes < read_bytes)) {
+			err = write_bytes;
+			break;
+		}
+	} while ((read_bytes > 0) && (len > 0));
+
+	set_fs(old_fs);
+
+	kfree(buf);
+
+	if (!err)
+		err = output_file->f_op->fsync(output_file,
+					       new_lower_dentry, 0);
+
+	if (err)
+		goto out_close_out;
+
+	if (copyup_file) {
+		*copyup_file = output_file;
+		goto out_close_in;
+	}
+
+out_close_out:
+	fput(output_file);
+
+out_close_in2:
+	branchput(sb, new_bindex);
+
+out_close_in:
+	fput(input_file);
+
+out:
+	branchput(sb, old_bindex);
+
+	return err;
+}
+
+/*
+ * dput the lower references for old and new dentry & clear a lower dentry
+ * pointer
+ */
+static void __clear(struct dentry *dentry, struct dentry *old_lower_dentry,
+		    int old_bstart, int old_bend,
+		    struct dentry *new_lower_dentry, int new_bindex)
+{
+	/* get rid of the lower dentry and all its traces */
+	unionfs_set_lower_dentry_idx(dentry, new_bindex, NULL);
+	dbstart(dentry) = old_bstart;
+	dbend(dentry) = old_bend;
+
+	dput(new_lower_dentry);
+	dput(old_lower_dentry);
+}
+
+/*
+ * Copy up a dentry to a file of specified name.
+ *
+ * @dir: used to pull the ->i_sb to access other branches
+ * @dentry: the non-negative dentry whose lower_inode we should copy
+ * @bstart: the branch of the lower_inode to copy from
+ * @new_bindex: the branch to create the new file in
+ * @name: the name of the file to create
+ * @namelen: length of @name
+ * @copyup_file: the "struct file" to return (optional)
+ * @len: how many bytes to copy-up?
+ */
+int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
+		  int new_bindex, const char *name, int namelen,
+		  struct file **copyup_file, loff_t len)
+{
+	struct dentry *new_lower_dentry;
+	struct dentry *old_lower_dentry = NULL;
+	struct super_block *sb;
+	int err = 0;
+	int old_bindex;
+	int old_bstart;
+	int old_bend;
+	struct dentry *new_lower_parent_dentry = NULL;
+	mm_segment_t oldfs;
+	char *symbuf = NULL;
+
+	verify_locked(dentry);
+
+	old_bindex = bstart;
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	BUG_ON(new_bindex < 0);
+	BUG_ON(new_bindex >= old_bindex);
+
+	sb = dir->i_sb;
+
+	err = is_robranch_super(sb, new_bindex);
+	if (err)
+		goto out;
+
+	/* Create the directory structure above this dentry. */
+	new_lower_dentry = create_parents(dir, dentry, name, new_bindex);
+	if (IS_ERR(new_lower_dentry)) {
+		err = PTR_ERR(new_lower_dentry);
+		goto out;
+	}
+
+	old_lower_dentry = unionfs_lower_dentry_idx(dentry, old_bindex);
+	/* we conditionally dput this old_lower_dentry at end of function */
+	dget(old_lower_dentry);
+
+	/* For symlinks, we must read the link before we lock the directory. */
+	if (S_ISLNK(old_lower_dentry->d_inode->i_mode)) {
+
+		symbuf = kmalloc(PATH_MAX, GFP_KERNEL);
+		if (unlikely(!symbuf)) {
+			__clear(dentry, old_lower_dentry,
+				old_bstart, old_bend,
+				new_lower_dentry, new_bindex);
+			err = -ENOMEM;
+			goto out_free;
+		}
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		err = old_lower_dentry->d_inode->i_op->readlink(
+			old_lower_dentry,
+			(char __user *)symbuf,
+			PATH_MAX);
+		set_fs(oldfs);
+		if (err < 0) {
+			__clear(dentry, old_lower_dentry,
+				old_bstart, old_bend,
+				new_lower_dentry, new_bindex);
+			goto out_free;
+		}
+		symbuf[err] = '\0';
+	}
+
+	/* Now we lock the parent, and create the object in the new branch. */
+	new_lower_parent_dentry = lock_parent(new_lower_dentry);
+
+	/* create the new inode */
+	err = __copyup_ndentry(old_lower_dentry, new_lower_dentry,
+			       new_lower_parent_dentry, symbuf);
+
+	if (err) {
+		__clear(dentry, old_lower_dentry,
+			old_bstart, old_bend,
+			new_lower_dentry, new_bindex);
+		goto out_unlock;
+	}
+
+	/* We actually copyup the file here. */
+	if (S_ISREG(old_lower_dentry->d_inode->i_mode))
+		err = __copyup_reg_data(dentry, new_lower_dentry, new_bindex,
+					old_lower_dentry, old_bindex,
+					copyup_file, len);
+	if (err)
+		goto out_unlink;
+
+	/* Set permissions. */
+	err = copyup_permissions(sb, old_lower_dentry, new_lower_dentry);
+	if (err)
+		goto out_unlink;
+
+#ifdef CONFIG_UNION_FS_XATTR
+	/* Selinux uses extended attributes for permissions. */
+	err = copyup_xattrs(old_lower_dentry, new_lower_dentry);
+	if (err)
+		goto out_unlink;
+#endif /* CONFIG_UNION_FS_XATTR */
+
+	/* do not allow files getting deleted to be re-interposed */
+	if (!d_deleted(dentry))
+		unionfs_reinterpose(dentry);
+
+	goto out_unlock;
+
+out_unlink:
+	/*
+	 * copyup failed, because we possibly ran out of space or
+	 * quota, or something else happened so let's unlink; we don't
+	 * really care about the return value of vfs_unlink
+	 */
+	vfs_unlink(new_lower_parent_dentry->d_inode, new_lower_dentry);
+
+	if (copyup_file) {
+		/* need to close the file */
+
+		fput(*copyup_file);
+		branchput(sb, new_bindex);
+	}
+
+	/*
+	 * TODO: should we reset the error to something like -EIO?
+	 *
+	 * If we don't reset, the user may get some nonsensical errors, but
+	 * on the other hand, if we reset to EIO, we guarantee that the user
+	 * will get a "confusing" error message.
+	 */
+
+out_unlock:
+	unlock_dir(new_lower_parent_dentry);
+
+out_free:
+	/*
+	 * If old_lower_dentry was not a file, then we need to dput it.  If
+	 * it was a file, then it was already dput indirectly by other
+	 * functions we call above which operate on regular files.
+	 */
+	if (old_lower_dentry && old_lower_dentry->d_inode &&
+	    !S_ISREG(old_lower_dentry->d_inode->i_mode))
+		dput(old_lower_dentry);
+	kfree(symbuf);
+
+	if (err) {
+		/*
+		 * if directory creation succeeded, but inode copyup failed,
+		 * then purge new dentries.
+		 */
+		if (dbstart(dentry) < old_bstart &&
+		    ibstart(dentry->d_inode) > dbstart(dentry))
+			__clear(dentry, NULL, old_bstart, old_bend,
+				unionfs_lower_dentry(dentry), dbstart(dentry));
+		goto out;
+	}
+	if (!S_ISDIR(dentry->d_inode->i_mode)) {
+		unionfs_postcopyup_release(dentry);
+		if (!unionfs_lower_inode(dentry->d_inode)) {
+			/*
+			 * If we got here, then we copied up to an
+			 * unlinked-open file, whose name is .unionfsXXXXX.
+			 */
+			struct inode *inode = new_lower_dentry->d_inode;
+			atomic_inc(&inode->i_count);
+			unionfs_set_lower_inode_idx(dentry->d_inode,
+						    ibstart(dentry->d_inode),
+						    inode);
+		}
+	}
+	unionfs_postcopyup_setmnt(dentry);
+	/* sync inode times from copied-up inode to our inode */
+	unionfs_copy_attr_times(dentry->d_inode);
+	unionfs_check_inode(dir);
+	unionfs_check_dentry(dentry);
+out:
+	return err;
+}
+
+/*
+ * This function creates a copy of a file represented by 'file' which
+ * currently resides in branch 'bstart' to branch 'new_bindex.'  The copy
+ * will be named "name".
+ */
+int copyup_named_file(struct inode *dir, struct file *file, char *name,
+		      int bstart, int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	err = copyup_dentry(dir, file->f_path.dentry, bstart, new_bindex,
+			    name, strlen(name), &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		unionfs_set_lower_file_idx(file, new_bindex, output_file);
+	}
+
+	return err;
+}
+
+/*
+ * This function creates a copy of a file represented by 'file' which
+ * currently resides in branch 'bstart' to branch 'new_bindex'.
+ */
+int copyup_file(struct inode *dir, struct file *file, int bstart,
+		int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+
+	err = copyup_dentry(dir, dentry, bstart, new_bindex,
+			    dentry->d_name.name, dentry->d_name.len,
+			    &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		unionfs_set_lower_file_idx(file, new_bindex, output_file);
+	}
+
+	return err;
+}
+
+/* purge a dentry's lower-branch states (dput/mntput, etc.) */
+static void __cleanup_dentry(struct dentry *dentry, int bindex,
+			     int old_bstart, int old_bend)
+{
+	int loop_start;
+	int loop_end;
+	int new_bstart = -1;
+	int new_bend = -1;
+	int i;
+
+	loop_start = min(old_bstart, bindex);
+	loop_end = max(old_bend, bindex);
+
+	/*
+	 * This loop sets the bstart and bend for the new dentry by
+	 * traversing from left to right.  It also dputs all negative
+	 * dentries except bindex
+	 */
+	for (i = loop_start; i <= loop_end; i++) {
+		if (!unionfs_lower_dentry_idx(dentry, i))
+			continue;
+
+		if (i == bindex) {
+			new_bend = i;
+			if (new_bstart < 0)
+				new_bstart = i;
+			continue;
+		}
+
+		if (!unionfs_lower_dentry_idx(dentry, i)->d_inode) {
+			dput(unionfs_lower_dentry_idx(dentry, i));
+			unionfs_set_lower_dentry_idx(dentry, i, NULL);
+
+			unionfs_mntput(dentry, i);
+			unionfs_set_lower_mnt_idx(dentry, i, NULL);
+		} else {
+			if (new_bstart < 0)
+				new_bstart = i;
+			new_bend = i;
+		}
+	}
+
+	if (new_bstart < 0)
+		new_bstart = bindex;
+	if (new_bend < 0)
+		new_bend = bindex;
+	dbstart(dentry) = new_bstart;
+	dbend(dentry) = new_bend;
+
+}
+
+/* set lower inode ptr and update bstart & bend if necessary */
+static void __set_inode(struct dentry *upper, struct dentry *lower,
+			int bindex)
+{
+	unionfs_set_lower_inode_idx(upper->d_inode, bindex,
+				    igrab(lower->d_inode));
+	if (likely(ibstart(upper->d_inode) > bindex))
+		ibstart(upper->d_inode) = bindex;
+	if (likely(ibend(upper->d_inode) < bindex))
+		ibend(upper->d_inode) = bindex;
+
+}
+
+/* set lower dentry ptr and update bstart & bend if necessary */
+static void __set_dentry(struct dentry *upper, struct dentry *lower,
+			 int bindex)
+{
+	unionfs_set_lower_dentry_idx(upper, bindex, lower);
+	if (likely(dbstart(upper) > bindex))
+		dbstart(upper) = bindex;
+	if (likely(dbend(upper) < bindex))
+		dbend(upper) = bindex;
+}
+
+/*
+ * This function replicates the directory structure up-to given dentry
+ * in the bindex branch.
+ */
+struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+			      const char *name, int bindex)
+{
+	int err;
+	struct dentry *child_dentry;
+	struct dentry *parent_dentry;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *lower_dentry = NULL;
+	const char *childname;
+	unsigned int childnamelen;
+	int nr_dentry;
+	int count = 0;
+	int old_bstart;
+	int old_bend;
+	struct dentry **path = NULL;
+	struct super_block *sb;
+
+	verify_locked(dentry);
+
+	err = is_robranch_super(dir->i_sb, bindex);
+	if (err) {
+		lower_dentry = ERR_PTR(err);
+		goto out;
+	}
+
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	lower_dentry = ERR_PTR(-ENOMEM);
+
+	/* There is no sense allocating any less than the minimum. */
+	nr_dentry = 1;
+	path = kmalloc(nr_dentry * sizeof(struct dentry *), GFP_KERNEL);
+	if (unlikely(!path))
+		goto out;
+
+	/* assume the negative dentry of unionfs as the parent dentry */
+	parent_dentry = dentry;
+
+	/*
+	 * This loop finds the first parent that exists in the given branch.
+	 * We start building the directory structure from there.  At the end
+	 * of the loop, the following should hold:
+	 *  - child_dentry is the first nonexistent child
+	 *  - parent_dentry is the first existent parent
+	 *  - path[0] is the = deepest child
+	 *  - path[count] is the first child to create
+	 */
+	do {
+		child_dentry = parent_dentry;
+
+		/* find the parent directory dentry in unionfs */
+		parent_dentry = dget_parent(child_dentry);
+
+		/* find out the lower_parent_dentry in the given branch */
+		lower_parent_dentry =
+			unionfs_lower_dentry_idx(parent_dentry, bindex);
+
+		/* grow path table */
+		if (count == nr_dentry) {
+			void *p;
+
+			nr_dentry *= 2;
+			p = krealloc(path, nr_dentry * sizeof(struct dentry *),
+				     GFP_KERNEL);
+			if (unlikely(!p)) {
+				lower_dentry = ERR_PTR(-ENOMEM);
+				goto out;
+			}
+			path = p;
+		}
+
+		/* store the child dentry */
+		path[count++] = child_dentry;
+	} while (!lower_parent_dentry);
+	count--;
+
+	sb = dentry->d_sb;
+
+	/*
+	 * This code goes between the begin/end labels and basically
+	 * emulates a while(child_dentry != dentry), only cleaner and
+	 * shorter than what would be a much longer while loop.
+	 */
+begin:
+	/* get lower parent dir in the current branch */
+	lower_parent_dentry = unionfs_lower_dentry_idx(parent_dentry, bindex);
+	dput(parent_dentry);
+
+	/* init the values to lookup */
+	childname = child_dentry->d_name.name;
+	childnamelen = child_dentry->d_name.len;
+
+	if (child_dentry != dentry) {
+		/* lookup child in the underlying file system */
+		lower_dentry = lookup_lck_len(childname, lower_parent_dentry,
+					      childnamelen);
+		if (IS_ERR(lower_dentry))
+			goto out;
+	} else {
+		/*
+		 * Is the name a whiteout of the child name ?  lookup the
+		 * whiteout child in the underlying file system
+		 */
+		lower_dentry = lookup_lck_len(name, lower_parent_dentry,
+					      strlen(name));
+		if (IS_ERR(lower_dentry))
+			goto out;
+
+		/* Replace the current dentry (if any) with the new one */
+		dput(unionfs_lower_dentry_idx(dentry, bindex));
+		unionfs_set_lower_dentry_idx(dentry, bindex,
+					     lower_dentry);
+
+		__cleanup_dentry(dentry, bindex, old_bstart, old_bend);
+		goto out;
+	}
+
+	if (lower_dentry->d_inode) {
+		/*
+		 * since this already exists we dput to avoid
+		 * multiple references on the same dentry
+		 */
+		dput(lower_dentry);
+	} else {
+		struct sioq_args args;
+
+		/* it's a negative dentry, create a new dir */
+		lower_parent_dentry = lock_parent(lower_dentry);
+
+		args.mkdir.parent = lower_parent_dentry->d_inode;
+		args.mkdir.dentry = lower_dentry;
+		args.mkdir.mode = child_dentry->d_inode->i_mode;
+
+		run_sioq(__unionfs_mkdir, &args);
+		err = args.err;
+
+		if (!err)
+			err = copyup_permissions(dir->i_sb, child_dentry,
+						 lower_dentry);
+		unlock_dir(lower_parent_dentry);
+		if (err) {
+			dput(lower_dentry);
+			lower_dentry = ERR_PTR(err);
+			goto out;
+		}
+
+	}
+
+	__set_inode(child_dentry, lower_dentry, bindex);
+	__set_dentry(child_dentry, lower_dentry, bindex);
+	/*
+	 * update times of this dentry, but also the parent, because if
+	 * we changed, the parent may have changed too.
+	 */
+	fsstack_copy_attr_times(parent_dentry->d_inode,
+				lower_parent_dentry->d_inode);
+	unionfs_copy_attr_times(child_dentry->d_inode);
+
+	parent_dentry = child_dentry;
+	child_dentry = path[--count];
+	goto begin;
+out:
+	/* cleanup any leftover locks from the do/while loop above */
+	if (IS_ERR(lower_dentry))
+		while (count)
+			dput(path[count--]);
+	kfree(path);
+	return lower_dentry;
+}
+
+/*
+ * Post-copyup helper to ensure we have valid mnts: set lower mnt of
+ * dentry+parents to the first parent node that has an mnt.
+ */
+void unionfs_postcopyup_setmnt(struct dentry *dentry)
+{
+	struct dentry *parent, *hasone;
+	int bindex = dbstart(dentry);
+
+	if (unionfs_lower_mnt_idx(dentry, bindex))
+		return;
+	hasone = dentry->d_parent;
+	/* this loop should stop at root dentry */
+	while (!unionfs_lower_mnt_idx(hasone, bindex))
+		hasone = hasone->d_parent;
+	parent = dentry;
+	while (!unionfs_lower_mnt_idx(parent, bindex)) {
+		unionfs_set_lower_mnt_idx(parent, bindex,
+					  unionfs_mntget(hasone, bindex));
+		parent = parent->d_parent;
+	}
+}
+
+/*
+ * Post-copyup helper to release all non-directory source objects of a
+ * copied-up file.  Regular files should have only one lower object.
+ */
+void unionfs_postcopyup_release(struct dentry *dentry)
+{
+	int bstart, bend;
+
+	BUG_ON(S_ISDIR(dentry->d_inode->i_mode));
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	path_put_lowers(dentry, bstart + 1, bend, false);
+	iput_lowers(dentry->d_inode, bstart + 1, bend, false);
+
+	dbend(dentry) = bstart;
+	ibend(dentry->d_inode) = ibstart(dentry->d_inode) = bstart;
+}
diff --git a/fs/unionfs/debug.c b/fs/unionfs/debug.c
new file mode 100644
index 0000000..acc44bd
--- /dev/null
+++ b/fs/unionfs/debug.c
@@ -0,0 +1,533 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Helper debugging functions for maintainers (and for users to report back
+ * useful information back to maintainers)
+ */
+
+/* it's always useful to know what part of the code called us */
+#define PRINT_CALLER(fname, fxn, line)					\
+	do {								\
+		if (!printed_caller) {					\
+			pr_debug("PC:%s:%s:%d\n", (fname), (fxn), (line)); \
+			printed_caller = 1;				\
+		}							\
+	} while (0)
+
+/*
+ * __unionfs_check_{inode,dentry,file} perform exhaustive sanity checking on
+ * the fan-out of various Unionfs objects.  We check that no lower objects
+ * exist  outside the start/end branch range; that all objects within are
+ * non-NULL (with some allowed exceptions); that for every lower file
+ * there's a lower dentry+inode; that the start/end ranges match for all
+ * corresponding lower objects; that open files/symlinks have only one lower
+ * objects, but directories can have several; and more.
+ */
+void __unionfs_check_inode(const struct inode *inode,
+			   const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int istart, iend;
+	struct inode *lower_inode;
+	struct super_block *sb;
+	int printed_caller = 0;
+	void *poison_ptr;
+
+	/* for inodes now */
+	BUG_ON(!inode);
+	sb = inode->i_sb;
+	istart = ibstart(inode);
+	iend = ibend(inode);
+	/* don't check inode if no lower branches */
+	if (istart < 0 && iend < 0)
+		return;
+	if (unlikely(istart > iend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci0: inode=%p istart/end=%d:%d\n",
+			 inode, istart, iend);
+	}
+	if (unlikely((istart == -1 && iend != -1) ||
+		     (istart != -1 && iend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci1: inode=%p istart/end=%d:%d\n",
+			 inode, istart, iend);
+	}
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(iend != istart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci2: inode=%p istart=%d iend=%d\n",
+				 inode, istart, iend);
+		}
+	}
+
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		if (unlikely(!UNIONFS_I(inode))) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci3: no inode_info %p\n", inode);
+			return;
+		}
+		if (unlikely(!UNIONFS_I(inode)->lower_inodes)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" Ci4: no lower_inodes %p\n", inode);
+			return;
+		}
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			memset(&poison_ptr, POISON_INUSE, sizeof(void *));
+			if (unlikely(bindex < istart || bindex > iend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Ci5: inode/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", inode,
+					 lower_inode, bindex, istart, iend);
+			} else if (unlikely(lower_inode == poison_ptr)) {
+				/* freed inode! */
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Ci6: inode/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", inode,
+					 lower_inode, bindex, istart, iend);
+			}
+			continue;
+		}
+		/* if we get here, then lower_inode == NULL */
+		if (bindex < istart || bindex > iend)
+			continue;
+		/*
+		 * directories can have NULL lower inodes in b/t start/end,
+		 * but NOT if at the start/end range.
+		 */
+		if (unlikely(S_ISDIR(inode->i_mode) &&
+			     bindex > istart && bindex < iend))
+			continue;
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" Ci7: inode/linode=%p:%p "
+			 "bindex=%d istart/end=%d:%d\n",
+			 inode, lower_inode, bindex, istart, iend);
+	}
+}
+
+void __unionfs_check_dentry(const struct dentry *dentry,
+			    const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int dstart, dend, istart, iend;
+	struct dentry *lower_dentry;
+	struct inode *inode, *lower_inode;
+	struct super_block *sb;
+	struct vfsmount *lower_mnt;
+	int printed_caller = 0;
+	void *poison_ptr;
+
+	BUG_ON(!dentry);
+	sb = dentry->d_sb;
+	inode = dentry->d_inode;
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	/* don't check dentry/mnt if no lower branches */
+	if (dstart < 0 && dend < 0)
+		goto check_inode;
+	BUG_ON(dstart > dend);
+
+	if (unlikely((dstart == -1 && dend != -1) ||
+		     (dstart != -1 && dend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CD0: dentry=%p dstart/end=%d:%d\n",
+			 dentry, dstart, dend);
+	}
+	/*
+	 * check for NULL dentries inside the start/end range, or
+	 * non-NULL dentries outside the start/end range.
+	 */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (lower_dentry) {
+			if (unlikely(bindex < dstart || bindex > dend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CD1: dentry/lower=%p:%p(%p) "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_dentry,
+					 (lower_dentry ? lower_dentry->d_inode :
+					  (void *) -1L),
+					 bindex, dstart, dend);
+			}
+		} else {	/* lower_dentry == NULL */
+			if (bindex < dstart || bindex > dend)
+				continue;
+			/*
+			 * Directories can have NULL lower inodes in b/t
+			 * start/end, but NOT if at the start/end range.
+			 * Ignore this rule, however, if this is a NULL
+			 * dentry or a deleted dentry.
+			 */
+			if (unlikely(!d_deleted((struct dentry *) dentry) &&
+				     inode &&
+				     !(inode && S_ISDIR(inode->i_mode) &&
+				       bindex > dstart && bindex < dend))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CD2: dentry/lower=%p:%p(%p) "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_dentry,
+					 (lower_dentry ?
+					  lower_dentry->d_inode :
+					  (void *) -1L),
+					 bindex, dstart, dend);
+			}
+		}
+	}
+
+	/* check for vfsmounts same as for dentries */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+		if (lower_mnt) {
+			if (unlikely(bindex < dstart || bindex > dend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CM0: dentry/lmnt=%p:%p bindex=%d "
+					 "dstart/end=%d:%d\n", dentry,
+					 lower_mnt, bindex, dstart, dend);
+			}
+		} else {	/* lower_mnt == NULL */
+			if (bindex < dstart || bindex > dend)
+				continue;
+			/*
+			 * Directories can have NULL lower inodes in b/t
+			 * start/end, but NOT if at the start/end range.
+			 * Ignore this rule, however, if this is a NULL
+			 * dentry.
+			 */
+			if (unlikely(inode &&
+				     !(inode && S_ISDIR(inode->i_mode) &&
+				       bindex > dstart && bindex < dend))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CM1: dentry/lmnt=%p:%p "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 dentry, lower_mnt, bindex,
+					 dstart, dend);
+			}
+		}
+	}
+
+check_inode:
+	/* for inodes now */
+	if (!inode)
+		return;
+	istart = ibstart(inode);
+	iend = ibend(inode);
+	/* don't check inode if no lower branches */
+	if (istart < 0 && iend < 0)
+		return;
+	BUG_ON(istart > iend);
+	if (unlikely((istart == -1 && iend != -1) ||
+		     (istart != -1 && iend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI0: dentry/inode=%p:%p istart/end=%d:%d\n",
+			 dentry, inode, istart, iend);
+	}
+	if (unlikely(istart != dstart)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI1: dentry/inode=%p:%p istart=%d dstart=%d\n",
+			 dentry, inode, istart, dstart);
+	}
+	if (unlikely(iend != dend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI2: dentry/inode=%p:%p iend=%d dend=%d\n",
+			 dentry, inode, iend, dend);
+	}
+
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(dend != dstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CI3: dentry/inode=%p:%p dstart=%d dend=%d\n",
+				 dentry, inode, dstart, dend);
+		}
+		if (unlikely(iend != istart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CI4: dentry/inode=%p:%p istart=%d iend=%d\n",
+				 dentry, inode, istart, iend);
+		}
+	}
+
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			memset(&poison_ptr, POISON_INUSE, sizeof(void *));
+			if (unlikely(bindex < istart || bindex > iend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CI5: dentry/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", dentry,
+					 lower_inode, bindex, istart, iend);
+			} else if (unlikely(lower_inode == poison_ptr)) {
+				/* freed inode! */
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CI6: dentry/linode=%p:%p bindex=%d "
+					 "istart/end=%d:%d\n", dentry,
+					 lower_inode, bindex, istart, iend);
+			}
+			continue;
+		}
+		/* if we get here, then lower_inode == NULL */
+		if (bindex < istart || bindex > iend)
+			continue;
+		/*
+		 * directories can have NULL lower inodes in b/t start/end,
+		 * but NOT if at the start/end range.
+		 */
+		if (unlikely(S_ISDIR(inode->i_mode) &&
+			     bindex > istart && bindex < iend))
+			continue;
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CI7: dentry/linode=%p:%p "
+			 "bindex=%d istart/end=%d:%d\n",
+			 dentry, lower_inode, bindex, istart, iend);
+	}
+
+	/*
+	 * If it's a directory, then intermediate objects b/t start/end can
+	 * be NULL.  But, check that all three are NULL: lower dentry, mnt,
+	 * and inode.
+	 */
+	if (dstart >= 0 && dend >= 0 && S_ISDIR(inode->i_mode))
+		for (bindex = dstart+1; bindex < dend; bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			lower_dentry = unionfs_lower_dentry_idx(dentry,
+								bindex);
+			lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+			if (unlikely(!((lower_inode && lower_dentry &&
+					lower_mnt) ||
+				       (!lower_inode &&
+					!lower_dentry && !lower_mnt)))) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" Cx: lmnt/ldentry/linode=%p:%p:%p "
+					 "bindex=%d dstart/end=%d:%d\n",
+					 lower_mnt, lower_dentry, lower_inode,
+					 bindex, dstart, dend);
+			}
+		}
+	/* check if lower inode is newer than upper one (it shouldn't) */
+	if (unlikely(is_newer_lower(dentry) && !is_negative_lower(dentry))) {
+		PRINT_CALLER(fname, fxn, line);
+		for (bindex = ibstart(inode); bindex <= ibend(inode);
+		     bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			if (unlikely(!lower_inode))
+				continue;
+			pr_debug(" CI8: bindex=%d mtime/lmtime=%lu.%lu/%lu.%lu "
+				 "ctime/lctime=%lu.%lu/%lu.%lu\n",
+				 bindex,
+				 inode->i_mtime.tv_sec,
+				 inode->i_mtime.tv_nsec,
+				 lower_inode->i_mtime.tv_sec,
+				 lower_inode->i_mtime.tv_nsec,
+				 inode->i_ctime.tv_sec,
+				 inode->i_ctime.tv_nsec,
+				 lower_inode->i_ctime.tv_sec,
+				 lower_inode->i_ctime.tv_nsec);
+		}
+	}
+}
+
+void __unionfs_check_file(const struct file *file,
+			  const char *fname, const char *fxn, int line)
+{
+	int bindex;
+	int dstart, dend, fstart, fend;
+	struct dentry *dentry;
+	struct file *lower_file;
+	struct inode *inode;
+	struct super_block *sb;
+	int printed_caller = 0;
+
+	BUG_ON(!file);
+	dentry = file->f_path.dentry;
+	sb = dentry->d_sb;
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	BUG_ON(dstart > dend);
+	fstart = fbstart(file);
+	fend = fbend(file);
+	BUG_ON(fstart > fend);
+
+	if (unlikely((fstart == -1 && fend != -1) ||
+		     (fstart != -1 && fend == -1))) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF0: file/dentry=%p:%p fstart/end=%d:%d\n",
+			 file, dentry, fstart, fend);
+	}
+	if (unlikely(fstart != dstart)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF1: file/dentry=%p:%p fstart=%d dstart=%d\n",
+			 file, dentry, fstart, dstart);
+	}
+	if (unlikely(fend != dend)) {
+		PRINT_CALLER(fname, fxn, line);
+		pr_debug(" CF2: file/dentry=%p:%p fend=%d dend=%d\n",
+			 file, dentry, fend, dend);
+	}
+	inode = dentry->d_inode;
+	if (!S_ISDIR(inode->i_mode)) {
+		if (unlikely(fend != fstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CF3: file/inode=%p:%p fstart=%d fend=%d\n",
+				 file, inode, fstart, fend);
+		}
+		if (unlikely(dend != dstart)) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CF4: file/dentry=%p:%p dstart=%d dend=%d\n",
+				 file, dentry, dstart, dend);
+		}
+	}
+
+	/*
+	 * check for NULL dentries inside the start/end range, or
+	 * non-NULL dentries outside the start/end range.
+	 */
+	for (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		if (lower_file) {
+			if (unlikely(bindex < fstart || bindex > fend)) {
+				PRINT_CALLER(fname, fxn, line);
+				pr_debug(" CF5: file/lower=%p:%p bindex=%d "
+					 "fstart/end=%d:%d\n", file,
+					 lower_file, bindex, fstart, fend);
+			}
+		} else {	/* lower_file == NULL */
+			if (bindex >= fstart && bindex <= fend) {
+				/*
+				 * directories can have NULL lower inodes in
+				 * b/t start/end, but NOT if at the
+				 * start/end range.
+				 */
+				if (unlikely(!(S_ISDIR(inode->i_mode) &&
+					       bindex > fstart &&
+					       bindex < fend))) {
+					PRINT_CALLER(fname, fxn, line);
+					pr_debug(" CF6: file/lower=%p:%p "
+						 "bindex=%d fstart/end=%d:%d\n",
+						 file, lower_file, bindex,
+						 fstart, fend);
+				}
+			}
+		}
+	}
+
+	__unionfs_check_dentry(dentry, fname, fxn, line);
+}
+
+void __unionfs_check_nd(const struct nameidata *nd,
+			const char *fname, const char *fxn, int line)
+{
+	struct file *file;
+	int printed_caller = 0;
+
+	if (unlikely(!nd))
+		return;
+	if (nd->flags & LOOKUP_OPEN) {
+		file = nd->intent.open.file;
+		if (unlikely(file->f_path.dentry &&
+			     strcmp(file->f_path.dentry->d_sb->s_type->name,
+				    UNIONFS_NAME))) {
+			PRINT_CALLER(fname, fxn, line);
+			pr_debug(" CND1: lower_file of type %s\n",
+				 file->f_path.dentry->d_sb->s_type->name);
+			BUG();
+		}
+	}
+}
+
+/* useful to track vfsmount leaks that could cause EBUSY on unmount */
+void __show_branch_counts(const struct super_block *sb,
+			  const char *file, const char *fxn, int line)
+{
+	int i;
+	struct vfsmount *mnt;
+
+	pr_debug("BC:");
+	for (i = 0; i < sbmax(sb); i++) {
+		if (likely(sb->s_root))
+			mnt = UNIONFS_D(sb->s_root)->lower_paths[i].mnt;
+		else
+			mnt = NULL;
+		printk(KERN_CONT "%d:",
+		       (mnt ? atomic_read(&mnt->mnt_count) : -99));
+	}
+	printk(KERN_CONT "%s:%s:%d\n", file, fxn, line);
+}
+
+void __show_inode_times(const struct inode *inode,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (unlikely(!lower_inode))
+			continue;
+		pr_debug("IT(%lu:%d): %s:%s:%d "
+			 "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\n",
+			 inode->i_ino, bindex,
+			 file, fxn, line,
+			 inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
+			 lower_inode->i_mtime.tv_sec,
+			 lower_inode->i_mtime.tv_nsec,
+			 inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
+			 lower_inode->i_ctime.tv_sec,
+			 lower_inode->i_ctime.tv_nsec);
+	}
+}
+
+void __show_dinode_times(const struct dentry *dentry,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *inode = dentry->d_inode;
+	struct inode *lower_inode;
+	int bindex;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+		pr_debug("DT(%s:%lu:%d): %s:%s:%d "
+			 "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\n",
+			 dentry->d_name.name, inode->i_ino, bindex,
+			 file, fxn, line,
+			 inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,
+			 lower_inode->i_mtime.tv_sec,
+			 lower_inode->i_mtime.tv_nsec,
+			 inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,
+			 lower_inode->i_ctime.tv_sec,
+			 lower_inode->i_ctime.tv_nsec);
+	}
+}
+
+void __show_inode_counts(const struct inode *inode,
+			const char *file, const char *fxn, int line)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	if (unlikely(!inode)) {
+		pr_debug("SiC: Null inode\n");
+		return;
+	}
+	for (bindex = sbstart(inode->i_sb); bindex <= sbend(inode->i_sb);
+	     bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (unlikely(!lower_inode))
+			continue;
+		pr_debug("SIC(%lu:%d:%d): lc=%d %s:%s:%d\n",
+			 inode->i_ino, bindex,
+			 atomic_read(&(inode)->i_count),
+			 atomic_read(&(lower_inode)->i_count),
+			 file, fxn, line);
+	}
+}
diff --git a/fs/unionfs/dentry.c b/fs/unionfs/dentry.c
new file mode 100644
index 0000000..a0c3bba
--- /dev/null
+++ b/fs/unionfs/dentry.c
@@ -0,0 +1,397 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+bool is_negative_lower(const struct dentry *dentry)
+{
+	int bindex;
+	struct dentry *lower_dentry;
+
+	BUG_ON(!dentry);
+	/* cache coherency: check if file was deleted on lower branch */
+	if (dbstart(dentry) < 0)
+		return true;
+	for (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		/* unhashed (i.e., unlinked) lower dentries don't count */
+		if (lower_dentry && lower_dentry->d_inode &&
+		    !d_deleted(lower_dentry) &&
+		    !(lower_dentry->d_flags & DCACHE_NFSFS_RENAMED))
+			return false;
+	}
+	return true;
+}
+
+static inline void __dput_lowers(struct dentry *dentry, int start, int end)
+{
+	struct dentry *lower_dentry;
+	int bindex;
+
+	if (start < 0)
+		return;
+	for (bindex = start; bindex <= end; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+		dput(lower_dentry);
+	}
+}
+
+/*
+ * Purge and invalidate as many data pages of a unionfs inode.  This is
+ * called when the lower inode has changed, and we want to force processes
+ * to re-get the new data.
+ */
+static inline void purge_inode_data(struct inode *inode)
+{
+	/* remove all non-private mappings */
+	unmap_mapping_range(inode->i_mapping, 0, 0, 0);
+	/* invalidate as many pages as possible */
+	invalidate_mapping_pages(inode->i_mapping, 0, -1);
+	/*
+	 * Don't try to truncate_inode_pages here, because this could lead
+	 * to a deadlock between some of address_space ops and dentry
+	 * revalidation: the address space op is invoked with a lock on our
+	 * own page, and truncate_inode_pages will block on locked pages.
+	 */
+}
+
+/*
+ * Revalidate a single file/symlink/special dentry.  Assume that info nodes
+ * of the @dentry and its @parent are locked.  Assume parent is valid,
+ * otherwise return false (and let's hope the VFS will try to re-lookup this
+ * dentry).  Returns true if valid, false otherwise.
+ */
+bool __unionfs_d_revalidate(struct dentry *dentry, struct dentry *parent,
+			    bool willwrite)
+{
+	bool valid = true;	/* default is valid */
+	struct dentry *lower_dentry;
+	struct dentry *result;
+	int bindex, bstart, bend;
+	int sbgen, dgen, pdgen;
+	int positive = 0;
+	int interpose_flag;
+
+	verify_locked(dentry);
+	verify_locked(parent);
+
+	/* if the dentry is unhashed, do NOT revalidate */
+	if (d_deleted(dentry))
+		goto out;
+
+	dgen = atomic_read(&UNIONFS_D(dentry)->generation);
+
+	if (is_newer_lower(dentry)) {
+		/* root dentry is always valid */
+		if (IS_ROOT(dentry)) {
+			unionfs_copy_attr_times(dentry->d_inode);
+		} else {
+			/*
+			 * reset generation number to zero, guaranteed to be
+			 * "old"
+			 */
+			dgen = 0;
+			atomic_set(&UNIONFS_D(dentry)->generation, dgen);
+		}
+		if (!willwrite)
+			purge_inode_data(dentry->d_inode);
+	}
+
+	sbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);
+
+	BUG_ON(dbstart(dentry) == -1);
+	if (dentry->d_inode)
+		positive = 1;
+
+	/* if our dentry is valid, then validate all lower ones */
+	if (sbgen == dgen)
+		goto validate_lowers;
+
+	/* The root entry should always be valid */
+	BUG_ON(IS_ROOT(dentry));
+
+	/* We can't work correctly if our parent isn't valid. */
+	pdgen = atomic_read(&UNIONFS_D(parent)->generation);
+
+	/* Free the pointers for our inodes and this dentry. */
+	path_put_lowers_all(dentry, false);
+
+	interpose_flag = INTERPOSE_REVAL_NEG;
+	if (positive) {
+		interpose_flag = INTERPOSE_REVAL;
+		iput_lowers_all(dentry->d_inode, true);
+	}
+
+	if (realloc_dentry_private_data(dentry) != 0) {
+		valid = false;
+		goto out;
+	}
+
+	result = unionfs_lookup_full(dentry, parent, interpose_flag);
+	if (result) {
+		if (IS_ERR(result)) {
+			valid = false;
+			goto out;
+		}
+		/*
+		 * current unionfs_lookup_backend() doesn't return
+		 * a valid dentry
+		 */
+		dput(dentry);
+		dentry = result;
+	}
+
+	if (unlikely(positive && is_negative_lower(dentry))) {
+		/* call make_bad_inode here ? */
+		d_drop(dentry);
+		valid = false;
+		goto out;
+	}
+
+	/*
+	 * if we got here then we have revalidated our dentry and all lower
+	 * ones, so we can return safely.
+	 */
+	if (!valid)		/* lower dentry revalidation failed */
+		goto out;
+
+	/*
+	 * If the parent's gen no.  matches the superblock's gen no., then
+	 * we can update our denty's gen no.  If they didn't match, then it
+	 * was OK to revalidate this dentry with a stale parent, but we'll
+	 * purposely not update our dentry's gen no. (so it can be redone);
+	 * and, we'll mark our parent dentry as invalid so it'll force it
+	 * (and our dentry) to be revalidated.
+	 */
+	if (pdgen == sbgen)
+		atomic_set(&UNIONFS_D(dentry)->generation, sbgen);
+	goto out;
+
+validate_lowers:
+
+	/* The revalidation must occur across all branches */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart == -1);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry || !lower_dentry->d_op
+		    || !lower_dentry->d_op->d_revalidate)
+			continue;
+		/*
+		 * Don't pass nameidata to lower file system, because we
+		 * don't want an arbitrary lower file being opened or
+		 * returned to us: it may be useless to us because of the
+		 * fanout nature of unionfs (cf. file/directory open-file
+		 * invariants).  We will open lower files as and when needed
+		 * later on.
+		 */
+		if (!lower_dentry->d_op->d_revalidate(lower_dentry, NULL))
+			valid = false;
+	}
+
+	if (!dentry->d_inode ||
+	    ibstart(dentry->d_inode) < 0 ||
+	    ibend(dentry->d_inode) < 0) {
+		valid = false;
+		goto out;
+	}
+
+	if (valid) {
+		/*
+		 * If we get here, and we copy the meta-data from the lower
+		 * inode to our inode, then it is vital that we have already
+		 * purged all unionfs-level file data.  We do that in the
+		 * caller (__unionfs_d_revalidate) by calling
+		 * purge_inode_data.
+		 */
+		unionfs_copy_attr_all(dentry->d_inode,
+				      unionfs_lower_inode(dentry->d_inode));
+		fsstack_copy_inode_size(dentry->d_inode,
+					unionfs_lower_inode(dentry->d_inode));
+	}
+
+out:
+	return valid;
+}
+
+/*
+ * Determine if the lower inode objects have changed from below the unionfs
+ * inode.  Return true if changed, false otherwise.
+ *
+ * We check if the mtime or ctime have changed.  However, the inode times
+ * can be changed by anyone without much protection, including
+ * asynchronously.  This can sometimes cause unionfs to find that the lower
+ * file system doesn't change its inode times quick enough, resulting in a
+ * false positive indication (which is harmless, it just makes unionfs do
+ * extra work in re-validating the objects).  To minimize the chances of
+ * these situations, we still consider such small time changes valid, but we
+ * don't print debugging messages unless the time changes are greater than
+ * UNIONFS_MIN_CC_TIME (which defaults to 3 seconds, as with NFS's acregmin)
+ * because significant changes are more likely due to users manually
+ * touching lower files.
+ */
+bool is_newer_lower(const struct dentry *dentry)
+{
+	int bindex;
+	struct inode *inode;
+	struct inode *lower_inode;
+
+	/* ignore if we're called on semi-initialized dentries/inodes */
+	if (!dentry || !UNIONFS_D(dentry))
+		return false;
+	inode = dentry->d_inode;
+	if (!inode || !UNIONFS_I(inode)->lower_inodes ||
+	    ibstart(inode) < 0 || ibend(inode) < 0)
+		return false;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		/* check if mtime/ctime have changed */
+		if (unlikely(timespec_compare(&inode->i_mtime,
+					      &lower_inode->i_mtime) < 0)) {
+			if ((lower_inode->i_mtime.tv_sec -
+			     inode->i_mtime.tv_sec) > UNIONFS_MIN_CC_TIME) {
+				pr_info("unionfs: new lower inode mtime "
+					"(bindex=%d, name=%s)\n", bindex,
+					dentry->d_name.name);
+				show_dinode_times(dentry);
+			}
+			return true;
+		}
+		if (unlikely(timespec_compare(&inode->i_ctime,
+					      &lower_inode->i_ctime) < 0)) {
+			if ((lower_inode->i_ctime.tv_sec -
+			     inode->i_ctime.tv_sec) > UNIONFS_MIN_CC_TIME) {
+				pr_info("unionfs: new lower inode ctime "
+					"(bindex=%d, name=%s)\n", bindex,
+					dentry->d_name.name);
+				show_dinode_times(dentry);
+			}
+			return true;
+		}
+	}
+
+	/*
+	 * Last check: if this is a positive dentry, but somehow all lower
+	 * dentries are negative or unhashed, then this dentry needs to be
+	 * revalidated, because someone probably deleted the objects from
+	 * the lower branches directly.
+	 */
+	if (is_negative_lower(dentry))
+		return true;
+
+	return false;		/* default: lower is not newer */
+}
+
+static int unionfs_d_revalidate(struct dentry *dentry,
+				struct nameidata *nd_unused)
+{
+	bool valid = true;
+	int err = 1;		/* 1 means valid for the VFS */
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (valid) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_dentry(dentry);
+	} else {
+		d_drop(dentry);
+		err = valid;
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+static void unionfs_d_release(struct dentry *dentry)
+{
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	if (unlikely(!UNIONFS_D(dentry)))
+		goto out;	/* skip if no lower branches */
+	/* must lock our branch configuration here */
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	unionfs_check_dentry(dentry);
+	/* this could be a negative dentry, so check first */
+	if (dbstart(dentry) < 0) {
+		unionfs_unlock_dentry(dentry);
+		goto out;	/* due to a (normal) failed lookup */
+	}
+
+	/* Release all the lower dentries */
+	path_put_lowers_all(dentry, true);
+
+	unionfs_unlock_dentry(dentry);
+
+out:
+	free_dentry_private_data(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	return;
+}
+
+/*
+ * Called when we're removing the last reference to our dentry.  So we
+ * should drop all lower references too.
+ */
+static void unionfs_d_iput(struct dentry *dentry, struct inode *inode)
+{
+	int rc;
+
+	BUG_ON(!dentry);
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (!UNIONFS_D(dentry) || dbstart(dentry) < 0)
+		goto drop_lower_inodes;
+	path_put_lowers_all(dentry, false);
+
+drop_lower_inodes:
+	rc = atomic_read(&inode->i_count);
+	if (rc == 1 && inode->i_nlink == 1 && ibstart(inode) >= 0) {
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		iput(unionfs_lower_inode(inode));
+		lockdep_on();
+		unionfs_set_lower_inode(inode, NULL);
+		/* XXX: may need to set start/end to -1? */
+	}
+
+	iput(inode);
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+}
+
+struct dentry_operations unionfs_dops = {
+	.d_revalidate	= unionfs_d_revalidate,
+	.d_release	= unionfs_d_release,
+	.d_iput		= unionfs_d_iput,
+};
diff --git a/fs/unionfs/dirfops.c b/fs/unionfs/dirfops.c
new file mode 100644
index 0000000..7da0ff0
--- /dev/null
+++ b/fs/unionfs/dirfops.c
@@ -0,0 +1,302 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* Make sure our rdstate is playing by the rules. */
+static void verify_rdstate_offset(struct unionfs_dir_state *rdstate)
+{
+	BUG_ON(rdstate->offset >= DIREOF);
+	BUG_ON(rdstate->cookie >= MAXRDCOOKIE);
+}
+
+struct unionfs_getdents_callback {
+	struct unionfs_dir_state *rdstate;
+	void *dirent;
+	int entries_written;
+	int filldir_called;
+	int filldir_error;
+	filldir_t filldir;
+	struct super_block *sb;
+};
+
+/* based on generic filldir in fs/readir.c */
+static int unionfs_filldir(void *dirent, const char *oname, int namelen,
+			   loff_t offset, u64 ino, unsigned int d_type)
+{
+	struct unionfs_getdents_callback *buf = dirent;
+	struct filldir_node *found = NULL;
+	int err = 0;
+	int is_whiteout;
+	char *name = (char *) oname;
+
+	buf->filldir_called++;
+
+	is_whiteout = is_whiteout_name(&name, &namelen);
+
+	found = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);
+
+	if (found) {
+		/*
+		 * If we had non-whiteout entry in dir cache, then mark it
+		 * as a whiteout and but leave it in the dir cache.
+		 */
+		if (is_whiteout && !found->whiteout)
+			found->whiteout = is_whiteout;
+		goto out;
+	}
+
+	/* if 'name' isn't a whiteout, filldir it. */
+	if (!is_whiteout) {
+		off_t pos = rdstate2offset(buf->rdstate);
+		u64 unionfs_ino = ino;
+
+		err = buf->filldir(buf->dirent, name, namelen, pos,
+				   unionfs_ino, d_type);
+		buf->rdstate->offset++;
+		verify_rdstate_offset(buf->rdstate);
+	}
+	/*
+	 * If we did fill it, stuff it in our hash, otherwise return an
+	 * error.
+	 */
+	if (err) {
+		buf->filldir_error = err;
+		goto out;
+	}
+	buf->entries_written++;
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->bindex, is_whiteout);
+	if (err)
+		buf->filldir_error = err;
+
+out:
+	return err;
+}
+
+static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err = 0;
+	struct file *lower_file = NULL;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	struct inode *inode = NULL;
+	struct unionfs_getdents_callback buf;
+	struct unionfs_dir_state *uds;
+	int bend;
+	loff_t offset;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, false);
+	if (unlikely(err))
+		goto out;
+
+	inode = dentry->d_inode;
+
+	uds = UNIONFS_F(file)->rdstate;
+	if (!uds) {
+		if (file->f_pos == DIREOF) {
+			goto out;
+		} else if (file->f_pos > 0) {
+			uds = find_rdstate(inode, file->f_pos);
+			if (unlikely(!uds)) {
+				err = -ESTALE;
+				goto out;
+			}
+			UNIONFS_F(file)->rdstate = uds;
+		} else {
+			init_rdstate(file);
+			uds = UNIONFS_F(file)->rdstate;
+		}
+	}
+	bend = fbend(file);
+
+	while (uds->bindex <= bend) {
+		lower_file = unionfs_lower_file_idx(file, uds->bindex);
+		if (!lower_file) {
+			uds->bindex++;
+			uds->dirpos = 0;
+			continue;
+		}
+
+		/* prepare callback buffer */
+		buf.filldir_called = 0;
+		buf.filldir_error = 0;
+		buf.entries_written = 0;
+		buf.dirent = dirent;
+		buf.filldir = filldir;
+		buf.rdstate = uds;
+		buf.sb = inode->i_sb;
+
+		/* Read starting from where we last left off. */
+		offset = vfs_llseek(lower_file, uds->dirpos, SEEK_SET);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		err = vfs_readdir(lower_file, unionfs_filldir, &buf);
+
+		/* Save the position for when we continue. */
+		offset = vfs_llseek(lower_file, 0, SEEK_CUR);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		uds->dirpos = offset;
+
+		/* Copy the atime. */
+		fsstack_copy_attr_atime(inode,
+					lower_file->f_path.dentry->d_inode);
+
+		if (err < 0)
+			goto out;
+
+		if (buf.filldir_error)
+			break;
+
+		if (!buf.entries_written) {
+			uds->bindex++;
+			uds->dirpos = 0;
+		}
+	}
+
+	if (!buf.filldir_error && uds->bindex >= bend) {
+		/* Save the number of hash entries for next time. */
+		UNIONFS_I(inode)->hashsize = uds->hashentries;
+		free_rdstate(uds);
+		UNIONFS_F(file)->rdstate = NULL;
+		file->f_pos = DIREOF;
+	} else {
+		file->f_pos = rdstate2offset(uds);
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * This is not meant to be a generic repositioning function.  If you do
+ * things that aren't supported, then we return EINVAL.
+ *
+ * What is allowed:
+ *  (1) seeking to the same position that you are currently at
+ *	This really has no effect, but returns where you are.
+ *  (2) seeking to the beginning of the file
+ *	This throws out all state, and lets you begin again.
+ */
+static loff_t unionfs_dir_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct unionfs_dir_state *rdstate;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	loff_t err;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, false);
+	if (unlikely(err))
+		goto out;
+
+	rdstate = UNIONFS_F(file)->rdstate;
+
+	/*
+	 * we let users seek to their current position, but not anywhere
+	 * else.
+	 */
+	if (!offset) {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				free_rdstate(rdstate);
+				UNIONFS_F(file)->rdstate = NULL;
+			}
+			init_rdstate(file);
+			err = 0;
+			break;
+		case SEEK_CUR:
+			err = file->f_pos;
+			break;
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	} else {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				if (offset == rdstate2offset(rdstate))
+					err = offset;
+				else if (file->f_pos == DIREOF)
+					err = DIREOF;
+				else
+					err = -EINVAL;
+			} else {
+				struct inode *inode;
+				inode = dentry->d_inode;
+				rdstate = find_rdstate(inode, offset);
+				if (rdstate) {
+					UNIONFS_F(file)->rdstate = rdstate;
+					err = rdstate->offset;
+				} else {
+					err = -EINVAL;
+				}
+			}
+			break;
+		case SEEK_CUR:
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * Trimmed directory options, we shouldn't pass everything down since
+ * we don't want to operate on partial directories.
+ */
+struct file_operations unionfs_dir_fops = {
+	.llseek		= unionfs_dir_llseek,
+	.read		= generic_read_dir,
+	.readdir	= unionfs_readdir,
+	.unlocked_ioctl	= unionfs_ioctl,
+	.open		= unionfs_open,
+	.release	= unionfs_file_release,
+	.flush		= unionfs_flush,
+	.fsync		= unionfs_fsync,
+	.fasync		= unionfs_fasync,
+};
diff --git a/fs/unionfs/dirhelper.c b/fs/unionfs/dirhelper.c
new file mode 100644
index 0000000..033343b
--- /dev/null
+++ b/fs/unionfs/dirhelper.c
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+#define RD_NONE 0
+#define RD_CHECK_EMPTY 1
+/* The callback structure for check_empty. */
+struct unionfs_rdutil_callback {
+	int err;
+	int filldir_called;
+	struct unionfs_dir_state *rdstate;
+	int mode;
+};
+
+/* This filldir function makes sure only whiteouts exist within a directory. */
+static int readdir_util_callback(void *dirent, const char *oname, int namelen,
+				 loff_t offset, u64 ino, unsigned int d_type)
+{
+	int err = 0;
+	struct unionfs_rdutil_callback *buf = dirent;
+	int is_whiteout;
+	struct filldir_node *found;
+	char *name = (char *) oname;
+
+	buf->filldir_called = 1;
+
+	if (name[0] == '.' && (namelen == 1 ||
+			       (name[1] == '.' && namelen == 2)))
+		goto out;
+
+	is_whiteout = is_whiteout_name(&name, &namelen);
+
+	found = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);
+	/* If it was found in the table there was a previous whiteout. */
+	if (found)
+		goto out;
+
+	/*
+	 * if it wasn't found and isn't a whiteout, the directory isn't
+	 * empty.
+	 */
+	err = -ENOTEMPTY;
+	if ((buf->mode == RD_CHECK_EMPTY) && !is_whiteout)
+		goto out;
+
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->bindex, is_whiteout);
+
+out:
+	buf->err = err;
+	return err;
+}
+
+/* Is a directory logically empty? */
+int check_empty(struct dentry *dentry, struct dentry *parent,
+		struct unionfs_dir_state **namelist)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct vfsmount *mnt;
+	struct super_block *sb;
+	struct file *lower_file;
+	struct unionfs_rdutil_callback *buf = NULL;
+	int bindex, bstart, bend, bopaque;
+
+	sb = dentry->d_sb;
+
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+
+	err = unionfs_partial_lookup(dentry, parent);
+	if (err)
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	bopaque = dbopaque(dentry);
+	if (0 <= bopaque && bopaque < bend)
+		bend = bopaque;
+
+	buf = kmalloc(sizeof(struct unionfs_rdutil_callback), GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	buf->err = 0;
+	buf->mode = RD_CHECK_EMPTY;
+	buf->rdstate = alloc_rdstate(dentry->d_inode, bstart);
+	if (unlikely(!buf->rdstate)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Process the lower directories with rdutil_callback as a filldir. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (!lower_dentry->d_inode)
+			continue;
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+			continue;
+
+		dget(lower_dentry);
+		mnt = unionfs_mntget(dentry, bindex);
+		branchget(sb, bindex);
+		lower_file = dentry_open(lower_dentry, mnt, O_RDONLY, current_cred());
+		if (IS_ERR(lower_file)) {
+			err = PTR_ERR(lower_file);
+			branchput(sb, bindex);
+			goto out;
+		}
+
+		do {
+			buf->filldir_called = 0;
+			buf->rdstate->bindex = bindex;
+			err = vfs_readdir(lower_file,
+					  readdir_util_callback, buf);
+			if (buf->err)
+				err = buf->err;
+		} while ((err >= 0) && buf->filldir_called);
+
+		/* fput calls dput for lower_dentry */
+		fput(lower_file);
+		branchput(sb, bindex);
+
+		if (err < 0)
+			goto out;
+	}
+
+out:
+	if (buf) {
+		if (namelist && !err)
+			*namelist = buf->rdstate;
+		else if (buf->rdstate)
+			free_rdstate(buf->rdstate);
+		kfree(buf);
+	}
+
+
+	return err;
+}
diff --git a/fs/unionfs/fanout.h b/fs/unionfs/fanout.h
new file mode 100644
index 0000000..5b77eac
--- /dev/null
+++ b/fs/unionfs/fanout.h
@@ -0,0 +1,407 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _FANOUT_H_
+#define _FANOUT_H_
+
+/*
+ * Inode to private data
+ *
+ * Since we use containers and the struct inode is _inside_ the
+ * unionfs_inode_info structure, UNIONFS_I will always (given a non-NULL
+ * inode pointer), return a valid non-NULL pointer.
+ */
+static inline struct unionfs_inode_info *UNIONFS_I(const struct inode *inode)
+{
+	return container_of(inode, struct unionfs_inode_info, vfs_inode);
+}
+
+#define ibstart(ino) (UNIONFS_I(ino)->bstart)
+#define ibend(ino) (UNIONFS_I(ino)->bend)
+
+/* Dentry to private data */
+#define UNIONFS_D(dent) ((struct unionfs_dentry_info *)(dent)->d_fsdata)
+#define dbstart(dent) (UNIONFS_D(dent)->bstart)
+#define dbend(dent) (UNIONFS_D(dent)->bend)
+#define dbopaque(dent) (UNIONFS_D(dent)->bopaque)
+
+/* Superblock to private data */
+#define UNIONFS_SB(super) ((struct unionfs_sb_info *)(super)->s_fs_info)
+#define sbstart(sb) 0
+#define sbend(sb) (UNIONFS_SB(sb)->bend)
+#define sbmax(sb) (UNIONFS_SB(sb)->bend + 1)
+#define sbhbid(sb) (UNIONFS_SB(sb)->high_branch_id)
+
+/* File to private Data */
+#define UNIONFS_F(file) ((struct unionfs_file_info *)((file)->private_data))
+#define fbstart(file) (UNIONFS_F(file)->bstart)
+#define fbend(file) (UNIONFS_F(file)->bend)
+
+/* macros to manipulate branch IDs in stored in our superblock */
+static inline int branch_id(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	return UNIONFS_SB(sb)->data[index].branch_id;
+}
+
+static inline void set_branch_id(struct super_block *sb, int index, int val)
+{
+	BUG_ON(!sb || index < 0);
+	UNIONFS_SB(sb)->data[index].branch_id = val;
+}
+
+static inline void new_branch_id(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	set_branch_id(sb, index, ++UNIONFS_SB(sb)->high_branch_id);
+}
+
+/*
+ * Find new index of matching branch with an existing superblock of a known
+ * (possibly old) id.  This is needed because branches could have been
+ * added/deleted causing the branches of any open files to shift.
+ *
+ * @sb: the new superblock which may have new/different branch IDs
+ * @id: the old/existing id we're looking for
+ * Returns index of newly found branch (0 or greater), -1 otherwise.
+ */
+static inline int branch_id_to_idx(struct super_block *sb, int id)
+{
+	int i;
+	for (i = 0; i < sbmax(sb); i++) {
+		if (branch_id(sb, i) == id)
+			return i;
+	}
+	/* in the non-ODF code, this should really never happen */
+	printk(KERN_WARNING "unionfs: cannot find branch with id %d\n", id);
+	return -1;
+}
+
+/* File to lower file. */
+static inline struct file *unionfs_lower_file(const struct file *f)
+{
+	BUG_ON(!f);
+	return UNIONFS_F(f)->lower_files[fbstart(f)];
+}
+
+static inline struct file *unionfs_lower_file_idx(const struct file *f,
+						  int index)
+{
+	BUG_ON(!f || index < 0);
+	return UNIONFS_F(f)->lower_files[index];
+}
+
+static inline void unionfs_set_lower_file_idx(struct file *f, int index,
+					      struct file *val)
+{
+	BUG_ON(!f || index < 0);
+	UNIONFS_F(f)->lower_files[index] = val;
+	/* save branch ID (may be redundant?) */
+	UNIONFS_F(f)->saved_branch_ids[index] =
+		branch_id((f)->f_path.dentry->d_sb, index);
+}
+
+static inline void unionfs_set_lower_file(struct file *f, struct file *val)
+{
+	BUG_ON(!f);
+	unionfs_set_lower_file_idx((f), fbstart(f), (val));
+}
+
+/* Inode to lower inode. */
+static inline struct inode *unionfs_lower_inode(const struct inode *i)
+{
+	BUG_ON(!i);
+	return UNIONFS_I(i)->lower_inodes[ibstart(i)];
+}
+
+static inline struct inode *unionfs_lower_inode_idx(const struct inode *i,
+						    int index)
+{
+	BUG_ON(!i || index < 0);
+	return UNIONFS_I(i)->lower_inodes[index];
+}
+
+static inline void unionfs_set_lower_inode_idx(struct inode *i, int index,
+					       struct inode *val)
+{
+	BUG_ON(!i || index < 0);
+	UNIONFS_I(i)->lower_inodes[index] = val;
+}
+
+static inline void unionfs_set_lower_inode(struct inode *i, struct inode *val)
+{
+	BUG_ON(!i);
+	UNIONFS_I(i)->lower_inodes[ibstart(i)] = val;
+}
+
+/* Superblock to lower superblock. */
+static inline struct super_block *unionfs_lower_super(
+					const struct super_block *sb)
+{
+	BUG_ON(!sb);
+	return UNIONFS_SB(sb)->data[sbstart(sb)].sb;
+}
+
+static inline struct super_block *unionfs_lower_super_idx(
+					const struct super_block *sb,
+					int index)
+{
+	BUG_ON(!sb || index < 0);
+	return UNIONFS_SB(sb)->data[index].sb;
+}
+
+static inline void unionfs_set_lower_super_idx(struct super_block *sb,
+					       int index,
+					       struct super_block *val)
+{
+	BUG_ON(!sb || index < 0);
+	UNIONFS_SB(sb)->data[index].sb = val;
+}
+
+static inline void unionfs_set_lower_super(struct super_block *sb,
+					   struct super_block *val)
+{
+	BUG_ON(!sb);
+	UNIONFS_SB(sb)->data[sbstart(sb)].sb = val;
+}
+
+/* Branch count macros. */
+static inline int branch_count(const struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	return atomic_read(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+static inline void set_branch_count(struct super_block *sb, int index, int val)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_set(&UNIONFS_SB(sb)->data[index].open_files, val);
+}
+
+static inline void branchget(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_inc(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+static inline void branchput(struct super_block *sb, int index)
+{
+	BUG_ON(!sb || index < 0);
+	atomic_dec(&UNIONFS_SB(sb)->data[index].open_files);
+}
+
+/* Dentry macros */
+static inline void unionfs_set_lower_dentry_idx(struct dentry *dent, int index,
+						struct dentry *val)
+{
+	BUG_ON(!dent || index < 0);
+	UNIONFS_D(dent)->lower_paths[index].dentry = val;
+}
+
+static inline struct dentry *unionfs_lower_dentry_idx(
+				const struct dentry *dent,
+				int index)
+{
+	BUG_ON(!dent || index < 0);
+	return UNIONFS_D(dent)->lower_paths[index].dentry;
+}
+
+static inline struct dentry *unionfs_lower_dentry(const struct dentry *dent)
+{
+	BUG_ON(!dent);
+	return unionfs_lower_dentry_idx(dent, dbstart(dent));
+}
+
+static inline void unionfs_set_lower_mnt_idx(struct dentry *dent, int index,
+					     struct vfsmount *mnt)
+{
+	BUG_ON(!dent || index < 0);
+	UNIONFS_D(dent)->lower_paths[index].mnt = mnt;
+}
+
+static inline struct vfsmount *unionfs_lower_mnt_idx(
+					const struct dentry *dent,
+					int index)
+{
+	BUG_ON(!dent || index < 0);
+	return UNIONFS_D(dent)->lower_paths[index].mnt;
+}
+
+static inline struct vfsmount *unionfs_lower_mnt(const struct dentry *dent)
+{
+	BUG_ON(!dent);
+	return unionfs_lower_mnt_idx(dent, dbstart(dent));
+}
+
+/* Macros for locking a dentry. */
+enum unionfs_dentry_lock_class {
+	UNIONFS_DMUTEX_NORMAL,
+	UNIONFS_DMUTEX_ROOT,
+	UNIONFS_DMUTEX_PARENT,
+	UNIONFS_DMUTEX_CHILD,
+	UNIONFS_DMUTEX_WHITEOUT,
+	UNIONFS_DMUTEX_REVAL_PARENT, /* for file/dentry revalidate */
+	UNIONFS_DMUTEX_REVAL_CHILD,   /* for file/dentry revalidate */
+};
+
+static inline void unionfs_lock_dentry(struct dentry *d,
+				       unsigned int subclass)
+{
+	BUG_ON(!d);
+	mutex_lock_nested(&UNIONFS_D(d)->lock, subclass);
+}
+
+static inline void unionfs_unlock_dentry(struct dentry *d)
+{
+	BUG_ON(!d);
+	mutex_unlock(&UNIONFS_D(d)->lock);
+}
+
+static inline struct dentry *unionfs_lock_parent(struct dentry *d,
+						 unsigned int subclass)
+{
+	struct dentry *p;
+
+	BUG_ON(!d);
+	p = dget_parent(d);
+	if (p != d)
+		mutex_lock_nested(&UNIONFS_D(p)->lock, subclass);
+	return p;
+}
+
+static inline void unionfs_unlock_parent(struct dentry *d, struct dentry *p)
+{
+	BUG_ON(!d);
+	BUG_ON(!p);
+	if (p != d) {
+		BUG_ON(!mutex_is_locked(&UNIONFS_D(p)->lock));
+		mutex_unlock(&UNIONFS_D(p)->lock);
+	}
+	dput(p);
+}
+
+static inline void verify_locked(struct dentry *d)
+{
+	BUG_ON(!d);
+	BUG_ON(!mutex_is_locked(&UNIONFS_D(d)->lock));
+}
+
+/* macros to put lower objects */
+
+/*
+ * iput lower inodes of an unionfs dentry, from bstart to bend.  If
+ * @free_lower is true, then also kfree the memory used to hold the lower
+ * object pointers.
+ */
+static inline void iput_lowers(struct inode *inode,
+			       int bstart, int bend, bool free_lower)
+{
+	struct inode *lower_inode;
+	int bindex;
+
+	BUG_ON(!inode);
+	BUG_ON(!UNIONFS_I(inode));
+	BUG_ON(bstart < 0);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (lower_inode) {
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			iput(lower_inode);
+			lockdep_on();
+		}
+	}
+
+	if (free_lower) {
+		kfree(UNIONFS_I(inode)->lower_inodes);
+		UNIONFS_I(inode)->lower_inodes = NULL;
+	}
+}
+
+/* iput all lower inodes, and reset start/end branch indices to -1 */
+static inline void iput_lowers_all(struct inode *inode, bool free_lower)
+{
+	int bstart, bend;
+
+	BUG_ON(!inode);
+	BUG_ON(!UNIONFS_I(inode));
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	BUG_ON(bstart < 0);
+
+	iput_lowers(inode, bstart, bend, free_lower);
+	ibstart(inode) = ibend(inode) = -1;
+}
+
+/*
+ * dput/mntput all lower dentries and vfsmounts of an unionfs dentry, from
+ * bstart to bend.  If @free_lower is true, then also kfree the memory used
+ * to hold the lower object pointers.
+ *
+ * XXX: implement using path_put VFS macros
+ */
+static inline void path_put_lowers(struct dentry *dentry,
+				   int bstart, int bend, bool free_lower)
+{
+	struct dentry *lower_dentry;
+	struct vfsmount *lower_mnt;
+	int bindex;
+
+	BUG_ON(!dentry);
+	BUG_ON(!UNIONFS_D(dentry));
+	BUG_ON(bstart < 0);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (lower_dentry) {
+			unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+			dput(lower_dentry);
+		}
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+		if (lower_mnt) {
+			unionfs_set_lower_mnt_idx(dentry, bindex, NULL);
+			mntput(lower_mnt);
+		}
+	}
+
+	if (free_lower) {
+		kfree(UNIONFS_D(dentry)->lower_paths);
+		UNIONFS_D(dentry)->lower_paths = NULL;
+	}
+}
+
+/*
+ * dput/mntput all lower dentries and vfsmounts, and reset start/end branch
+ * indices to -1.
+ */
+static inline void path_put_lowers_all(struct dentry *dentry, bool free_lower)
+{
+	int bstart, bend;
+
+	BUG_ON(!dentry);
+	BUG_ON(!UNIONFS_D(dentry));
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart < 0);
+
+	path_put_lowers(dentry, bstart, bend, free_lower);
+	dbstart(dentry) = dbend(dentry) = -1;
+}
+
+#endif	/* not _FANOUT_H */
diff --git a/fs/unionfs/file.c b/fs/unionfs/file.c
new file mode 100644
index 0000000..46eaa90
--- /dev/null
+++ b/fs/unionfs/file.c
@@ -0,0 +1,380 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+static ssize_t unionfs_read(struct file *file, char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	int err;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, false);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_read(lower_file, buf, count, ppos);
+	/* update our inode atime upon a successful lower read */
+	if (err >= 0) {
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_write(struct file *file, const char __user *buf,
+			     size_t count, loff_t *ppos)
+{
+	int err = 0;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, true);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_write(lower_file, buf, count, ppos);
+	/* update our inode times+sizes upon a successful lower write */
+	if (err >= 0) {
+		fsstack_copy_inode_size(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		fsstack_copy_attr_times(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		UNIONFS_F(file)->wrote_to_file = true; /* for delayed copyup */
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_file_readdir(struct file *file, void *dirent,
+				filldir_t filldir)
+{
+	return -ENOTDIR;
+}
+
+static int unionfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err = 0;
+	bool willwrite;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	const struct vm_operations_struct *saved_vm_ops = NULL;
+
+	/*
+	 * Since mm/memory.c:might_fault() (under PROVE_LOCKING) was
+	 * modified in 2.6.29-rc1 to call might_lock_read on mmap_sem, this
+	 * has been causing false positives in file system stacking layers.
+	 * In particular, our ->mmap is called after sys_mmap2 already holds
+	 * mmap_sem, then we lock our own mutexes; but earlier, it's
+	 * possible for lockdep to have locked our mutexes first, and then
+	 * we call a lower ->readdir which could call might_fault.  The
+	 * different ordering of the locks is what lockdep complains about
+	 * -- unnecessarily.  Therefore, we have no choice but to tell
+	 * lockdep to temporarily turn off lockdep here.  Note: the comments
+	 * inside might_sleep also suggest that it would have been
+	 * nicer to only annotate paths that needs that might_lock_read.
+	 */
+	lockdep_off();
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/* This might be deferred to mmap's writepage */
+	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);
+	err = unionfs_file_revalidate(file, parent, willwrite);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	/*
+	 * File systems which do not implement ->writepage may use
+	 * generic_file_readonly_mmap as their ->mmap op.  If you call
+	 * generic_file_readonly_mmap with VM_WRITE, you'd get an -EINVAL.
+	 * But we cannot call the lower ->mmap op, so we can't tell that
+	 * writeable mappings won't work.  Therefore, our only choice is to
+	 * check if the lower file system supports the ->writepage, and if
+	 * not, return EINVAL (the same error that
+	 * generic_file_readonly_mmap returns in that case).
+	 */
+	lower_file = unionfs_lower_file(file);
+	if (willwrite && !lower_file->f_mapping->a_ops->writepage) {
+		err = -EINVAL;
+		printk(KERN_ERR "unionfs: branch %d file system does not "
+		       "support writeable mmap\n", fbstart(file));
+		goto out;
+	}
+
+	/*
+	 * find and save lower vm_ops.
+	 *
+	 * XXX: the VFS should have a cleaner way of finding the lower vm_ops
+	 */
+	if (!UNIONFS_F(file)->lower_vm_ops) {
+		err = lower_file->f_op->mmap(lower_file, vma);
+		if (err) {
+			printk(KERN_ERR "unionfs: lower mmap failed %d\n", err);
+			goto out;
+		}
+		saved_vm_ops = vma->vm_ops;
+		err = do_munmap(current->mm, vma->vm_start,
+				vma->vm_end - vma->vm_start);
+		if (err) {
+			printk(KERN_ERR "unionfs: do_munmap failed %d\n", err);
+			goto out;
+		}
+	}
+
+	file->f_mapping->a_ops = &unionfs_dummy_aops;
+	err = generic_file_mmap(file, vma);
+	file->f_mapping->a_ops = &unionfs_aops;
+	if (err) {
+		printk(KERN_ERR "unionfs: generic_file_mmap failed %d\n", err);
+		goto out;
+	}
+	vma->vm_ops = &unionfs_vm_ops;
+	if (!UNIONFS_F(file)->lower_vm_ops)
+		UNIONFS_F(file)->lower_vm_ops = saved_vm_ops;
+
+out:
+	if (!err) {
+		/* copyup could cause parent dir times to change */
+		unionfs_copy_attr_times(parent->d_inode);
+		unionfs_check_file(file);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	lockdep_on();
+	return err;
+}
+
+int unionfs_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	int bindex, bstart, bend;
+	struct file *lower_file;
+	struct dentry *lower_dentry;
+	struct dentry *parent;
+	struct inode *lower_inode, *inode;
+	int err = -EINVAL;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, true);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	if (bstart < 0 || bend < 0)
+		goto out;
+
+	inode = dentry->d_inode;
+	if (unlikely(!inode)) {
+		printk(KERN_ERR
+		       "unionfs: null lower inode in unionfs_fsync\n");
+		goto out;
+	}
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode || !lower_inode->i_fop->fsync)
+			continue;
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		mutex_lock(&lower_inode->i_mutex);
+		err = lower_inode->i_fop->fsync(lower_file,
+						lower_dentry,
+						datasync);
+		if (!err && bindex == bstart)
+			fsstack_copy_attr_times(inode, lower_inode);
+		mutex_unlock(&lower_inode->i_mutex);
+		if (err)
+			goto out;
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+int unionfs_fasync(int fd, struct file *file, int flag)
+{
+	int bindex, bstart, bend;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+	struct inode *lower_inode, *inode;
+	int err = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, true);
+	if (unlikely(err))
+		goto out;
+	unionfs_check_file(file);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	if (bstart < 0 || bend < 0)
+		goto out;
+
+	inode = dentry->d_inode;
+	if (unlikely(!inode)) {
+		printk(KERN_ERR
+		       "unionfs: null lower inode in unionfs_fasync\n");
+		goto out;
+	}
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode || !lower_inode->i_fop->fasync)
+			continue;
+		lower_file = unionfs_lower_file_idx(file, bindex);
+		mutex_lock(&lower_inode->i_mutex);
+		err = lower_inode->i_fop->fasync(fd, lower_file, flag);
+		if (!err && bindex == bstart)
+			fsstack_copy_attr_times(inode, lower_inode);
+		mutex_unlock(&lower_inode->i_mutex);
+		if (err)
+			goto out;
+	}
+
+out:
+	if (!err)
+		unionfs_check_file(file);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_splice_read(struct file *file, loff_t *ppos,
+				   struct pipe_inode_info *pipe, size_t len,
+				   unsigned int flags)
+{
+	ssize_t err;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, false);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_splice_to(lower_file, ppos, pipe, len, flags);
+	/* update our inode atime upon a successful lower splice-read */
+	if (err >= 0) {
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static ssize_t unionfs_splice_write(struct pipe_inode_info *pipe,
+				    struct file *file, loff_t *ppos,
+				    size_t len, unsigned int flags)
+{
+	ssize_t err = 0;
+	struct file *lower_file;
+	struct dentry *dentry = file->f_path.dentry;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	err = unionfs_file_revalidate(file, parent, true);
+	if (unlikely(err))
+		goto out;
+
+	lower_file = unionfs_lower_file(file);
+	err = vfs_splice_from(pipe, lower_file, ppos, len, flags);
+	/* update our inode times+sizes upon a successful lower write */
+	if (err >= 0) {
+		fsstack_copy_inode_size(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		fsstack_copy_attr_times(dentry->d_inode,
+					lower_file->f_path.dentry->d_inode);
+		unionfs_check_file(file);
+	}
+
+out:
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+struct file_operations unionfs_main_fops = {
+	.llseek		= generic_file_llseek,
+	.read		= unionfs_read,
+	.write		= unionfs_write,
+	.readdir	= unionfs_file_readdir,
+	.unlocked_ioctl	= unionfs_ioctl,
+	.mmap		= unionfs_mmap,
+	.open		= unionfs_open,
+	.flush		= unionfs_flush,
+	.release	= unionfs_file_release,
+	.fsync		= unionfs_fsync,
+	.fasync		= unionfs_fasync,
+	.splice_read	= unionfs_splice_read,
+	.splice_write	= unionfs_splice_write,
+};
diff --git a/fs/unionfs/inode.c b/fs/unionfs/inode.c
new file mode 100644
index 0000000..062163a
--- /dev/null
+++ b/fs/unionfs/inode.c
@@ -0,0 +1,1055 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Find a writeable branch to create new object in.  Checks all writeble
+ * branches of the parent inode, from istart to iend order; if none are
+ * suitable, also tries branch 0 (which may require a copyup).
+ *
+ * Return a lower_dentry we can use to create object in, or ERR_PTR.
+ */
+static struct dentry *find_writeable_branch(struct inode *parent,
+					    struct dentry *dentry)
+{
+	int err = -EINVAL;
+	int bindex, istart, iend;
+	struct dentry *lower_dentry = NULL;
+
+	istart = ibstart(parent);
+	iend = ibend(parent);
+	if (istart < 0)
+		goto out;
+
+begin:
+	for (bindex = istart; bindex <= iend; bindex++) {
+		/* skip non-writeable branches */
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (err) {
+			err = -EROFS;
+			continue;
+		}
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		/*
+		 * check for whiteouts in writeable branch, and remove them
+		 * if necessary.
+		 */
+		err = check_unlink_whiteout(dentry, lower_dentry, bindex);
+		if (err > 0)	/* ignore if whiteout found and removed */
+			err = 0;
+		if (err)
+			continue;
+		/* if get here, we can write to the branch */
+		break;
+	}
+	/*
+	 * If istart wasn't already branch 0, and we got any error, then try
+	 * branch 0 (which may require copyup)
+	 */
+	if (err && istart > 0) {
+		istart = iend = 0;
+		goto begin;
+	}
+
+	/*
+	 * If we tried even branch 0, and still got an error, abort.  But if
+	 * the error was an EROFS, then we should try to copyup.
+	 */
+	if (err && err != -EROFS)
+		goto out;
+
+	/*
+	 * If we get here, then check if copyup needed.  If lower_dentry is
+	 * NULL, create the entire dentry directory structure in branch 0.
+	 */
+	if (!lower_dentry) {
+		bindex = 0;
+		lower_dentry = create_parents(parent, dentry,
+					      dentry->d_name.name, bindex);
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out;
+		}
+	}
+	err = 0;		/* all's well */
+out:
+	if (err)
+		return ERR_PTR(err);
+	return lower_dentry;
+}
+
+static int unionfs_create(struct inode *dir, struct dentry *dentry,
+			  int mode, struct nameidata *nd_unused)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *parent;
+	int valid = 0;
+	struct nameidata lower_nd;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;	/* same as what real_lookup does */
+		goto out;
+	}
+
+	lower_dentry = find_writeable_branch(dir, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out_unlock;
+	}
+
+	err = init_lower_nd(&lower_nd, LOOKUP_CREATE);
+	if (unlikely(err < 0))
+		goto out_unlock;
+	err = vfs_create(lower_parent_dentry->d_inode, lower_dentry, mode,
+			 &lower_nd);
+	release_lower_nd(&lower_nd, err);
+
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(dir);
+			fsstack_copy_inode_size(dir,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			dir->i_nlink = unionfs_get_nlinks(dir);
+		}
+	}
+
+out_unlock:
+	unlock_dir(lower_parent_dentry);
+out:
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(dir);
+		unionfs_check_dentry(dentry);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * unionfs_lookup is the only special function which takes a dentry, yet we
+ * do NOT want to call __unionfs_d_revalidate_chain because by definition,
+ * we don't have a valid dentry here yet.
+ */
+static struct dentry *unionfs_lookup(struct inode *dir,
+				     struct dentry *dentry,
+				     struct nameidata *nd_unused)
+{
+	struct dentry *ret, *parent;
+	int err = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+
+	/*
+	 * As long as we lock/dget the parent, then can skip validating the
+	 * parent now; we may have to rebuild this dentry on the next
+	 * ->d_revalidate, however.
+	 */
+
+	/* allocate dentry private data.  We free it in ->d_release */
+	err = new_dentry_private_data(dentry, UNIONFS_DMUTEX_CHILD);
+	if (unlikely(err)) {
+		ret = ERR_PTR(err);
+		goto out;
+	}
+
+	ret = unionfs_lookup_full(dentry, parent, INTERPOSE_LOOKUP);
+
+	if (!IS_ERR(ret)) {
+		if (ret)
+			dentry = ret;
+		/* lookup_full can return multiple positive dentries */
+		if (dentry->d_inode && !S_ISDIR(dentry->d_inode->i_mode)) {
+			BUG_ON(dbstart(dentry) < 0);
+			unionfs_postcopyup_release(dentry);
+		}
+		unionfs_copy_attr_times(dentry->d_inode);
+	}
+
+	unionfs_check_inode(dir);
+	if (!IS_ERR(ret))
+		unionfs_check_dentry(dentry);
+	unionfs_check_dentry(parent);
+	unionfs_unlock_dentry(dentry); /* locked in new_dentry_private data */
+
+out:
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return ret;
+}
+
+static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *lower_old_dentry = NULL;
+	struct dentry *lower_new_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *old_parent, *new_parent;
+	char *name = NULL;
+	bool valid;
+
+	unionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	old_parent = dget_parent(old_dentry);
+	new_parent = dget_parent(new_dentry);
+	unionfs_double_lock_parents(old_parent, new_parent);
+	unionfs_double_lock_dentry(old_dentry, new_dentry);
+
+	valid = __unionfs_d_revalidate(old_dentry, old_parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (new_dentry->d_inode) {
+		valid = __unionfs_d_revalidate(new_dentry, new_parent, false);
+		if (unlikely(!valid)) {
+			err = -ESTALE;
+			goto out;
+		}
+	}
+
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
+
+	/* check for a whiteout in new dentry branch, and delete it */
+	err = check_unlink_whiteout(new_dentry, lower_new_dentry,
+				    dbstart(new_dentry));
+	if (err > 0) {	       /* whiteout found and removed successfully */
+		lower_dir_dentry = dget_parent(lower_new_dentry);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+		dput(lower_dir_dentry);
+		dir->i_nlink = unionfs_get_nlinks(dir);
+		err = 0;
+	}
+	if (err)
+		goto out;
+
+	/* check if parent hierachy is needed, then link in same branch */
+	if (dbstart(old_dentry) != dbstart(new_dentry)) {
+		lower_new_dentry = create_parents(dir, new_dentry,
+						  new_dentry->d_name.name,
+						  dbstart(old_dentry));
+		err = PTR_ERR(lower_new_dentry);
+		if (IS_COPYUP_ERR(err))
+			goto docopyup;
+		if (!lower_new_dentry || IS_ERR(lower_new_dentry))
+			goto out;
+	}
+	lower_new_dentry = unionfs_lower_dentry(new_dentry);
+	lower_old_dentry = unionfs_lower_dentry(old_dentry);
+
+	BUG_ON(dbstart(old_dentry) != dbstart(new_dentry));
+	lower_dir_dentry = lock_parent(lower_new_dentry);
+	err = is_robranch(old_dentry);
+	if (!err) {
+		/* see Documentation/filesystems/unionfs/issues.txt */
+		lockdep_off();
+		err = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,
+			       lower_new_dentry);
+		lockdep_on();
+	}
+	unlock_dir(lower_dir_dentry);
+
+docopyup:
+	if (IS_COPYUP_ERR(err)) {
+		int old_bstart = dbstart(old_dentry);
+		int bindex;
+
+		for (bindex = old_bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_dentry(old_parent->d_inode,
+					    old_dentry, old_bstart,
+					    bindex, old_dentry->d_name.name,
+					    old_dentry->d_name.len, NULL,
+					    i_size_read(old_dentry->d_inode));
+			if (err)
+				continue;
+			lower_new_dentry =
+				create_parents(dir, new_dentry,
+					       new_dentry->d_name.name,
+					       bindex);
+			lower_old_dentry = unionfs_lower_dentry(old_dentry);
+			lower_dir_dentry = lock_parent(lower_new_dentry);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			/* do vfs_link */
+			err = vfs_link(lower_old_dentry,
+				       lower_dir_dentry->d_inode,
+				       lower_new_dentry);
+			lockdep_on();
+			unlock_dir(lower_dir_dentry);
+			goto check_link;
+		}
+		goto out;
+	}
+
+check_link:
+	if (err || !lower_new_dentry->d_inode)
+		goto out;
+
+	/* Its a hard link, so use the same inode */
+	new_dentry->d_inode = igrab(old_dentry->d_inode);
+	d_add(new_dentry, new_dentry->d_inode);
+	unionfs_copy_attr_all(dir, lower_new_dentry->d_parent->d_inode);
+	fsstack_copy_inode_size(dir, lower_new_dentry->d_parent->d_inode);
+
+	/* propagate number of hard-links */
+	old_dentry->d_inode->i_nlink = unionfs_get_nlinks(old_dentry->d_inode);
+	/* new dentry's ctime may have changed due to hard-link counts */
+	unionfs_copy_attr_times(new_dentry->d_inode);
+
+out:
+	if (!new_dentry->d_inode)
+		d_drop(new_dentry);
+
+	kfree(name);
+	if (!err)
+		unionfs_postcopyup_setmnt(new_dentry);
+
+	unionfs_check_inode(dir);
+	unionfs_check_dentry(new_dentry);
+	unionfs_check_dentry(old_dentry);
+
+	unionfs_double_unlock_dentry(old_dentry, new_dentry);
+	unionfs_double_unlock_parents(old_parent, new_parent);
+	dput(new_parent);
+	dput(old_parent);
+	unionfs_read_unlock(old_dentry->d_sb);
+
+	return err;
+}
+
+static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *parent;
+	char *name = NULL;
+	int valid = 0;
+	umode_t mode;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	/*
+	 * It's only a bug if this dentry was not negative and couldn't be
+	 * revalidated (shouldn't happen).
+	 */
+	BUG_ON(!valid && dentry->d_inode);
+
+	lower_dentry = find_writeable_branch(dir, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out_unlock;
+	}
+
+	mode = S_IALLUGO;
+	err = vfs_symlink(lower_parent_dentry->d_inode, lower_dentry, symname);
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(dir);
+			fsstack_copy_inode_size(dir,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			dir->i_nlink = unionfs_get_nlinks(dir);
+		}
+	}
+
+out_unlock:
+	unlock_dir(lower_parent_dentry);
+out:
+	dput(wh_dentry);
+	kfree(name);
+
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(dir);
+		unionfs_check_dentry(dentry);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *parent;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;	/* same as what real_lookup does */
+		goto out;
+	}
+
+	bstart = dbstart(dentry);
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	/* check for a whiteout in new dentry branch, and delete it */
+	err = check_unlink_whiteout(dentry, lower_dentry, bstart);
+	if (err > 0)	       /* whiteout found and removed successfully */
+		err = 0;
+	if (err) {
+		/* exit if the error returned was NOT -EROFS */
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+		bstart--;
+	}
+
+	/* check if copyup's needed, and mkdir */
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		int i;
+		int bend = dbend(dentry);
+
+		if (is_robranch_super(dentry->d_sb, bindex))
+			continue;
+
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			lower_dentry = create_parents(dir, dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				printk(KERN_ERR "unionfs: lower dentry "
+				       " NULL for bindex = %d\n", bindex);
+				continue;
+			}
+		}
+
+		lower_parent_dentry = lock_parent(lower_dentry);
+
+		if (IS_ERR(lower_parent_dentry)) {
+			err = PTR_ERR(lower_parent_dentry);
+			goto out;
+		}
+
+		err = vfs_mkdir(lower_parent_dentry->d_inode, lower_dentry,
+				mode);
+
+		unlock_dir(lower_parent_dentry);
+
+		/* did the mkdir succeed? */
+		if (err)
+			break;
+
+		for (i = bindex + 1; i <= bend; i++) {
+			/* XXX: use path_put_lowers? */
+			if (unionfs_lower_dentry_idx(dentry, i)) {
+				dput(unionfs_lower_dentry_idx(dentry, i));
+				unionfs_set_lower_dentry_idx(dentry, i, NULL);
+			}
+		}
+		dbend(dentry) = bindex;
+
+		/*
+		 * Only INTERPOSE_LOOKUP can return a value other than 0 on
+		 * err.
+		 */
+		err = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(dir);
+			fsstack_copy_inode_size(dir,
+						lower_parent_dentry->d_inode);
+
+			/* update number of links on parent directory */
+			dir->i_nlink = unionfs_get_nlinks(dir);
+		}
+
+		err = make_dir_opaque(dentry, dbstart(dentry));
+		if (err) {
+			printk(KERN_ERR "unionfs: mkdir: error creating "
+			       ".wh.__dir_opaque: %d\n", err);
+			goto out;
+		}
+
+		/* we are done! */
+		break;
+	}
+
+out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	kfree(name);
+
+	if (!err) {
+		unionfs_copy_attr_times(dentry->d_inode);
+		unionfs_postcopyup_setmnt(dentry);
+	}
+	unionfs_check_inode(dir);
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			 dev_t dev)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_parent_dentry = NULL;
+	struct dentry *parent;
+	char *name = NULL;
+	int valid = 0;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	/*
+	 * It's only a bug if this dentry was not negative and couldn't be
+	 * revalidated (shouldn't happen).
+	 */
+	BUG_ON(!valid && dentry->d_inode);
+
+	lower_dentry = find_writeable_branch(dir, dentry);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	lower_parent_dentry = lock_parent(lower_dentry);
+	if (IS_ERR(lower_parent_dentry)) {
+		err = PTR_ERR(lower_parent_dentry);
+		goto out_unlock;
+	}
+
+	err = vfs_mknod(lower_parent_dentry->d_inode, lower_dentry, mode, dev);
+	if (!err) {
+		err = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));
+		if (!err) {
+			unionfs_copy_attr_times(dir);
+			fsstack_copy_inode_size(dir,
+						lower_parent_dentry->d_inode);
+			/* update no. of links on parent directory */
+			dir->i_nlink = unionfs_get_nlinks(dir);
+		}
+	}
+
+out_unlock:
+	unlock_dir(lower_parent_dentry);
+out:
+	dput(wh_dentry);
+	kfree(name);
+
+	if (!err) {
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_inode(dir);
+		unionfs_check_dentry(dentry);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/* requires sb, dentry, and parent to already be locked */
+static int __unionfs_readlink(struct dentry *dentry, char __user *buf,
+			      int bufsiz)
+{
+	int err;
+	struct dentry *lower_dentry;
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	if (!lower_dentry->d_inode->i_op ||
+	    !lower_dentry->d_inode->i_op->readlink) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = lower_dentry->d_inode->i_op->readlink(lower_dentry,
+						    buf, bufsiz);
+	if (err >= 0)
+		fsstack_copy_attr_atime(dentry->d_inode,
+					lower_dentry->d_inode);
+
+out:
+	return err;
+}
+
+static int unionfs_readlink(struct dentry *dentry, char __user *buf,
+			    int bufsiz)
+{
+	int err;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate(dentry, parent, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	err = __unionfs_readlink(dentry, buf, bufsiz);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+static void *unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	char *buf;
+	int len = PAGE_SIZE, err;
+	mm_segment_t old_fs;
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	/* This is freed by the put_link method assuming a successful call. */
+	buf = kmalloc(len, GFP_KERNEL);
+	if (unlikely(!buf)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* read the symlink, and then we will follow it */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = __unionfs_readlink(dentry, buf, len);
+	set_fs(old_fs);
+	if (err < 0) {
+		kfree(buf);
+		buf = NULL;
+		goto out;
+	}
+	buf[err] = 0;
+	nd_set_link(nd, buf);
+	err = 0;
+
+out:
+	if (err >= 0) {
+		unionfs_check_nd(nd);
+		unionfs_check_dentry(dentry);
+	}
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return ERR_PTR(err);
+}
+
+/* this @nd *IS* still used */
+static void unionfs_put_link(struct dentry *dentry, struct nameidata *nd,
+			     void *cookie)
+{
+	struct dentry *parent;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate(dentry, parent, false)))
+		printk(KERN_ERR
+		       "unionfs: put_link failed to revalidate dentry\n");
+
+	unionfs_check_dentry(dentry);
+	unionfs_check_nd(nd);
+	kfree(nd_get_link(nd));
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+}
+
+/*
+ * This is a variant of fs/namei.c:permission() or inode_permission() which
+ * skips over EROFS tests (because we perform copyup on EROFS).
+ */
+static int __inode_permission(struct inode *inode, int mask)
+{
+	int retval;
+
+	/* nobody gets write access to an immutable file */
+	if ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))
+		return -EACCES;
+
+	/* Ordinary permission routines do not understand MAY_APPEND. */
+	if (inode->i_op && inode->i_op->permission) {
+		retval = inode->i_op->permission(inode, mask);
+		if (!retval) {
+			/*
+			 * Exec permission on a regular file is denied if none
+			 * of the execute bits are set.
+			 *
+			 * This check should be done by the ->permission()
+			 * method.
+			 */
+			if ((mask & MAY_EXEC) && S_ISREG(inode->i_mode) &&
+			    !(inode->i_mode & S_IXUGO))
+				return -EACCES;
+		}
+	} else {
+		retval = generic_permission(inode, mask, NULL);
+	}
+	if (retval)
+		return retval;
+
+	return security_inode_permission(inode,
+			mask & (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND));
+}
+
+/*
+ * Don't grab the superblock read-lock in unionfs_permission, which prevents
+ * a deadlock with the branch-management "add branch" code (which grabbed
+ * the write lock).  It is safe to not grab the read lock here, because even
+ * with branch management taking place, there is no chance that
+ * unionfs_permission, or anything it calls, will use stale branch
+ * information.
+ */
+static int unionfs_permission(struct inode *inode, int mask)
+{
+	struct inode *lower_inode = NULL;
+	int err = 0;
+	int bindex, bstart, bend;
+	const int is_file = !S_ISDIR(inode->i_mode);
+	const int write_mask = (mask & MAY_WRITE) && !(mask & MAY_READ);
+	struct inode *inode_grabbed = igrab(inode);
+	struct dentry *dentry = d_find_alias(inode);
+
+	if (dentry)
+		unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (!UNIONFS_I(inode)->lower_inodes) {
+		if (is_file)	/* dirs can be unlinked but chdir'ed to */
+			err = -ESTALE;	/* force revalidate */
+		goto out;
+	}
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (unlikely(bstart < 0 || bend < 0)) {
+		/*
+		 * With branch-management, we can get a stale inode here.
+		 * If so, we return ESTALE back to link_path_walk, which
+		 * would discard the dcache entry and re-lookup the
+		 * dentry+inode.  This should be equivalent to issuing
+		 * __unionfs_d_revalidate_chain on nd.dentry here.
+		 */
+		if (is_file)	/* dirs can be unlinked but chdir'ed to */
+			err = -ESTALE;	/* force revalidate */
+		goto out;
+	}
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		/*
+		 * check the condition for D-F-D underlying files/directories,
+		 * we don't have to check for files, if we are checking for
+		 * directories.
+		 */
+		if (!is_file && !S_ISDIR(lower_inode->i_mode))
+			continue;
+
+		/*
+		 * We check basic permissions, but we ignore any conditions
+		 * such as readonly file systems or branches marked as
+		 * readonly, because those conditions should lead to a
+		 * copyup taking place later on.  However, if user never had
+		 * access to the file, then no copyup could ever take place.
+		 */
+		err = __inode_permission(lower_inode, mask);
+		if (err && err != -EACCES && err != EPERM && bindex > 0) {
+			umode_t mode = lower_inode->i_mode;
+			if ((is_robranch_super(inode->i_sb, bindex) ||
+			     __is_rdonly(lower_inode)) &&
+			    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))
+				err = 0;
+			if (IS_COPYUP_ERR(err))
+				err = 0;
+		}
+
+		/*
+		 * NFS HACK: NFSv2/3 return EACCES on readonly-exported,
+		 * locally readonly-mounted file systems, instead of EROFS
+		 * like other file systems do.  So we have no choice here
+		 * but to intercept this and ignore it for NFS branches
+		 * marked readonly.  Specifically, we avoid using NFS's own
+		 * "broken" ->permission method, and rely on
+		 * generic_permission() to do basic checking for us.
+		 */
+		if (err && err == -EACCES &&
+		    is_robranch_super(inode->i_sb, bindex) &&
+		    lower_inode->i_sb->s_magic == NFS_SUPER_MAGIC)
+			err = generic_permission(lower_inode, mask, NULL);
+
+		/*
+		 * The permissions are an intersection of the overall directory
+		 * permissions, so we fail if one fails.
+		 */
+		if (err)
+			goto out;
+
+		/* only the leftmost file matters. */
+		if (is_file || write_mask) {
+			if (is_file && write_mask) {
+				err = get_write_access(lower_inode);
+				if (!err)
+					put_write_access(lower_inode);
+			}
+			break;
+		}
+	}
+	/* sync times which may have changed (asynchronously) below */
+	unionfs_copy_attr_times(inode);
+
+out:
+	unionfs_check_inode(inode);
+	if (dentry) {
+		unionfs_unlock_dentry(dentry);
+		dput(dentry);
+	}
+	iput(inode_grabbed);
+	return err;
+}
+
+static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int err = 0;
+	struct dentry *lower_dentry;
+	struct dentry *parent;
+	struct inode *inode;
+	struct inode *lower_inode;
+	int bstart, bend, bindex;
+	loff_t size;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	if (unlikely(!__unionfs_d_revalidate(dentry, parent, false))) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	inode = dentry->d_inode;
+
+	/*
+	 * mode change is for clearing setuid/setgid. Allow lower filesystem
+	 * to reinterpret it in its own way.
+	 */
+	if (ia->ia_valid & (ATTR_KILL_SUID | ATTR_KILL_SGID))
+		ia->ia_valid &= ~ATTR_MODE;
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+	if (!lower_dentry) { /* should never happen after above revalidate */
+		err = -EINVAL;
+		goto out;
+	}
+	lower_inode = unionfs_lower_inode(inode);
+
+	/* check if user has permission to change lower inode */
+	err = inode_change_ok(lower_inode, ia);
+	if (err)
+		goto out;
+
+	/* copyup if the file is on a read only branch */
+	if (is_robranch_super(dentry->d_sb, bstart)
+	    || __is_rdonly(lower_inode)) {
+		/* check if we have a branch to copy up to */
+		if (bstart <= 0) {
+			err = -EACCES;
+			goto out;
+		}
+
+		if (ia->ia_valid & ATTR_SIZE)
+			size = ia->ia_size;
+		else
+			size = i_size_read(inode);
+		/* copyup to next available branch */
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			err = copyup_dentry(parent->d_inode,
+					    dentry, bstart, bindex,
+					    dentry->d_name.name,
+					    dentry->d_name.len,
+					    NULL, size);
+			if (!err)
+				break;
+		}
+		if (err)
+			goto out;
+		/* get updated lower_dentry/inode after copyup */
+		lower_dentry = unionfs_lower_dentry(dentry);
+		lower_inode = unionfs_lower_inode(inode);
+	}
+
+	/*
+	 * If shrinking, first truncate upper level to cancel writing dirty
+	 * pages beyond the new eof; and also if its' maxbytes is more
+	 * limiting (fail with -EFBIG before making any change to the lower
+	 * level).  There is no need to vmtruncate the upper level
+	 * afterwards in the other cases: we fsstack_copy_inode_size from
+	 * the lower level.
+	 */
+	if (ia->ia_valid & ATTR_SIZE) {
+		size = i_size_read(inode);
+		if (ia->ia_size < size || (ia->ia_size > size &&
+		    inode->i_sb->s_maxbytes < lower_inode->i_sb->s_maxbytes)) {
+			err = vmtruncate(inode, ia->ia_size);
+			if (err)
+				goto out;
+		}
+	}
+
+	/* notify the (possibly copied-up) lower inode */
+	/*
+	 * Note: we use lower_dentry->d_inode, because lower_inode may be
+	 * unlinked (no inode->i_sb and i_ino==0.  This happens if someone
+	 * tries to open(), unlink(), then ftruncate() a file.
+	 */
+	mutex_lock(&lower_dentry->d_inode->i_mutex);
+	err = notify_change(lower_dentry, ia);
+	mutex_unlock(&lower_dentry->d_inode->i_mutex);
+	if (err)
+		goto out;
+
+	/* get attributes from the first lower inode */
+	if (ibstart(inode) >= 0)
+		unionfs_copy_attr_all(inode, lower_inode);
+	/*
+	 * unionfs_copy_attr_all will copy the lower times to our inode if
+	 * the lower ones are newer (useful for cache coherency).  However,
+	 * ->setattr is the only place in which we may have to copy the
+	 * lower inode times absolutely, to support utimes(2).
+	 */
+	if (ia->ia_valid & ATTR_MTIME_SET)
+		inode->i_mtime = lower_inode->i_mtime;
+	if (ia->ia_valid & ATTR_CTIME)
+		inode->i_ctime = lower_inode->i_ctime;
+	if (ia->ia_valid & ATTR_ATIME_SET)
+		inode->i_atime = lower_inode->i_atime;
+	fsstack_copy_inode_size(inode, lower_inode);
+
+out:
+	if (!err)
+		unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+
+	return err;
+}
+
+struct inode_operations unionfs_symlink_iops = {
+	.readlink	= unionfs_readlink,
+	.permission	= unionfs_permission,
+	.follow_link	= unionfs_follow_link,
+	.setattr	= unionfs_setattr,
+	.put_link	= unionfs_put_link,
+};
+
+struct inode_operations unionfs_dir_iops = {
+	.create		= unionfs_create,
+	.lookup		= unionfs_lookup,
+	.link		= unionfs_link,
+	.unlink		= unionfs_unlink,
+	.symlink	= unionfs_symlink,
+	.mkdir		= unionfs_mkdir,
+	.rmdir		= unionfs_rmdir,
+	.mknod		= unionfs_mknod,
+	.rename		= unionfs_rename,
+	.permission	= unionfs_permission,
+	.setattr	= unionfs_setattr,
+#ifdef CONFIG_UNION_FS_XATTR
+	.setxattr	= unionfs_setxattr,
+	.getxattr	= unionfs_getxattr,
+	.removexattr	= unionfs_removexattr,
+	.listxattr	= unionfs_listxattr,
+#endif /* CONFIG_UNION_FS_XATTR */
+};
+
+struct inode_operations unionfs_main_iops = {
+	.permission	= unionfs_permission,
+	.setattr	= unionfs_setattr,
+#ifdef CONFIG_UNION_FS_XATTR
+	.setxattr	= unionfs_setxattr,
+	.getxattr	= unionfs_getxattr,
+	.removexattr	= unionfs_removexattr,
+	.listxattr	= unionfs_listxattr,
+#endif /* CONFIG_UNION_FS_XATTR */
+};
diff --git a/fs/unionfs/lookup.c b/fs/unionfs/lookup.c
new file mode 100644
index 0000000..b63c17e
--- /dev/null
+++ b/fs/unionfs/lookup.c
@@ -0,0 +1,569 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Lookup one path component @name relative to a <base,mnt> path pair.
+ * Behaves nearly the same as lookup_one_len (i.e., return negative dentry
+ * on ENOENT), but uses the @mnt passed, so it can cross bind mounts and
+ * other lower mounts properly.  If @new_mnt is non-null, will fill in the
+ * new mnt there.  Caller is responsible to dput/mntput/path_put returned
+ * @dentry and @new_mnt.
+ */
+struct dentry *__lookup_one(struct dentry *base, struct vfsmount *mnt,
+			    const char *name, struct vfsmount **new_mnt)
+{
+	struct dentry *dentry = NULL;
+	struct nameidata lower_nd;
+	int err;
+
+	/* we use flags=0 to get basic lookup */
+	err = vfs_path_lookup(base, mnt, name, 0, &lower_nd);
+
+	switch (err) {
+	case 0: /* no error */
+		dentry = lower_nd.path.dentry;
+		if (new_mnt)
+			*new_mnt = lower_nd.path.mnt; /* rc already inc'ed */
+		break;
+	case -ENOENT:
+		 /*
+		  * We don't consider ENOENT an error, and we want to return
+		  * a negative dentry (ala lookup_one_len).  As we know
+		  * there was no inode for this name before (-ENOENT), then
+		  * it's safe to call lookup_one_len (which doesn't take a
+		  * vfsmount).
+		  */
+		dentry = lookup_lck_len(name, base, strlen(name));
+		if (new_mnt)
+			*new_mnt = mntget(lower_nd.path.mnt);
+		break;
+	default: /* all other real errors */
+		dentry = ERR_PTR(err);
+		break;
+	}
+
+	return dentry;
+}
+
+/*
+ * This is a utility function that fills in a unionfs dentry.
+ * Caller must lock this dentry with unionfs_lock_dentry.
+ *
+ * Returns: 0 (ok), or -ERRNO if an error occurred.
+ * XXX: get rid of _partial_lookup and make callers call _lookup_full directly
+ */
+int unionfs_partial_lookup(struct dentry *dentry, struct dentry *parent)
+{
+	struct dentry *tmp;
+	int err = -ENOSYS;
+
+	tmp = unionfs_lookup_full(dentry, parent, INTERPOSE_PARTIAL);
+
+	if (!tmp) {
+		err = 0;
+		goto out;
+	}
+	if (IS_ERR(tmp)) {
+		err = PTR_ERR(tmp);
+		goto out;
+	}
+	/* XXX: need to change the interface */
+	BUG_ON(tmp != dentry);
+out:
+	return err;
+}
+
+/* The dentry cache is just so we have properly sized dentries. */
+static struct kmem_cache *unionfs_dentry_cachep;
+int unionfs_init_dentry_cache(void)
+{
+	unionfs_dentry_cachep =
+		kmem_cache_create("unionfs_dentry",
+				  sizeof(struct unionfs_dentry_info),
+				  0, SLAB_RECLAIM_ACCOUNT, NULL);
+
+	return (unionfs_dentry_cachep ? 0 : -ENOMEM);
+}
+
+void unionfs_destroy_dentry_cache(void)
+{
+	if (unionfs_dentry_cachep)
+		kmem_cache_destroy(unionfs_dentry_cachep);
+}
+
+void free_dentry_private_data(struct dentry *dentry)
+{
+	if (!dentry || !dentry->d_fsdata)
+		return;
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	UNIONFS_D(dentry)->lower_paths = NULL;
+	kmem_cache_free(unionfs_dentry_cachep, dentry->d_fsdata);
+	dentry->d_fsdata = NULL;
+}
+
+static inline int __realloc_dentry_private_data(struct dentry *dentry)
+{
+	struct unionfs_dentry_info *info = UNIONFS_D(dentry);
+	void *p;
+	int size;
+
+	BUG_ON(!info);
+
+	size = sizeof(struct path) * sbmax(dentry->d_sb);
+	p = krealloc(info->lower_paths, size, GFP_ATOMIC);
+	if (unlikely(!p))
+		return -ENOMEM;
+
+	info->lower_paths = p;
+
+	info->bstart = -1;
+	info->bend = -1;
+	info->bopaque = -1;
+	info->bcount = sbmax(dentry->d_sb);
+	atomic_set(&info->generation,
+			atomic_read(&UNIONFS_SB(dentry->d_sb)->generation));
+
+	memset(info->lower_paths, 0, size);
+
+	return 0;
+}
+
+/* UNIONFS_D(dentry)->lock must be locked */
+int realloc_dentry_private_data(struct dentry *dentry)
+{
+	if (!__realloc_dentry_private_data(dentry))
+		return 0;
+
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	free_dentry_private_data(dentry);
+	return -ENOMEM;
+}
+
+/* allocate new dentry private data */
+int new_dentry_private_data(struct dentry *dentry, int subclass)
+{
+	struct unionfs_dentry_info *info = UNIONFS_D(dentry);
+
+	BUG_ON(info);
+
+	info = kmem_cache_alloc(unionfs_dentry_cachep, GFP_ATOMIC);
+	if (unlikely(!info))
+		return -ENOMEM;
+
+	mutex_init(&info->lock);
+	mutex_lock_nested(&info->lock, subclass);
+
+	info->lower_paths = NULL;
+
+	dentry->d_fsdata = info;
+
+	if (!__realloc_dentry_private_data(dentry))
+		return 0;
+
+	mutex_unlock(&info->lock);
+	free_dentry_private_data(dentry);
+	return -ENOMEM;
+}
+
+/*
+ * scan through the lower dentry objects, and set bstart to reflect the
+ * starting branch
+ */
+void update_bstart(struct dentry *dentry)
+{
+	int bindex;
+	int bstart = dbstart(dentry);
+	int bend = dbend(dentry);
+	struct dentry *lower_dentry;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+		if (lower_dentry->d_inode) {
+			dbstart(dentry) = bindex;
+			break;
+		}
+		dput(lower_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+	}
+}
+
+
+/*
+ * Initialize a nameidata structure (the intent part) we can pass to a lower
+ * file system.  Returns 0 on success or -error (only -ENOMEM possible).
+ * Inside that nd structure, this function may also return an allocated
+ * struct file (for open intents).  The caller, when done with this nd, must
+ * kfree the intent file (using release_lower_nd).
+ *
+ * XXX: this code, and the callers of this code, should be redone using
+ * vfs_path_lookup() when (1) the nameidata structure is refactored into a
+ * separate intent-structure, and (2) open_namei() is broken into a VFS-only
+ * function and a method that other file systems can call.
+ */
+int init_lower_nd(struct nameidata *nd, unsigned int flags)
+{
+	int err = 0;
+#ifdef ALLOC_LOWER_ND_FILE
+	/*
+	 * XXX: one day we may need to have the lower return an open file
+	 * for us.  It is not needed in 2.6.23-rc1 for nfs2/nfs3, but may
+	 * very well be needed for nfs4.
+	 */
+	struct file *file;
+#endif /* ALLOC_LOWER_ND_FILE */
+
+	memset(nd, 0, sizeof(struct nameidata));
+	if (!flags)
+		return err;
+
+	switch (flags) {
+	case LOOKUP_CREATE:
+		nd->intent.open.flags |= O_CREAT;
+		/* fall through: shared code for create/open cases */
+	case LOOKUP_OPEN:
+		nd->flags = flags;
+		nd->intent.open.flags |= (FMODE_READ | FMODE_WRITE);
+#ifdef ALLOC_LOWER_ND_FILE
+		file = kzalloc(sizeof(struct file), GFP_KERNEL);
+		if (unlikely(!file)) {
+			err = -ENOMEM;
+			break; /* exit switch statement and thus return */
+		}
+		nd->intent.open.file = file;
+#endif /* ALLOC_LOWER_ND_FILE */
+		break;
+	default:
+		/*
+		 * We should never get here, for now.
+		 * We can add new cases here later on.
+		 */
+		pr_debug("unionfs: unknown nameidata flag 0x%x\n", flags);
+		BUG();
+		break;
+	}
+
+	return err;
+}
+
+void release_lower_nd(struct nameidata *nd, int err)
+{
+	if (!nd->intent.open.file)
+		return;
+	else if (!err)
+		release_open_intent(nd);
+#ifdef ALLOC_LOWER_ND_FILE
+	kfree(nd->intent.open.file);
+#endif /* ALLOC_LOWER_ND_FILE */
+}
+
+/*
+ * Main (and complex) driver function for Unionfs's lookup
+ *
+ * Returns: NULL (ok), ERR_PTR if an error occurred, or a non-null non-error
+ * PTR if d_splice returned a different dentry.
+ *
+ * If lookupmode is INTERPOSE_PARTIAL/REVAL/REVAL_NEG, the passed dentry's
+ * inode info must be locked.  If lookupmode is INTERPOSE_LOOKUP (i.e., a
+ * newly looked-up dentry), then unionfs_lookup_backend will return a locked
+ * dentry's info, which the caller must unlock.
+ */
+struct dentry *unionfs_lookup_full(struct dentry *dentry,
+				   struct dentry *parent, int lookupmode)
+{
+	int err = 0;
+	struct dentry *lower_dentry = NULL;
+	struct vfsmount *lower_mnt;
+	struct vfsmount *lower_dir_mnt;
+	struct dentry *wh_lower_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *d_interposed = NULL;
+	int bindex, bstart, bend, bopaque;
+	int opaque, num_positive = 0;
+	const char *name;
+	int namelen;
+	int pos_start, pos_end;
+
+	/*
+	 * We should already have a lock on this dentry in the case of a
+	 * partial lookup, or a revalidation.  Otherwise it is returned from
+	 * new_dentry_private_data already locked.
+	 */
+	verify_locked(dentry);
+	verify_locked(parent);
+
+	/* must initialize dentry operations */
+	dentry->d_op = &unionfs_dops;
+
+	/* We never partial lookup the root directory. */
+	if (IS_ROOT(dentry))
+		goto out;
+
+	name = dentry->d_name.name;
+	namelen = dentry->d_name.len;
+
+	/* No dentries should get created for possible whiteout names. */
+	if (!is_validname(name)) {
+		err = -EPERM;
+		goto out_free;
+	}
+
+	/* Now start the actual lookup procedure. */
+	bstart = dbstart(parent);
+	bend = dbend(parent);
+	bopaque = dbopaque(parent);
+	BUG_ON(bstart < 0);
+
+	/* adjust bend to bopaque if needed */
+	if ((bopaque >= 0) && (bopaque < bend))
+		bend = bopaque;
+
+	/* lookup all possible dentries */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		lower_mnt = unionfs_lower_mnt_idx(dentry, bindex);
+
+		/* skip if we already have a positive lower dentry */
+		if (lower_dentry) {
+			if (dbstart(dentry) < 0)
+				dbstart(dentry) = bindex;
+			if (bindex > dbend(dentry))
+				dbend(dentry) = bindex;
+			if (lower_dentry->d_inode)
+				num_positive++;
+			continue;
+		}
+
+		lower_dir_dentry =
+			unionfs_lower_dentry_idx(parent, bindex);
+		/* if the lower dentry's parent does not exist, skip this */
+		if (!lower_dir_dentry || !lower_dir_dentry->d_inode)
+			continue;
+
+		/* also skip it if the parent isn't a directory. */
+		if (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))
+			continue; /* XXX: should be BUG_ON */
+
+		/* check for whiteouts: stop lookup if found */
+		wh_lower_dentry = lookup_whiteout(name, lower_dir_dentry);
+		if (IS_ERR(wh_lower_dentry)) {
+			err = PTR_ERR(wh_lower_dentry);
+			goto out_free;
+		}
+		if (wh_lower_dentry->d_inode) {
+			dbend(dentry) = dbopaque(dentry) = bindex;
+			if (dbstart(dentry) < 0)
+				dbstart(dentry) = bindex;
+			dput(wh_lower_dentry);
+			break;
+		}
+		dput(wh_lower_dentry);
+
+		/* Now do regular lookup; lookup @name */
+		lower_dir_mnt = unionfs_lower_mnt_idx(parent, bindex);
+		lower_mnt = NULL; /* XXX: needed? */
+
+		lower_dentry = __lookup_one(lower_dir_dentry, lower_dir_mnt,
+					    name, &lower_mnt);
+
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out_free;
+		}
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		if (!lower_mnt)
+			lower_mnt = unionfs_mntget(dentry->d_sb->s_root,
+						   bindex);
+		unionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);
+
+		/* adjust dbstart/end */
+		if (dbstart(dentry) < 0)
+			dbstart(dentry) = bindex;
+		if (bindex > dbend(dentry))
+			dbend(dentry) = bindex;
+		/*
+		 * We always store the lower dentries above, and update
+		 * dbstart/dbend, even if the whole unionfs dentry is
+		 * negative (i.e., no lower inodes).
+		 */
+		if (!lower_dentry->d_inode)
+			continue;
+		num_positive++;
+
+		/*
+		 * check if we just found an opaque directory, if so, stop
+		 * lookups here.
+		 */
+		if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+			continue;
+		opaque = is_opaque_dir(dentry, bindex);
+		if (opaque < 0) {
+			err = opaque;
+			goto out_free;
+		} else if (opaque) {
+			dbend(dentry) = dbopaque(dentry) = bindex;
+			break;
+		}
+		dbend(dentry) = bindex;
+
+		/* update parent directory's atime with the bindex */
+		fsstack_copy_attr_atime(parent->d_inode,
+					lower_dir_dentry->d_inode);
+	}
+
+	/* sanity checks, then decide if to process a negative dentry */
+	BUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);
+	BUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);
+
+	if (num_positive > 0)
+		goto out_positive;
+
+	/*** handle NEGATIVE dentries ***/
+
+	/*
+	 * If negative, keep only first lower negative dentry, to save on
+	 * memory.
+	 */
+	if (dbstart(dentry) < dbend(dentry)) {
+		path_put_lowers(dentry, dbstart(dentry) + 1,
+				dbend(dentry), false);
+		dbend(dentry) = dbstart(dentry);
+	}
+	if (lookupmode == INTERPOSE_PARTIAL)
+		goto out;
+	if (lookupmode == INTERPOSE_LOOKUP) {
+		/*
+		 * If all we found was a whiteout in the first available
+		 * branch, then create a negative dentry for a possibly new
+		 * file to be created.
+		 */
+		if (dbopaque(dentry) < 0)
+			goto out;
+		/* XXX: need to get mnt here */
+		bindex = dbstart(dentry);
+		if (unionfs_lower_dentry_idx(dentry, bindex))
+			goto out;
+		lower_dir_dentry =
+			unionfs_lower_dentry_idx(parent, bindex);
+		if (!lower_dir_dentry || !lower_dir_dentry->d_inode)
+			goto out;
+		if (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))
+			goto out; /* XXX: should be BUG_ON */
+		/* XXX: do we need to cross bind mounts here? */
+		lower_dentry = lookup_lck_len(name, lower_dir_dentry, namelen);
+		if (IS_ERR(lower_dentry)) {
+			err = PTR_ERR(lower_dentry);
+			goto out;
+		}
+		/* XXX: need to mntget/mntput as needed too! */
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		/* XXX: wrong mnt for crossing bind mounts! */
+		lower_mnt = unionfs_mntget(dentry->d_sb->s_root, bindex);
+		unionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);
+
+		goto out;
+	}
+
+	/* if we're revalidating a positive dentry, don't make it negative */
+	if (lookupmode != INTERPOSE_REVAL)
+		d_add(dentry, NULL);
+
+	goto out;
+
+out_positive:
+	/*** handle POSITIVE dentries ***/
+
+	/*
+	 * This unionfs dentry is positive (at least one lower inode
+	 * exists), so scan entire dentry from beginning to end, and remove
+	 * any negative lower dentries, if any.  Then, update dbstart/dbend
+	 * to reflect the start/end of positive dentries.
+	 */
+	pos_start = pos_end = -1;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry,
+							bindex);
+		if (lower_dentry && lower_dentry->d_inode) {
+			if (pos_start < 0)
+				pos_start = bindex;
+			if (bindex > pos_end)
+				pos_end = bindex;
+			continue;
+		}
+		path_put_lowers(dentry, bindex, bindex, false);
+	}
+	if (pos_start >= 0)
+		dbstart(dentry) = pos_start;
+	if (pos_end >= 0)
+		dbend(dentry) = pos_end;
+
+	/* Partial lookups need to re-interpose, or throw away older negs. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		if (dentry->d_inode) {
+			unionfs_reinterpose(dentry);
+			goto out;
+		}
+
+		/*
+		 * This dentry was positive, so it is as if we had a
+		 * negative revalidation.
+		 */
+		lookupmode = INTERPOSE_REVAL_NEG;
+		update_bstart(dentry);
+	}
+
+	/*
+	 * Interpose can return a dentry if d_splice returned a different
+	 * dentry.
+	 */
+	d_interposed = unionfs_interpose(dentry, dentry->d_sb, lookupmode);
+	if (IS_ERR(d_interposed))
+		err = PTR_ERR(d_interposed);
+	else if (d_interposed)
+		dentry = d_interposed;
+
+	if (!err)
+		goto out;
+	d_drop(dentry);
+
+out_free:
+	/* should dput/mntput all the underlying dentries on error condition */
+	if (dbstart(dentry) >= 0)
+		path_put_lowers_all(dentry, false);
+	/* free lower_paths unconditionally */
+	kfree(UNIONFS_D(dentry)->lower_paths);
+	UNIONFS_D(dentry)->lower_paths = NULL;
+
+out:
+	if (dentry && UNIONFS_D(dentry)) {
+		BUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);
+		BUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);
+	}
+	if (d_interposed && UNIONFS_D(d_interposed)) {
+		BUG_ON(dbstart(d_interposed) < 0 && dbend(d_interposed) >= 0);
+		BUG_ON(dbstart(d_interposed) >= 0 && dbend(d_interposed) < 0);
+	}
+
+	if (!err && d_interposed)
+		return d_interposed;
+	return ERR_PTR(err);
+}
diff --git a/fs/unionfs/main.c b/fs/unionfs/main.c
new file mode 100644
index 0000000..258386e
--- /dev/null
+++ b/fs/unionfs/main.c
@@ -0,0 +1,758 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+static void unionfs_fill_inode(struct dentry *dentry,
+			       struct inode *inode)
+{
+	struct inode *lower_inode;
+	struct dentry *lower_dentry;
+	int bindex, bstart, bend;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry) {
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			continue;
+		}
+
+		/* Initialize the lower inode to the new lower inode. */
+		if (!lower_dentry->d_inode)
+			continue;
+
+		unionfs_set_lower_inode_idx(inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	/* Use attributes from the first branch. */
+	lower_inode = unionfs_lower_inode(inode);
+
+	/* Use different set of inode ops for symlinks & directories */
+	if (S_ISLNK(lower_inode->i_mode))
+		inode->i_op = &unionfs_symlink_iops;
+	else if (S_ISDIR(lower_inode->i_mode))
+		inode->i_op = &unionfs_dir_iops;
+
+	/* Use different set of file ops for directories */
+	if (S_ISDIR(lower_inode->i_mode))
+		inode->i_fop = &unionfs_dir_fops;
+
+	/* properly initialize special inodes */
+	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
+	    S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode))
+		init_special_inode(inode, lower_inode->i_mode,
+				   lower_inode->i_rdev);
+
+	/* all well, copy inode attributes */
+	unionfs_copy_attr_all(inode, lower_inode);
+	fsstack_copy_inode_size(inode, lower_inode);
+}
+
+/*
+ * Connect a unionfs inode dentry/inode with several lower ones.  This is
+ * the classic stackable file system "vnode interposition" action.
+ *
+ * @sb: unionfs's super_block
+ */
+struct dentry *unionfs_interpose(struct dentry *dentry, struct super_block *sb,
+				 int flag)
+{
+	int err = 0;
+	struct inode *inode;
+	int need_fill_inode = 1;
+	struct dentry *spliced = NULL;
+
+	verify_locked(dentry);
+
+	/*
+	 * We allocate our new inode below by calling unionfs_iget,
+	 * which will initialize some of the new inode's fields
+	 */
+
+	/*
+	 * On revalidate we've already got our own inode and just need
+	 * to fix it up.
+	 */
+	if (flag == INTERPOSE_REVAL) {
+		inode = dentry->d_inode;
+		UNIONFS_I(inode)->bstart = -1;
+		UNIONFS_I(inode)->bend = -1;
+		atomic_set(&UNIONFS_I(inode)->generation,
+			   atomic_read(&UNIONFS_SB(sb)->generation));
+
+		UNIONFS_I(inode)->lower_inodes =
+			kcalloc(sbmax(sb), sizeof(struct inode *), GFP_KERNEL);
+		if (unlikely(!UNIONFS_I(inode)->lower_inodes)) {
+			err = -ENOMEM;
+			goto out;
+		}
+	} else {
+		/* get unique inode number for unionfs */
+		inode = unionfs_iget(sb, iunique(sb, UNIONFS_ROOT_INO));
+		if (IS_ERR(inode)) {
+			err = PTR_ERR(inode);
+			goto out;
+		}
+		if (atomic_read(&inode->i_count) > 1)
+			goto skip;
+	}
+
+	need_fill_inode = 0;
+	unionfs_fill_inode(dentry, inode);
+
+skip:
+	/* only (our) lookup wants to do a d_add */
+	switch (flag) {
+	case INTERPOSE_DEFAULT:
+		/* for operations which create new inodes */
+		d_add(dentry, inode);
+		break;
+	case INTERPOSE_REVAL_NEG:
+		d_instantiate(dentry, inode);
+		break;
+	case INTERPOSE_LOOKUP:
+		spliced = d_splice_alias(inode, dentry);
+		if (spliced && spliced != dentry) {
+			/*
+			 * d_splice can return a dentry if it was
+			 * disconnected and had to be moved.  We must ensure
+			 * that the private data of the new dentry is
+			 * correct and that the inode info was filled
+			 * properly.  Finally we must return this new
+			 * dentry.
+			 */
+			spliced->d_op = &unionfs_dops;
+			spliced->d_fsdata = dentry->d_fsdata;
+			dentry->d_fsdata = NULL;
+			dentry = spliced;
+			if (need_fill_inode) {
+				need_fill_inode = 0;
+				unionfs_fill_inode(dentry, inode);
+			}
+			goto out_spliced;
+		} else if (!spliced) {
+			if (need_fill_inode) {
+				need_fill_inode = 0;
+				unionfs_fill_inode(dentry, inode);
+				goto out_spliced;
+			}
+		}
+		break;
+	case INTERPOSE_REVAL:
+		/* Do nothing. */
+		break;
+	default:
+		printk(KERN_CRIT "unionfs: invalid interpose flag passed!\n");
+		BUG();
+	}
+	goto out;
+
+out_spliced:
+	if (!err)
+		return spliced;
+out:
+	return ERR_PTR(err);
+}
+
+/* like interpose above, but for an already existing dentry */
+void unionfs_reinterpose(struct dentry *dentry)
+{
+	struct dentry *lower_dentry;
+	struct inode *inode;
+	int bindex, bstart, bend;
+
+	verify_locked(dentry);
+
+	/* This is pre-allocated inode */
+	inode = dentry->d_inode;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry)
+			continue;
+
+		if (!lower_dentry->d_inode)
+			continue;
+		if (unionfs_lower_inode_idx(inode, bindex))
+			continue;
+		unionfs_set_lower_inode_idx(inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+}
+
+/*
+ * make sure the branch we just looked up (nd) makes sense:
+ *
+ * 1) we're not trying to stack unionfs on top of unionfs
+ * 2) it exists
+ * 3) is a directory
+ */
+int check_branch(struct nameidata *nd)
+{
+	/* XXX: remove in ODF code -- stacking unions allowed there */
+	if (!strcmp(nd->path.dentry->d_sb->s_type->name, UNIONFS_NAME))
+		return -EINVAL;
+	if (!nd->path.dentry->d_inode)
+		return -ENOENT;
+	if (!S_ISDIR(nd->path.dentry->d_inode->i_mode))
+		return -ENOTDIR;
+	return 0;
+}
+
+/* checks if two lower_dentries have overlapping branches */
+static int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)
+{
+	struct dentry *dent = NULL;
+
+	dent = dent1;
+	while ((dent != dent2) && (dent->d_parent != dent))
+		dent = dent->d_parent;
+
+	if (dent == dent2)
+		return 1;
+
+	dent = dent2;
+	while ((dent != dent1) && (dent->d_parent != dent))
+		dent = dent->d_parent;
+
+	return (dent == dent1);
+}
+
+/*
+ * Parse "ro" or "rw" options, but default to "rw" if no mode options was
+ * specified.  Fill the mode bits in @perms.  If encounter an unknown
+ * string, return -EINVAL.  Otherwise return 0.
+ */
+int parse_branch_mode(const char *name, int *perms)
+{
+	if (!name || !strcmp(name, "rw")) {
+		*perms = MAY_READ | MAY_WRITE;
+		return 0;
+	}
+	if (!strcmp(name, "ro")) {
+		*perms = MAY_READ;
+		return 0;
+	}
+	return -EINVAL;
+}
+
+/*
+ * parse the dirs= mount argument
+ *
+ * We don't need to lock the superblock private data's rwsem, as we get
+ * called only by unionfs_read_super - it is still a long time before anyone
+ * can even get a reference to us.
+ */
+static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
+			     *lower_root_info, char *options)
+{
+	struct nameidata nd;
+	char *name;
+	int err = 0;
+	int branches = 1;
+	int bindex = 0;
+	int i = 0;
+	int j = 0;
+	struct dentry *dent1;
+	struct dentry *dent2;
+
+	if (options[0] == '\0') {
+		printk(KERN_ERR "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Each colon means we have a separator, this is really just a rough
+	 * guess, since strsep will handle empty fields for us.
+	 */
+	for (i = 0; options[i]; i++)
+		if (options[i] == ':')
+			branches++;
+
+	/* allocate space for underlying pointers to lower dentry */
+	UNIONFS_SB(sb)->data =
+		kcalloc(branches, sizeof(struct unionfs_data), GFP_KERNEL);
+	if (unlikely(!UNIONFS_SB(sb)->data)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	lower_root_info->lower_paths =
+		kcalloc(branches, sizeof(struct path), GFP_KERNEL);
+	if (unlikely(!lower_root_info->lower_paths)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* now parsing a string such as "b1:b2=rw:b3=ro:b4" */
+	branches = 0;
+	while ((name = strsep(&options, ":")) != NULL) {
+		int perms;
+		char *mode = strchr(name, '=');
+
+		if (!name)
+			continue;
+		if (!*name) {	/* bad use of ':' (extra colons) */
+			err = -EINVAL;
+			goto out;
+		}
+
+		branches++;
+
+		/* strip off '=' if any */
+		if (mode)
+			*mode++ = '\0';
+
+		err = parse_branch_mode(mode, &perms);
+		if (err) {
+			printk(KERN_ERR "unionfs: invalid mode \"%s\" for "
+			       "branch %d\n", mode, bindex);
+			goto out;
+		}
+		/* ensure that leftmost branch is writeable */
+		if (!bindex && !(perms & MAY_WRITE)) {
+			printk(KERN_ERR "unionfs: leftmost branch cannot be "
+			       "read-only (use \"-o ro\" to create a "
+			       "read-only union)\n");
+			err = -EINVAL;
+			goto out;
+		}
+
+		err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+		if (err) {
+			printk(KERN_ERR "unionfs: error accessing "
+			       "lower directory '%s' (error %d)\n",
+			       name, err);
+			goto out;
+		}
+
+		err = check_branch(&nd);
+		if (err) {
+			printk(KERN_ERR "unionfs: lower directory "
+			       "'%s' is not a valid branch\n", name);
+			path_put(&nd.path);
+			goto out;
+		}
+
+		lower_root_info->lower_paths[bindex].dentry = nd.path.dentry;
+		lower_root_info->lower_paths[bindex].mnt = nd.path.mnt;
+
+		set_branchperms(sb, bindex, perms);
+		set_branch_count(sb, bindex, 0);
+		new_branch_id(sb, bindex);
+
+		if (lower_root_info->bstart < 0)
+			lower_root_info->bstart = bindex;
+		lower_root_info->bend = bindex;
+		bindex++;
+	}
+
+	if (branches == 0) {
+		printk(KERN_ERR "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	BUG_ON(branches != (lower_root_info->bend + 1));
+
+	/*
+	 * Ensure that no overlaps exist in the branches.
+	 *
+	 * This test is required because the Linux kernel has no support
+	 * currently for ensuring coherency between stackable layers and
+	 * branches.  If we were to allow overlapping branches, it would be
+	 * possible, for example, to delete a file via one branch, which
+	 * would not be reflected in another branch.  Such incoherency could
+	 * lead to inconsistencies and even kernel oopses.  Rather than
+	 * implement hacks to work around some of these cache-coherency
+	 * problems, we prevent branch overlapping, for now.  A complete
+	 * solution will involve proper kernel/VFS support for cache
+	 * coherency, at which time we could safely remove this
+	 * branch-overlapping test.
+	 */
+	for (i = 0; i < branches; i++) {
+		dent1 = lower_root_info->lower_paths[i].dentry;
+		for (j = i + 1; j < branches; j++) {
+			dent2 = lower_root_info->lower_paths[j].dentry;
+			if (is_branch_overlap(dent1, dent2)) {
+				printk(KERN_ERR "unionfs: branches %d and "
+				       "%d overlap\n", i, j);
+				err = -EINVAL;
+				goto out;
+			}
+		}
+	}
+
+out:
+	if (err) {
+		for (i = 0; i < branches; i++)
+			path_put(&lower_root_info->lower_paths[i]);
+
+		kfree(lower_root_info->lower_paths);
+		kfree(UNIONFS_SB(sb)->data);
+
+		/*
+		 * MUST clear the pointers to prevent potential double free if
+		 * the caller dies later on
+		 */
+		lower_root_info->lower_paths = NULL;
+		UNIONFS_SB(sb)->data = NULL;
+	}
+	return err;
+}
+
+/*
+ * Parse mount options.  See the manual page for usage instructions.
+ *
+ * Returns the dentry object of the lower-level (lower) directory;
+ * We want to mount our stackable file system on top of that lower directory.
+ */
+static struct unionfs_dentry_info *unionfs_parse_options(
+					 struct super_block *sb,
+					 char *options)
+{
+	struct unionfs_dentry_info *lower_root_info;
+	char *optname;
+	int err = 0;
+	int bindex;
+	int dirsfound = 0;
+
+	/* allocate private data area */
+	err = -ENOMEM;
+	lower_root_info =
+		kzalloc(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
+	if (unlikely(!lower_root_info))
+		goto out_error;
+	lower_root_info->bstart = -1;
+	lower_root_info->bend = -1;
+	lower_root_info->bopaque = -1;
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+
+		/*
+		 * All of our options take an argument now. Insert ones that
+		 * don't, above this check.
+		 */
+		if (!optarg) {
+			printk(KERN_ERR "unionfs: %s requires an argument\n",
+			       optname);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("dirs", optname)) {
+			if (++dirsfound > 1) {
+				printk(KERN_ERR
+				       "unionfs: multiple dirs specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err = parse_dirs_option(sb, lower_root_info, optarg);
+			if (err)
+				goto out_error;
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_ERR
+		       "unionfs: unrecognized option '%s'\n", optname);
+		goto out_error;
+	}
+	if (dirsfound != 1) {
+		printk(KERN_ERR "unionfs: dirs option required\n");
+		err = -EINVAL;
+		goto out_error;
+	}
+	goto out;
+
+out_error:
+	if (lower_root_info && lower_root_info->lower_paths) {
+		for (bindex = lower_root_info->bstart;
+		     bindex >= 0 && bindex <= lower_root_info->bend;
+		     bindex++)
+			path_put(&lower_root_info->lower_paths[bindex]);
+	}
+
+	kfree(lower_root_info->lower_paths);
+	kfree(lower_root_info);
+
+	kfree(UNIONFS_SB(sb)->data);
+	UNIONFS_SB(sb)->data = NULL;
+
+	lower_root_info = ERR_PTR(err);
+out:
+	return lower_root_info;
+}
+
+/*
+ * our custom d_alloc_root work-alike
+ *
+ * we can't use d_alloc_root if we want to use our own interpose function
+ * unchanged, so we simply call our own "fake" d_alloc_root
+ */
+static struct dentry *unionfs_d_alloc_root(struct super_block *sb)
+{
+	struct dentry *ret = NULL;
+
+	if (sb) {
+		static const struct qstr name = {
+			.name = "/",
+			.len = 1
+		};
+
+		ret = d_alloc(NULL, &name);
+		if (likely(ret)) {
+			ret->d_op = &unionfs_dops;
+			ret->d_sb = sb;
+			ret->d_parent = ret;
+		}
+	}
+	return ret;
+}
+
+/*
+ * There is no need to lock the unionfs_super_info's rwsem as there is no
+ * way anyone can have a reference to the superblock at this point in time.
+ */
+static int unionfs_read_super(struct super_block *sb, void *raw_data,
+			      int silent)
+{
+	int err = 0;
+	struct unionfs_dentry_info *lower_root_info = NULL;
+	int bindex, bstart, bend;
+
+	if (!raw_data) {
+		printk(KERN_ERR
+		       "unionfs: read_super: missing data argument\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Allocate superblock private data */
+	sb->s_fs_info = kzalloc(sizeof(struct unionfs_sb_info), GFP_KERNEL);
+	if (unlikely(!UNIONFS_SB(sb))) {
+		printk(KERN_CRIT "unionfs: read_super: out of memory\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	UNIONFS_SB(sb)->bend = -1;
+	atomic_set(&UNIONFS_SB(sb)->generation, 1);
+	init_rwsem(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->high_branch_id = -1; /* -1 == invalid branch ID */
+
+	lower_root_info = unionfs_parse_options(sb, raw_data);
+	if (IS_ERR(lower_root_info)) {
+		printk(KERN_ERR
+		       "unionfs: read_super: error while parsing options "
+		       "(err = %ld)\n", PTR_ERR(lower_root_info));
+		err = PTR_ERR(lower_root_info);
+		lower_root_info = NULL;
+		goto out_free;
+	}
+	if (lower_root_info->bstart == -1) {
+		err = -ENOENT;
+		goto out_free;
+	}
+
+	/* set the lower superblock field of upper superblock */
+	bstart = lower_root_info->bstart;
+	BUG_ON(bstart != 0);
+	sbend(sb) = bend = lower_root_info->bend;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d = lower_root_info->lower_paths[bindex].dentry;
+		atomic_inc(&d->d_sb->s_active);
+		unionfs_set_lower_super_idx(sb, bindex, d->d_sb);
+	}
+
+	/* max Bytes is the maximum bytes from highest priority branch */
+	sb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;
+
+	/*
+	 * Our c/m/atime granularity is 1 ns because we may stack on file
+	 * systems whose granularity is as good.  This is important for our
+	 * time-based cache coherency.
+	 */
+	sb->s_time_gran = 1;
+
+	sb->s_op = &unionfs_sops;
+
+	/* See comment next to the definition of unionfs_d_alloc_root */
+	sb->s_root = unionfs_d_alloc_root(sb);
+	if (unlikely(!sb->s_root)) {
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	/* link the upper and lower dentries */
+	sb->s_root->d_fsdata = NULL;
+	err = new_dentry_private_data(sb->s_root, UNIONFS_DMUTEX_ROOT);
+	if (unlikely(err))
+		goto out_freedpd;
+
+	/* Set the lower dentries for s_root */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+		struct vfsmount *m;
+
+		d = lower_root_info->lower_paths[bindex].dentry;
+		m = lower_root_info->lower_paths[bindex].mnt;
+
+		unionfs_set_lower_dentry_idx(sb->s_root, bindex, d);
+		unionfs_set_lower_mnt_idx(sb->s_root, bindex, m);
+	}
+	dbstart(sb->s_root) = bstart;
+	dbend(sb->s_root) = bend;
+
+	/* Set the generation number to one, since this is for the mount. */
+	atomic_set(&UNIONFS_D(sb->s_root)->generation, 1);
+
+	/*
+	 * Call interpose to create the upper level inode.  Only
+	 * INTERPOSE_LOOKUP can return a value other than 0 on err.
+	 */
+	err = PTR_ERR(unionfs_interpose(sb->s_root, sb, 0));
+	unionfs_unlock_dentry(sb->s_root);
+	if (!err)
+		goto out;
+	/* else fall through */
+
+out_freedpd:
+	if (UNIONFS_D(sb->s_root)) {
+		kfree(UNIONFS_D(sb->s_root)->lower_paths);
+		free_dentry_private_data(sb->s_root);
+	}
+	dput(sb->s_root);
+
+out_dput:
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		for (bindex = lower_root_info->bstart;
+		     bindex <= lower_root_info->bend; bindex++) {
+			struct dentry *d;
+			d = lower_root_info->lower_paths[bindex].dentry;
+			/* drop refs we took earlier */
+			atomic_dec(&d->d_sb->s_active);
+			path_put(&lower_root_info->lower_paths[bindex]);
+		}
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
+		lower_root_info = NULL;
+	}
+
+out_free:
+	kfree(UNIONFS_SB(sb)->data);
+	kfree(UNIONFS_SB(sb));
+	sb->s_fs_info = NULL;
+
+out:
+	if (lower_root_info && !IS_ERR(lower_root_info)) {
+		kfree(lower_root_info->lower_paths);
+		kfree(lower_root_info);
+	}
+	return err;
+}
+
+static int unionfs_get_sb(struct file_system_type *fs_type,
+			  int flags, const char *dev_name,
+			  void *raw_data, struct vfsmount *mnt)
+{
+	int err;
+	err = get_sb_nodev(fs_type, flags, raw_data, unionfs_read_super, mnt);
+	if (!err)
+		UNIONFS_SB(mnt->mnt_sb)->dev_name =
+			kstrdup(dev_name, GFP_KERNEL);
+	return err;
+}
+
+static struct file_system_type unionfs_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= UNIONFS_NAME,
+	.get_sb		= unionfs_get_sb,
+	.kill_sb	= generic_shutdown_super,
+	.fs_flags	= FS_REVAL_DOT,
+};
+
+static int __init init_unionfs_fs(void)
+{
+	int err;
+
+	pr_info("Registering unionfs " UNIONFS_VERSION "\n");
+
+	err = unionfs_init_filldir_cache();
+	if (unlikely(err))
+		goto out;
+	err = unionfs_init_inode_cache();
+	if (unlikely(err))
+		goto out;
+	err = unionfs_init_dentry_cache();
+	if (unlikely(err))
+		goto out;
+	err = init_sioq();
+	if (unlikely(err))
+		goto out;
+	err = register_filesystem(&unionfs_fs_type);
+out:
+	if (unlikely(err)) {
+		stop_sioq();
+		unionfs_destroy_filldir_cache();
+		unionfs_destroy_inode_cache();
+		unionfs_destroy_dentry_cache();
+	}
+	return err;
+}
+
+static void __exit exit_unionfs_fs(void)
+{
+	stop_sioq();
+	unionfs_destroy_filldir_cache();
+	unionfs_destroy_inode_cache();
+	unionfs_destroy_dentry_cache();
+	unregister_filesystem(&unionfs_fs_type);
+	pr_info("Completed unionfs module unload\n");
+}
+
+MODULE_AUTHOR("Erez Zadok, Filesystems and Storage Lab, Stony Brook University"
+	      " (http://www.fsl.cs.sunysb.edu)");
+MODULE_DESCRIPTION("Unionfs " UNIONFS_VERSION
+		   " (http://unionfs.filesystems.org)");
+MODULE_LICENSE("GPL");
+
+module_init(init_unionfs_fs);
+module_exit(exit_unionfs_fs);
diff --git a/fs/unionfs/mmap.c b/fs/unionfs/mmap.c
new file mode 100644
index 0000000..1f70535
--- /dev/null
+++ b/fs/unionfs/mmap.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2006      Shaya Potter
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+
+/*
+ * XXX: we need a dummy readpage handler because generic_file_mmap (which we
+ * use in unionfs_mmap) checks for the existence of
+ * mapping->a_ops->readpage, else it returns -ENOEXEC.  The VFS will need to
+ * be fixed to allow a file system to define vm_ops->fault without any
+ * address_space_ops whatsoever.
+ *
+ * Otherwise, we don't want to use our readpage method at all.
+ */
+static int unionfs_readpage(struct file *file, struct page *page)
+{
+	BUG();
+	return -EINVAL;
+}
+
+static int unionfs_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	int err;
+	struct file *file, *lower_file;
+	const struct vm_operations_struct *lower_vm_ops;
+	struct vm_area_struct lower_vma;
+
+	BUG_ON(!vma);
+	memcpy(&lower_vma, vma, sizeof(struct vm_area_struct));
+	file = lower_vma.vm_file;
+	lower_vm_ops = UNIONFS_F(file)->lower_vm_ops;
+	BUG_ON(!lower_vm_ops);
+
+	lower_file = unionfs_lower_file(file);
+	BUG_ON(!lower_file);
+	/*
+	 * XXX: vm_ops->fault may be called in parallel.  Because we have to
+	 * resort to temporarily changing the vma->vm_file to point to the
+	 * lower file, a concurrent invocation of unionfs_fault could see a
+	 * different value.  In this workaround, we keep a different copy of
+	 * the vma structure in our stack, so we never expose a different
+	 * value of the vma->vm_file called to us, even temporarily.  A
+	 * better fix would be to change the calling semantics of ->fault to
+	 * take an explicit file pointer.
+	 */
+	lower_vma.vm_file = lower_file;
+	err = lower_vm_ops->fault(&lower_vma, vmf);
+	return err;
+}
+
+/*
+ * XXX: the default address_space_ops for unionfs is empty.  We cannot set
+ * our inode->i_mapping->a_ops to NULL because too many code paths expect
+ * the a_ops vector to be non-NULL.
+ */
+struct address_space_operations unionfs_aops = {
+	/* empty on purpose */
+};
+
+/*
+ * XXX: we need a second, dummy address_space_ops vector, to be used
+ * temporarily during unionfs_mmap, because the latter calls
+ * generic_file_mmap, which checks if ->readpage exists, else returns
+ * -ENOEXEC.
+ */
+struct address_space_operations unionfs_dummy_aops = {
+	.readpage	= unionfs_readpage,
+};
+
+struct vm_operations_struct unionfs_vm_ops = {
+	.fault		= unionfs_fault,
+};
diff --git a/fs/unionfs/rdstate.c b/fs/unionfs/rdstate.c
new file mode 100644
index 0000000..f745fbc
--- /dev/null
+++ b/fs/unionfs/rdstate.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* This file contains the routines for maintaining readdir state. */
+
+/*
+ * There are two structures here, rdstate which is a hash table
+ * of the second structure which is a filldir_node.
+ */
+
+/*
+ * This is a struct kmem_cache for filldir nodes, because we allocate a lot
+ * of them and they shouldn't waste memory.  If the node has a small name
+ * (as defined by the dentry structure), then we use an inline name to
+ * preserve kmalloc space.
+ */
+static struct kmem_cache *unionfs_filldir_cachep;
+
+int unionfs_init_filldir_cache(void)
+{
+	unionfs_filldir_cachep =
+		kmem_cache_create("unionfs_filldir",
+				  sizeof(struct filldir_node), 0,
+				  SLAB_RECLAIM_ACCOUNT, NULL);
+
+	return (unionfs_filldir_cachep ? 0 : -ENOMEM);
+}
+
+void unionfs_destroy_filldir_cache(void)
+{
+	if (unionfs_filldir_cachep)
+		kmem_cache_destroy(unionfs_filldir_cachep);
+}
+
+/*
+ * This is a tuning parameter that tells us roughly how big to make the
+ * hash table in directory entries per page.  This isn't perfect, but
+ * at least we get a hash table size that shouldn't be too overloaded.
+ * The following averages are based on my home directory.
+ * 14.44693	Overall
+ * 12.29	Single Page Directories
+ * 117.93	Multi-page directories
+ */
+#define DENTPAGE 4096
+#define DENTPERONEPAGE 12
+#define DENTPERPAGE 118
+#define MINHASHSIZE 1
+static int guesstimate_hash_size(struct inode *inode)
+{
+	struct inode *lower_inode;
+	int bindex;
+	int hashsize = MINHASHSIZE;
+
+	if (UNIONFS_I(inode)->hashsize > 0)
+		return UNIONFS_I(inode)->hashsize;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		lower_inode = unionfs_lower_inode_idx(inode, bindex);
+		if (!lower_inode)
+			continue;
+
+		if (i_size_read(lower_inode) == DENTPAGE)
+			hashsize += DENTPERONEPAGE;
+		else
+			hashsize += (i_size_read(lower_inode) / DENTPAGE) *
+				DENTPERPAGE;
+	}
+
+	return hashsize;
+}
+
+int init_rdstate(struct file *file)
+{
+	BUG_ON(sizeof(loff_t) !=
+	       (sizeof(unsigned int) + sizeof(unsigned int)));
+	BUG_ON(UNIONFS_F(file)->rdstate != NULL);
+
+	UNIONFS_F(file)->rdstate = alloc_rdstate(file->f_path.dentry->d_inode,
+						 fbstart(file));
+
+	return (UNIONFS_F(file)->rdstate ? 0 : -ENOMEM);
+}
+
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos)
+{
+	struct unionfs_dir_state *rdstate = NULL;
+	struct list_head *pos;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	list_for_each(pos, &UNIONFS_I(inode)->readdircache) {
+		struct unionfs_dir_state *r =
+			list_entry(pos, struct unionfs_dir_state, cache);
+		if (fpos == rdstate2offset(r)) {
+			UNIONFS_I(inode)->rdcount--;
+			list_del(&r->cache);
+			rdstate = r;
+			break;
+		}
+	}
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+	return rdstate;
+}
+
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex)
+{
+	int i = 0;
+	int hashsize;
+	unsigned long mallocsize = sizeof(struct unionfs_dir_state);
+	struct unionfs_dir_state *rdstate;
+
+	hashsize = guesstimate_hash_size(inode);
+	mallocsize += hashsize * sizeof(struct list_head);
+	mallocsize = __roundup_pow_of_two(mallocsize);
+
+	/* This should give us about 500 entries anyway. */
+	if (mallocsize > PAGE_SIZE)
+		mallocsize = PAGE_SIZE;
+
+	hashsize = (mallocsize - sizeof(struct unionfs_dir_state)) /
+		sizeof(struct list_head);
+
+	rdstate = kmalloc(mallocsize, GFP_KERNEL);
+	if (unlikely(!rdstate))
+		return NULL;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	if (UNIONFS_I(inode)->cookie >= (MAXRDCOOKIE - 1))
+		UNIONFS_I(inode)->cookie = 1;
+	else
+		UNIONFS_I(inode)->cookie++;
+
+	rdstate->cookie = UNIONFS_I(inode)->cookie;
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+	rdstate->offset = 1;
+	rdstate->access = jiffies;
+	rdstate->bindex = bindex;
+	rdstate->dirpos = 0;
+	rdstate->hashentries = 0;
+	rdstate->size = hashsize;
+	for (i = 0; i < rdstate->size; i++)
+		INIT_LIST_HEAD(&rdstate->list[i]);
+
+	return rdstate;
+}
+
+static void free_filldir_node(struct filldir_node *node)
+{
+	if (node->namelen >= DNAME_INLINE_LEN_MIN)
+		kfree(node->name);
+	kmem_cache_free(unionfs_filldir_cachep, node);
+}
+
+void free_rdstate(struct unionfs_dir_state *state)
+{
+	struct filldir_node *tmp;
+	int i;
+
+	for (i = 0; i < state->size; i++) {
+		struct list_head *head = &(state->list[i]);
+		struct list_head *pos, *n;
+
+		/* traverse the list and deallocate space */
+		list_for_each_safe(pos, n, head) {
+			tmp = list_entry(pos, struct filldir_node, file_list);
+			list_del(&tmp->file_list);
+			free_filldir_node(tmp);
+		}
+	}
+
+	kfree(state);
+}
+
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen,
+				       int is_whiteout)
+{
+	int index;
+	unsigned int hash;
+	struct list_head *head;
+	struct list_head *pos;
+	struct filldir_node *cursor = NULL;
+	int found = 0;
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->size;
+
+	head = &(rdstate->list[index]);
+	list_for_each(pos, head) {
+		cursor = list_entry(pos, struct filldir_node, file_list);
+
+		if (cursor->namelen == namelen && cursor->hash == hash &&
+		    !strncmp(cursor->name, name, namelen)) {
+			/*
+			 * a duplicate exists, and hence no need to create
+			 * entry to the list
+			 */
+			found = 1;
+
+			/*
+			 * if a duplicate is found in this branch, and is
+			 * not due to the caller looking for an entry to
+			 * whiteout, then the file system may be corrupted.
+			 */
+			if (unlikely(!is_whiteout &&
+				     cursor->bindex == rdstate->bindex))
+				printk(KERN_ERR "unionfs: filldir: possible "
+				       "I/O error: a file is duplicated "
+				       "in the same branch %d: %s\n",
+				       rdstate->bindex, cursor->name);
+			break;
+		}
+	}
+
+	if (!found)
+		cursor = NULL;
+
+	return cursor;
+}
+
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout)
+{
+	struct filldir_node *new;
+	unsigned int hash;
+	int index;
+	int err = 0;
+	struct list_head *head;
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->size;
+	head = &(rdstate->list[index]);
+
+	new = kmem_cache_alloc(unionfs_filldir_cachep, GFP_KERNEL);
+	if (unlikely(!new)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&new->file_list);
+	new->namelen = namelen;
+	new->hash = hash;
+	new->bindex = bindex;
+	new->whiteout = whiteout;
+
+	if (namelen < DNAME_INLINE_LEN_MIN) {
+		new->name = new->iname;
+	} else {
+		new->name = kmalloc(namelen + 1, GFP_KERNEL);
+		if (unlikely(!new->name)) {
+			kmem_cache_free(unionfs_filldir_cachep, new);
+			new = NULL;
+			goto out;
+		}
+	}
+
+	memcpy(new->name, name, namelen);
+	new->name[namelen] = '\0';
+
+	rdstate->hashentries++;
+
+	list_add(&(new->file_list), head);
+out:
+	return err;
+}
diff --git a/fs/unionfs/rename.c b/fs/unionfs/rename.c
new file mode 100644
index 0000000..936700e
--- /dev/null
+++ b/fs/unionfs/rename.c
@@ -0,0 +1,517 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * This is a helper function for rename, used when rename ends up with hosed
+ * over dentries and we need to revert.
+ */
+static int unionfs_refresh_lower_dentry(struct dentry *dentry,
+					struct dentry *parent, int bindex)
+{
+	struct dentry *lower_dentry;
+	struct dentry *lower_parent;
+	int err = 0;
+
+	verify_locked(dentry);
+
+	lower_parent = unionfs_lower_dentry_idx(parent, bindex);
+
+	BUG_ON(!S_ISDIR(lower_parent->d_inode->i_mode));
+
+	lower_dentry = lookup_one_len(dentry->d_name.name, lower_parent,
+				      dentry->d_name.len);
+	if (IS_ERR(lower_dentry)) {
+		err = PTR_ERR(lower_dentry);
+		goto out;
+	}
+
+	dput(unionfs_lower_dentry_idx(dentry, bindex));
+	iput(unionfs_lower_inode_idx(dentry->d_inode, bindex));
+	unionfs_set_lower_inode_idx(dentry->d_inode, bindex, NULL);
+
+	if (!lower_dentry->d_inode) {
+		dput(lower_dentry);
+		unionfs_set_lower_dentry_idx(dentry, bindex, NULL);
+	} else {
+		unionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);
+		unionfs_set_lower_inode_idx(dentry->d_inode, bindex,
+					    igrab(lower_dentry->d_inode));
+	}
+
+out:
+	return err;
+}
+
+static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			    struct dentry *old_parent,
+			    struct inode *new_dir, struct dentry *new_dentry,
+			    struct dentry *new_parent,
+			    int bindex)
+{
+	int err = 0;
+	struct dentry *lower_old_dentry;
+	struct dentry *lower_new_dentry;
+	struct dentry *lower_old_dir_dentry;
+	struct dentry *lower_new_dir_dentry;
+	struct dentry *trap;
+
+	lower_new_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
+	lower_old_dentry = unionfs_lower_dentry_idx(old_dentry, bindex);
+
+	if (!lower_new_dentry) {
+		lower_new_dentry =
+			create_parents(new_parent->d_inode,
+				       new_dentry, new_dentry->d_name.name,
+				       bindex);
+		if (IS_ERR(lower_new_dentry)) {
+			err = PTR_ERR(lower_new_dentry);
+			if (IS_COPYUP_ERR(err))
+				goto out;
+			printk(KERN_ERR "unionfs: error creating directory "
+			       "tree for rename, bindex=%d err=%d\n",
+			       bindex, err);
+			goto out;
+		}
+	}
+
+	/* check for and remove whiteout, if any */
+	err = check_unlink_whiteout(new_dentry, lower_new_dentry, bindex);
+	if (err > 0) /* ignore if whiteout found and successfully removed */
+		err = 0;
+	if (err)
+		goto out;
+
+	/* check of old_dentry branch is writable */
+	err = is_robranch_super(old_dentry->d_sb, bindex);
+	if (err)
+		goto out;
+
+	dget(lower_old_dentry);
+	dget(lower_new_dentry);
+	lower_old_dir_dentry = dget_parent(lower_old_dentry);
+	lower_new_dir_dentry = dget_parent(lower_new_dentry);
+
+	trap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+	/* source should not be ancenstor of target */
+	if (trap == lower_old_dentry) {
+		err = -EINVAL;
+		goto out_err_unlock;
+	}
+	/* target should not be ancenstor of source */
+	if (trap == lower_new_dentry) {
+		err = -ENOTEMPTY;
+		goto out_err_unlock;
+	}
+	err = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,
+			 lower_new_dir_dentry->d_inode, lower_new_dentry);
+out_err_unlock:
+	if (!err) {
+		/* update parent dir times */
+		fsstack_copy_attr_times(old_dir, lower_old_dir_dentry->d_inode);
+		fsstack_copy_attr_times(new_dir, lower_new_dir_dentry->d_inode);
+	}
+	unlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);
+
+	dput(lower_old_dir_dentry);
+	dput(lower_new_dir_dentry);
+	dput(lower_old_dentry);
+	dput(lower_new_dentry);
+
+out:
+	if (!err) {
+		/* Fixup the new_dentry. */
+		if (bindex < dbstart(new_dentry))
+			dbstart(new_dentry) = bindex;
+		else if (bindex > dbend(new_dentry))
+			dbend(new_dentry) = bindex;
+	}
+
+	return err;
+}
+
+/*
+ * Main rename code.  This is sufficiently complex, that it's documented in
+ * Documentation/filesystems/unionfs/rename.txt.  This routine calls
+ * __unionfs_rename() above to perform some of the work.
+ */
+static int do_unionfs_rename(struct inode *old_dir,
+			     struct dentry *old_dentry,
+			     struct dentry *old_parent,
+			     struct inode *new_dir,
+			     struct dentry *new_dentry,
+			     struct dentry *new_parent)
+{
+	int err = 0;
+	int bindex;
+	int old_bstart, old_bend;
+	int new_bstart, new_bend;
+	int do_copyup = -1;
+	int local_err = 0;
+	int eio = 0;
+	int revert = 0;
+
+	old_bstart = dbstart(old_dentry);
+	old_bend = dbend(old_dentry);
+
+	new_bstart = dbstart(new_dentry);
+	new_bend = dbend(new_dentry);
+
+	/* Rename source to destination. */
+	err = __unionfs_rename(old_dir, old_dentry, old_parent,
+			       new_dir, new_dentry, new_parent,
+			       old_bstart);
+	if (err) {
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+		do_copyup = old_bstart - 1;
+	} else {
+		revert = 1;
+	}
+
+	/*
+	 * Unlink all instances of destination that exist to the left of
+	 * bstart of source. On error, revert back, goto out.
+	 */
+	for (bindex = old_bstart - 1; bindex >= new_bstart; bindex--) {
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		BUG_ON(bindex < 0);
+		unlink_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);
+		if (!unlink_dentry)
+			continue;
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		err = is_robranch_super(old_dir->i_sb, bindex);
+		if (!err)
+			err = vfs_unlink(unlink_dir_dentry->d_inode,
+					 unlink_dentry);
+
+		fsstack_copy_attr_times(new_parent->d_inode,
+					unlink_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		new_parent->d_inode->i_nlink =
+			unionfs_get_nlinks(new_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+		if (!err) {
+			if (bindex != new_bstart) {
+				dput(unlink_dentry);
+				unionfs_set_lower_dentry_idx(new_dentry,
+							     bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			do_copyup = bindex - 1;
+		} else if (revert) {
+			goto revert;
+		}
+	}
+
+	if (do_copyup != -1) {
+		for (bindex = do_copyup; bindex >= 0; bindex--) {
+			/*
+			 * copyup the file into some left directory, so that
+			 * you can rename it
+			 */
+			err = copyup_dentry(old_parent->d_inode,
+					    old_dentry, old_bstart, bindex,
+					    old_dentry->d_name.name,
+					    old_dentry->d_name.len, NULL,
+					    i_size_read(old_dentry->d_inode));
+			/* if copyup failed, try next branch to the left */
+			if (err)
+				continue;
+			/*
+			 * create whiteout before calling __unionfs_rename
+			 * because the latter will change the old_dentry's
+			 * lower name and parent dir, resulting in the
+			 * whiteout getting created in the wrong dir.
+			 */
+			err = create_whiteout(old_dentry, bindex);
+			if (err) {
+				printk(KERN_ERR "unionfs: can't create a "
+				       "whiteout for %s in rename (err=%d)\n",
+				       old_dentry->d_name.name, err);
+				continue;
+			}
+			err = __unionfs_rename(old_dir, old_dentry, old_parent,
+					       new_dir, new_dentry, new_parent,
+					       bindex);
+			break;
+		}
+	}
+
+	/* make it opaque */
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+		err = make_dir_opaque(old_dentry, dbstart(old_dentry));
+		if (err)
+			goto revert;
+	}
+
+	/*
+	 * Create whiteout for source, only if:
+	 * (1) There is more than one underlying instance of source.
+	 * (We did a copy_up is taken care of above).
+	 */
+	if ((old_bstart != old_bend) && (do_copyup == -1)) {
+		err = create_whiteout(old_dentry, old_bstart);
+		if (err) {
+			/* can't fix anything now, so we exit with -EIO */
+			printk(KERN_ERR "unionfs: can't create a whiteout for "
+			       "%s in rename!\n", old_dentry->d_name.name);
+			err = -EIO;
+		}
+	}
+
+out:
+	return err;
+
+revert:
+	/* Do revert here. */
+	local_err = unionfs_refresh_lower_dentry(new_dentry, new_parent,
+						 old_bstart);
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the new refresh failed\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_lower_dentry(old_dentry, old_parent,
+						 old_bstart);
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the old refresh failed\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (!unionfs_lower_dentry_idx(new_dentry, bindex) ||
+	    !unionfs_lower_dentry_idx(new_dentry, bindex)->d_inode) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the object disappeared from under us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (unionfs_lower_dentry_idx(old_dentry, bindex) &&
+	    unionfs_lower_dentry_idx(old_dentry, bindex)->d_inode) {
+		printk(KERN_ERR "unionfs: revert failed in rename: "
+		       "the object was created underneath us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	local_err = __unionfs_rename(new_dir, new_dentry, new_parent,
+				     old_dir, old_dentry, old_parent,
+				     old_bstart);
+
+	/* If we can't fix it, then we cop-out with -EIO. */
+	if (local_err) {
+		printk(KERN_ERR "unionfs: revert failed in rename!\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_lower_dentry(new_dentry, new_parent,
+						 bindex);
+	if (local_err)
+		eio = -EIO;
+	local_err = unionfs_refresh_lower_dentry(old_dentry, old_parent,
+						 bindex);
+	if (local_err)
+		eio = -EIO;
+
+revert_out:
+	if (eio)
+		err = eio;
+	return err;
+}
+
+/*
+ * We can't copyup a directory, because it may involve huge numbers of
+ * children, etc.  Doing that in the kernel would be bad, so instead we
+ * return EXDEV to the user-space utility that caused this, and let the
+ * user-space recurse and ask us to copy up each file separately.
+ */
+static int may_rename_dir(struct dentry *dentry, struct dentry *parent)
+{
+	int err, bstart;
+
+	err = check_empty(dentry, parent, NULL);
+	if (err == -ENOTEMPTY) {
+		if (is_robranch(dentry))
+			return -EXDEV;
+	} else if (err) {
+		return err;
+	}
+
+	bstart = dbstart(dentry);
+	if (dbend(dentry) == bstart || dbopaque(dentry) == bstart)
+		return 0;
+
+	dbstart(dentry) = bstart + 1;
+	err = check_empty(dentry, parent, NULL);
+	dbstart(dentry) = bstart;
+	if (err == -ENOTEMPTY)
+		err = -EXDEV;
+	return err;
+}
+
+/*
+ * The locking rules in unionfs_rename are complex.  We could use a simpler
+ * superblock-level name-space lock for renames and copy-ups.
+ */
+int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *wh_dentry;
+	struct dentry *old_parent, *new_parent;
+	int valid = true;
+
+	unionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	old_parent = dget_parent(old_dentry);
+	new_parent = dget_parent(new_dentry);
+	/* un/lock parent dentries only if they differ from old/new_dentry */
+	if (old_parent != old_dentry &&
+	    old_parent != new_dentry)
+		unionfs_lock_dentry(old_parent, UNIONFS_DMUTEX_REVAL_PARENT);
+	if (new_parent != old_dentry &&
+	    new_parent != new_dentry &&
+	    new_parent != old_parent)
+		unionfs_lock_dentry(new_parent, UNIONFS_DMUTEX_REVAL_CHILD);
+	unionfs_double_lock_dentry(old_dentry, new_dentry);
+
+	valid = __unionfs_d_revalidate(old_dentry, old_parent, false);
+	if (!valid) {
+		err = -ESTALE;
+		goto out;
+	}
+	if (!d_deleted(new_dentry) && new_dentry->d_inode) {
+		valid = __unionfs_d_revalidate(new_dentry, new_parent, false);
+		if (!valid) {
+			err = -ESTALE;
+			goto out;
+		}
+	}
+
+	if (!S_ISDIR(old_dentry->d_inode->i_mode))
+		err = unionfs_partial_lookup(old_dentry, old_parent);
+	else
+		err = may_rename_dir(old_dentry, old_parent);
+
+	if (err)
+		goto out;
+
+	err = unionfs_partial_lookup(new_dentry, new_parent);
+	if (err)
+		goto out;
+
+	/*
+	 * if new_dentry is already lower because of whiteout,
+	 * simply override it even if the whited-out dir is not empty.
+	 */
+	wh_dentry = find_first_whiteout(new_dentry);
+	if (!IS_ERR(wh_dentry)) {
+		dput(wh_dentry);
+	} else if (new_dentry->d_inode) {
+		if (S_ISDIR(old_dentry->d_inode->i_mode) !=
+		    S_ISDIR(new_dentry->d_inode->i_mode)) {
+			err = S_ISDIR(old_dentry->d_inode->i_mode) ?
+				-ENOTDIR : -EISDIR;
+			goto out;
+		}
+
+		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
+			struct unionfs_dir_state *namelist = NULL;
+			/* check if this unionfs directory is empty or not */
+			err = check_empty(new_dentry, new_parent, &namelist);
+			if (err)
+				goto out;
+
+			if (!is_robranch(new_dentry))
+				err = delete_whiteouts(new_dentry,
+						       dbstart(new_dentry),
+						       namelist);
+
+			free_rdstate(namelist);
+
+			if (err)
+				goto out;
+		}
+	}
+
+	err = do_unionfs_rename(old_dir, old_dentry, old_parent,
+				new_dir, new_dentry, new_parent);
+	if (err)
+		goto out;
+
+	/*
+	 * force re-lookup since the dir on ro branch is not renamed, and
+	 * lower dentries still indicate the un-renamed ones.
+	 */
+	if (S_ISDIR(old_dentry->d_inode->i_mode))
+		atomic_dec(&UNIONFS_D(old_dentry)->generation);
+	else
+		unionfs_postcopyup_release(old_dentry);
+	if (new_dentry->d_inode && !S_ISDIR(new_dentry->d_inode->i_mode)) {
+		unionfs_postcopyup_release(new_dentry);
+		unionfs_postcopyup_setmnt(new_dentry);
+		if (!unionfs_lower_inode(new_dentry->d_inode)) {
+			/*
+			 * If we get here, it means that no copyup was
+			 * needed, and that a file by the old name already
+			 * existing on the destination branch; that file got
+			 * renamed earlier in this function, so all we need
+			 * to do here is set the lower inode.
+			 */
+			struct inode *inode;
+			inode = unionfs_lower_inode(old_dentry->d_inode);
+			igrab(inode);
+			unionfs_set_lower_inode_idx(new_dentry->d_inode,
+						    dbstart(new_dentry),
+						    inode);
+		}
+	}
+	/* if all of this renaming succeeded, update our times */
+	unionfs_copy_attr_times(old_dentry->d_inode);
+	unionfs_copy_attr_times(new_dentry->d_inode);
+	unionfs_check_inode(old_dir);
+	unionfs_check_inode(new_dir);
+	unionfs_check_dentry(old_dentry);
+	unionfs_check_dentry(new_dentry);
+
+out:
+	if (err)		/* clear the new_dentry stuff created */
+		d_drop(new_dentry);
+
+	unionfs_double_unlock_dentry(old_dentry, new_dentry);
+	if (new_parent != old_dentry &&
+	    new_parent != new_dentry &&
+	    new_parent != old_parent)
+		unionfs_unlock_dentry(new_parent);
+	if (old_parent != old_dentry &&
+	    old_parent != new_dentry)
+		unionfs_unlock_dentry(old_parent);
+	dput(new_parent);
+	dput(old_parent);
+	unionfs_read_unlock(old_dentry->d_sb);
+
+	return err;
+}
diff --git a/fs/unionfs/sioq.c b/fs/unionfs/sioq.c
new file mode 100644
index 0000000..760c580
--- /dev/null
+++ b/fs/unionfs/sioq.c
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2006-2010 Erez Zadok
+ * Copyright (c) 2006      Charles P. Wright
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006      Junjiro Okajima
+ * Copyright (c) 2006      David P. Quigley
+ * Copyright (c) 2006-2010 Stony Brook University
+ * Copyright (c) 2006-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Super-user IO work Queue - sometimes we need to perform actions which
+ * would fail due to the unix permissions on the parent directory (e.g.,
+ * rmdir a directory which appears empty, but in reality contains
+ * whiteouts).
+ */
+
+static struct workqueue_struct *superio_workqueue;
+
+int __init init_sioq(void)
+{
+	int err;
+
+	superio_workqueue = create_workqueue("unionfs_siod");
+	if (!IS_ERR(superio_workqueue))
+		return 0;
+
+	err = PTR_ERR(superio_workqueue);
+	printk(KERN_ERR "unionfs: create_workqueue failed %d\n", err);
+	superio_workqueue = NULL;
+	return err;
+}
+
+void stop_sioq(void)
+{
+	if (superio_workqueue)
+		destroy_workqueue(superio_workqueue);
+}
+
+void run_sioq(work_func_t func, struct sioq_args *args)
+{
+	INIT_WORK(&args->work, func);
+
+	init_completion(&args->comp);
+	while (!queue_work(superio_workqueue, &args->work)) {
+		/* TODO: do accounting if needed */
+		schedule();
+	}
+	wait_for_completion(&args->comp);
+}
+
+void __unionfs_create(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct create_args *c = &args->create;
+
+	args->err = vfs_create(c->parent, c->dentry, c->mode, c->nd);
+	complete(&args->comp);
+}
+
+void __unionfs_mkdir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct mkdir_args *m = &args->mkdir;
+
+	args->err = vfs_mkdir(m->parent, m->dentry, m->mode);
+	complete(&args->comp);
+}
+
+void __unionfs_mknod(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct mknod_args *m = &args->mknod;
+
+	args->err = vfs_mknod(m->parent, m->dentry, m->mode, m->dev);
+	complete(&args->comp);
+}
+
+void __unionfs_symlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct symlink_args *s = &args->symlink;
+
+	args->err = vfs_symlink(s->parent, s->dentry, s->symbuf);
+	complete(&args->comp);
+}
+
+void __unionfs_unlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct unlink_args *u = &args->unlink;
+
+	args->err = vfs_unlink(u->parent, u->dentry);
+	complete(&args->comp);
+}
diff --git a/fs/unionfs/sioq.h b/fs/unionfs/sioq.h
new file mode 100644
index 0000000..b26d248
--- /dev/null
+++ b/fs/unionfs/sioq.h
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2006-2010 Erez Zadok
+ * Copyright (c) 2006      Charles P. Wright
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006      Junjiro Okajima
+ * Copyright (c) 2006      David P. Quigley
+ * Copyright (c) 2006-2010 Stony Brook University
+ * Copyright (c) 2006-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _SIOQ_H
+#define _SIOQ_H
+
+struct deletewh_args {
+	struct unionfs_dir_state *namelist;
+	struct dentry *dentry;
+	int bindex;
+};
+
+struct is_opaque_args {
+	struct dentry *dentry;
+};
+
+struct create_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	struct nameidata *nd;
+};
+
+struct mkdir_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+};
+
+struct mknod_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	dev_t dev;
+};
+
+struct symlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	char *symbuf;
+};
+
+struct unlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+};
+
+
+struct sioq_args {
+	struct completion comp;
+	struct work_struct work;
+	int err;
+	void *ret;
+
+	union {
+		struct deletewh_args deletewh;
+		struct is_opaque_args is_opaque;
+		struct create_args create;
+		struct mkdir_args mkdir;
+		struct mknod_args mknod;
+		struct symlink_args symlink;
+		struct unlink_args unlink;
+	};
+};
+
+/* Extern definitions for SIOQ functions */
+extern int __init init_sioq(void);
+extern void stop_sioq(void);
+extern void run_sioq(work_func_t func, struct sioq_args *args);
+
+/* Extern definitions for our privilege escalation helpers */
+extern void __unionfs_create(struct work_struct *work);
+extern void __unionfs_mkdir(struct work_struct *work);
+extern void __unionfs_mknod(struct work_struct *work);
+extern void __unionfs_symlink(struct work_struct *work);
+extern void __unionfs_unlink(struct work_struct *work);
+extern void __delete_whiteouts(struct work_struct *work);
+extern void __is_opaque_dir(struct work_struct *work);
+
+#endif /* not _SIOQ_H */
diff --git a/fs/unionfs/subr.c b/fs/unionfs/subr.c
new file mode 100644
index 0000000..570a344
--- /dev/null
+++ b/fs/unionfs/subr.c
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * returns the right n_link value based on the inode type
+ */
+int unionfs_get_nlinks(const struct inode *inode)
+{
+	/* don't bother to do all the work since we're unlinked */
+	if (inode->i_nlink == 0)
+		return 0;
+
+	if (!S_ISDIR(inode->i_mode))
+		return unionfs_lower_inode(inode)->i_nlink;
+
+	/*
+	 * For directories, we return 1. The only place that could cares
+	 * about links is readdir, and there's d_type there so even that
+	 * doesn't matter.
+	 */
+	return 1;
+}
+
+/* copy a/m/ctime from the lower branch with the newest times */
+void unionfs_copy_attr_times(struct inode *upper)
+{
+	int bindex;
+	struct inode *lower;
+
+	if (!upper)
+		return;
+	if (ibstart(upper) < 0) {
+#ifdef CONFIG_UNION_FS_DEBUG
+		WARN_ON(ibstart(upper) < 0);
+#endif /* CONFIG_UNION_FS_DEBUG */
+		return;
+	}
+	for (bindex = ibstart(upper); bindex <= ibend(upper); bindex++) {
+		lower = unionfs_lower_inode_idx(upper, bindex);
+		if (!lower)
+			continue; /* not all lower dir objects may exist */
+		if (unlikely(timespec_compare(&upper->i_mtime,
+					      &lower->i_mtime) < 0))
+			upper->i_mtime = lower->i_mtime;
+		if (unlikely(timespec_compare(&upper->i_ctime,
+					      &lower->i_ctime) < 0))
+			upper->i_ctime = lower->i_ctime;
+		if (unlikely(timespec_compare(&upper->i_atime,
+					      &lower->i_atime) < 0))
+			upper->i_atime = lower->i_atime;
+	}
+}
+
+/*
+ * A unionfs/fanout version of fsstack_copy_attr_all.  Uses a
+ * unionfs_get_nlinks to properly calcluate the number of links to a file.
+ * Also, copies the max() of all a/m/ctimes for all lower inodes (which is
+ * important if the lower inode is a directory type)
+ */
+void unionfs_copy_attr_all(struct inode *dest,
+			   const struct inode *src)
+{
+	dest->i_mode = src->i_mode;
+	dest->i_uid = src->i_uid;
+	dest->i_gid = src->i_gid;
+	dest->i_rdev = src->i_rdev;
+
+	unionfs_copy_attr_times(dest);
+
+	dest->i_blkbits = src->i_blkbits;
+	dest->i_flags = src->i_flags;
+
+	/*
+	 * Update the nlinks AFTER updating the above fields, because the
+	 * get_links callback may depend on them.
+	 */
+	dest->i_nlink = unionfs_get_nlinks(dest);
+}
diff --git a/fs/unionfs/super.c b/fs/unionfs/super.c
new file mode 100644
index 0000000..bd058fe
--- /dev/null
+++ b/fs/unionfs/super.c
@@ -0,0 +1,1047 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * The inode cache is used with alloc_inode for both our inode info and the
+ * vfs inode.
+ */
+static struct kmem_cache *unionfs_inode_cachep;
+
+struct inode *unionfs_iget(struct super_block *sb, unsigned long ino)
+{
+	int size;
+	struct unionfs_inode_info *info;
+	struct inode *inode;
+
+	inode = iget_locked(sb, ino);
+	if (!inode)
+		return ERR_PTR(-ENOMEM);
+	if (!(inode->i_state & I_NEW))
+		return inode;
+
+	info = UNIONFS_I(inode);
+	memset(info, 0, offsetof(struct unionfs_inode_info, vfs_inode));
+	info->bstart = -1;
+	info->bend = -1;
+	atomic_set(&info->generation,
+		   atomic_read(&UNIONFS_SB(inode->i_sb)->generation));
+	spin_lock_init(&info->rdlock);
+	info->rdcount = 1;
+	info->hashsize = -1;
+	INIT_LIST_HEAD(&info->readdircache);
+
+	size = sbmax(inode->i_sb) * sizeof(struct inode *);
+	info->lower_inodes = kzalloc(size, GFP_KERNEL);
+	if (unlikely(!info->lower_inodes)) {
+		printk(KERN_CRIT "unionfs: no kernel memory when allocating "
+		       "lower-pointer array!\n");
+		iget_failed(inode);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	inode->i_version++;
+	inode->i_op = &unionfs_main_iops;
+	inode->i_fop = &unionfs_main_fops;
+
+	inode->i_mapping->a_ops = &unionfs_aops;
+
+	/*
+	 * reset times so unionfs_copy_attr_all can keep out time invariants
+	 * right (upper inode time being the max of all lower ones).
+	 */
+	inode->i_atime.tv_sec = inode->i_atime.tv_nsec = 0;
+	inode->i_mtime.tv_sec = inode->i_mtime.tv_nsec = 0;
+	inode->i_ctime.tv_sec = inode->i_ctime.tv_nsec = 0;
+	unlock_new_inode(inode);
+	return inode;
+}
+
+/*
+ * we now define delete_inode, because there are two VFS paths that may
+ * destroy an inode: one of them calls clear inode before doing everything
+ * else that's needed, and the other is fine.  This way we truncate the inode
+ * size (and its pages) and then clear our own inode, which will do an iput
+ * on our and the lower inode.
+ *
+ * No need to lock sb info's rwsem.
+ */
+static void unionfs_delete_inode(struct inode *inode)
+{
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	spin_lock(&inode->i_lock);
+#endif
+	i_size_write(inode, 0);	/* every f/s seems to do that */
+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)
+	spin_unlock(&inode->i_lock);
+#endif
+
+	if (inode->i_data.nrpages)
+		truncate_inode_pages(&inode->i_data, 0);
+
+	clear_inode(inode);
+}
+
+/*
+ * final actions when unmounting a file system
+ *
+ * No need to lock rwsem.
+ */
+static void unionfs_put_super(struct super_block *sb)
+{
+	int bindex, bstart, bend;
+	struct unionfs_sb_info *spd;
+	int leaks = 0;
+
+	spd = UNIONFS_SB(sb);
+	if (!spd)
+		return;
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	/* Make sure we have no leaks of branchget/branchput. */
+	for (bindex = bstart; bindex <= bend; bindex++)
+		if (unlikely(branch_count(sb, bindex) != 0)) {
+			printk(KERN_CRIT
+			       "unionfs: branch %d has %d references left!\n",
+			       bindex, branch_count(sb, bindex));
+			leaks = 1;
+		}
+	WARN_ON(leaks != 0);
+
+	/* decrement lower super references */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct super_block *s;
+		s = unionfs_lower_super_idx(sb, bindex);
+		unionfs_set_lower_super_idx(sb, bindex, NULL);
+		atomic_dec(&s->s_active);
+	}
+
+	kfree(spd->dev_name);
+	kfree(spd->data);
+	kfree(spd);
+	sb->s_fs_info = NULL;
+}
+
+/*
+ * Since people use this to answer the "How big of a file can I write?"
+ * question, we report the size of the highest priority branch as the size of
+ * the union.
+ */
+static int unionfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	int err	= 0;
+	struct super_block *sb;
+	struct dentry *lower_dentry;
+	struct dentry *parent;
+	bool valid;
+
+	sb = dentry->d_sb;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	lower_dentry = unionfs_lower_dentry(sb->s_root);
+	err = vfs_statfs(lower_dentry, buf);
+
+	/* set return buf to our f/s to avoid confusing user-level utils */
+	buf->f_type = UNIONFS_SUPER_MAGIC;
+	/*
+	 * Our maximum file name can is shorter by a few bytes because every
+	 * file name could potentially be whited-out.
+	 *
+	 * XXX: this restriction goes away with ODF.
+	 */
+	unionfs_set_max_namelen(&buf->f_namelen);
+
+	/*
+	 * reset two fields to avoid confusing user-land.
+	 * XXX: is this still necessary?
+	 */
+	memset(&buf->f_fsid, 0, sizeof(__kernel_fsid_t));
+	memset(&buf->f_spare, 0, sizeof(buf->f_spare));
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(sb);
+	return err;
+}
+
+/* handle mode changing during remount */
+static noinline_for_stack int do_remount_mode_option(
+					char *optarg,
+					int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths)
+{
+	int err = -EINVAL;
+	int perms, idx;
+	char *modename = strchr(optarg, '=');
+	struct nameidata nd;
+
+	/* by now, optarg contains the branch name */
+	if (!*optarg) {
+		printk(KERN_ERR
+		       "unionfs: no branch specified for mode change\n");
+		goto out;
+	}
+	if (!modename) {
+		printk(KERN_ERR "unionfs: branch \"%s\" requires a mode\n",
+		       optarg);
+		goto out;
+	}
+	*modename++ = '\0';
+	err = parse_branch_mode(modename, &perms);
+	if (err) {
+		printk(KERN_ERR "unionfs: invalid mode \"%s\" for \"%s\"\n",
+		       modename, optarg);
+		goto out;
+	}
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		err = -ENOENT;	/* err may have been reset above */
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		goto out;
+	}
+	/* check/change mode for existing branch */
+	/* we don't warn if perms==branchperms */
+	new_data[idx].branchperms = perms;
+	err = 0;
+out:
+	return err;
+}
+
+/* handle branch deletion during remount */
+static noinline_for_stack int do_remount_del_option(
+					char *optarg, int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths)
+{
+	int err = -EINVAL;
+	int idx;
+	struct nameidata nd;
+
+	/* optarg contains the branch name to delete */
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		err = -ENOENT;
+		goto out;
+	}
+	/* check if there are any open files on the branch to be deleted */
+	if (atomic_read(&new_data[idx].open_files) > 0) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * Now we have to delete the branch.  First, release any handles it
+	 * has.  Then, move the remaining array indexes past "idx" in
+	 * new_data and new_lower_paths one to the left.  Finally, adjust
+	 * cur_branches.
+	 */
+	path_put(&new_lower_paths[idx]);
+
+	if (idx < cur_branches - 1) {
+		/* if idx==cur_branches-1, we delete last branch: easy */
+		memmove(&new_data[idx], &new_data[idx+1],
+			(cur_branches - 1 - idx) *
+			sizeof(struct unionfs_data));
+		memmove(&new_lower_paths[idx], &new_lower_paths[idx+1],
+			(cur_branches - 1 - idx) * sizeof(struct path));
+	}
+
+	err = 0;
+out:
+	return err;
+}
+
+/* handle branch insertion during remount */
+static noinline_for_stack int do_remount_add_option(
+					char *optarg, int cur_branches,
+					struct unionfs_data *new_data,
+					struct path *new_lower_paths,
+					int *high_branch_id)
+{
+	int err = -EINVAL;
+	int perms;
+	int idx = 0;		/* default: insert at beginning */
+	char *new_branch , *modename = NULL;
+	struct nameidata nd;
+
+	/*
+	 * optarg can be of several forms:
+	 *
+	 * /bar:/foo		insert /foo before /bar
+	 * /bar:/foo=ro		insert /foo in ro mode before /bar
+	 * /foo			insert /foo in the beginning (prepend)
+	 * :/foo		insert /foo at the end (append)
+	 */
+	if (*optarg == ':') {	/* append? */
+		new_branch = optarg + 1; /* skip ':' */
+		idx = cur_branches;
+		goto found_insertion_point;
+	}
+	new_branch = strchr(optarg, ':');
+	if (!new_branch) {	/* prepend? */
+		new_branch = optarg;
+		goto found_insertion_point;
+	}
+	*new_branch++ = '\0';	/* holds path+mode of new branch */
+
+	/*
+	 * Find matching branch index.  For now, this assumes that nothing
+	 * has been mounted on top of this Unionfs stack.  Once we have /odf
+	 * and cache-coherency resolved, we'll address the branch-path
+	 * uniqueness.
+	 */
+	err = path_lookup(optarg, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       optarg, err);
+		goto out;
+	}
+	for (idx = 0; idx < cur_branches; idx++)
+		if (nd.path.mnt == new_lower_paths[idx].mnt &&
+		    nd.path.dentry == new_lower_paths[idx].dentry)
+			break;
+	path_put(&nd.path);	/* no longer needed */
+	if (idx == cur_branches) {
+		printk(KERN_ERR "unionfs: branch \"%s\" "
+		       "not found\n", optarg);
+		err = -ENOENT;
+		goto out;
+	}
+
+	/*
+	 * At this point idx will hold the index where the new branch should
+	 * be inserted before.
+	 */
+found_insertion_point:
+	/* find the mode for the new branch */
+	if (new_branch)
+		modename = strchr(new_branch, '=');
+	if (modename)
+		*modename++ = '\0';
+	if (!new_branch || !*new_branch) {
+		printk(KERN_ERR "unionfs: null new branch\n");
+		err = -EINVAL;
+		goto out;
+	}
+	err = parse_branch_mode(modename, &perms);
+	if (err) {
+		printk(KERN_ERR "unionfs: invalid mode \"%s\" for "
+		       "branch \"%s\"\n", modename, new_branch);
+		goto out;
+	}
+	err = path_lookup(new_branch, LOOKUP_FOLLOW, &nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: error accessing "
+		       "lower directory \"%s\" (error %d)\n",
+		       new_branch, err);
+		goto out;
+	}
+	/*
+	 * It's probably safe to check_mode the new branch to insert.  Note:
+	 * we don't allow inserting branches which are unionfs's by
+	 * themselves (check_branch returns EINVAL in that case).  This is
+	 * because this code base doesn't support stacking unionfs: the ODF
+	 * code base supports that correctly.
+	 */
+	err = check_branch(&nd);
+	if (err) {
+		printk(KERN_ERR "unionfs: lower directory "
+		       "\"%s\" is not a valid branch\n", optarg);
+		path_put(&nd.path);
+		goto out;
+	}
+
+	/*
+	 * Now we have to insert the new branch.  But first, move the bits
+	 * to make space for the new branch, if needed.  Finally, adjust
+	 * cur_branches.
+	 * We don't release nd here; it's kept until umount/remount.
+	 */
+	if (idx < cur_branches) {
+		/* if idx==cur_branches, we append: easy */
+		memmove(&new_data[idx+1], &new_data[idx],
+			(cur_branches - idx) * sizeof(struct unionfs_data));
+		memmove(&new_lower_paths[idx+1], &new_lower_paths[idx],
+			(cur_branches - idx) * sizeof(struct path));
+	}
+	new_lower_paths[idx].dentry = nd.path.dentry;
+	new_lower_paths[idx].mnt = nd.path.mnt;
+
+	new_data[idx].sb = nd.path.dentry->d_sb;
+	atomic_set(&new_data[idx].open_files, 0);
+	new_data[idx].branchperms = perms;
+	new_data[idx].branch_id = ++*high_branch_id; /* assign new branch ID */
+
+	err = 0;
+out:
+	return err;
+}
+
+
+/*
+ * Support branch management options on remount.
+ *
+ * See Documentation/filesystems/unionfs/ for details.
+ *
+ * @flags: numeric mount options
+ * @options: mount options string
+ *
+ * This function can rearrange a mounted union dynamically, adding and
+ * removing branches, including changing branch modes.  Clearly this has to
+ * be done safely and atomically.  Luckily, the VFS already calls this
+ * function with lock_super(sb) and lock_kernel() held, preventing
+ * concurrent mixing of new mounts, remounts, and unmounts.  Moreover,
+ * do_remount_sb(), our caller function, already called shrink_dcache_sb(sb)
+ * to purge dentries/inodes from our superblock, and also called
+ * fsync_super(sb) to purge any dirty pages.  So we're good.
+ *
+ * XXX: however, our remount code may also need to invalidate mapped pages
+ * so as to force them to be re-gotten from the (newly reconfigured) lower
+ * branches.  This has to wait for proper mmap and cache coherency support
+ * in the VFS.
+ *
+ */
+static int unionfs_remount_fs(struct super_block *sb, int *flags,
+			      char *options)
+{
+	int err = 0;
+	int i;
+	char *optionstmp, *tmp_to_free;	/* kstrdup'ed of "options" */
+	char *optname;
+	int cur_branches = 0;	/* no. of current branches */
+	int new_branches = 0;	/* no. of branches actually left in the end */
+	int add_branches;	/* est. no. of branches to add */
+	int del_branches;	/* est. no. of branches to del */
+	int max_branches;	/* max possible no. of branches */
+	struct unionfs_data *new_data = NULL, *tmp_data = NULL;
+	struct path *new_lower_paths = NULL, *tmp_lower_paths = NULL;
+	struct inode **new_lower_inodes = NULL;
+	int new_high_branch_id;	/* new high branch ID */
+	int size;		/* memory allocation size, temp var */
+	int old_ibstart, old_ibend;
+
+	unionfs_write_lock(sb);
+
+	/*
+	 * The VFS will take care of "ro" and "rw" flags, and we can safely
+	 * ignore MS_SILENT, but anything else left over is an error.  So we
+	 * need to check if any other flags may have been passed (none are
+	 * allowed/supported as of now).
+	 */
+	if ((*flags & ~(MS_RDONLY | MS_SILENT)) != 0) {
+		printk(KERN_ERR
+		       "unionfs: remount flags 0x%x unsupported\n", *flags);
+		err = -EINVAL;
+		goto out_error;
+	}
+
+	/*
+	 * If 'options' is NULL, it's probably because the user just changed
+	 * the union to a "ro" or "rw" and the VFS took care of it.  So
+	 * nothing to do and we're done.
+	 */
+	if (!options || options[0] == '\0')
+		goto out_error;
+
+	/*
+	 * Find out how many branches we will have in the end, counting
+	 * "add" and "del" commands.  Copy the "options" string because
+	 * strsep modifies the string and we need it later.
+	 */
+	tmp_to_free = kstrdup(options, GFP_KERNEL);
+	optionstmp = tmp_to_free;
+	if (unlikely(!optionstmp)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	cur_branches = sbmax(sb); /* current no. branches */
+	new_branches = sbmax(sb);
+	del_branches = 0;
+	add_branches = 0;
+	new_high_branch_id = sbhbid(sb); /* save current high_branch_id */
+	while ((optname = strsep(&optionstmp, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+
+		if (!strcmp("add", optname))
+			add_branches++;
+		else if (!strcmp("del", optname))
+			del_branches++;
+	}
+	kfree(tmp_to_free);
+	/* after all changes, will we have at least one branch left? */
+	if ((new_branches + add_branches - del_branches) < 1) {
+		printk(KERN_ERR
+		       "unionfs: no branches left after remount\n");
+		err = -EINVAL;
+		goto out_free;
+	}
+
+	/*
+	 * Since we haven't actually parsed all the add/del options, nor
+	 * have we checked them for errors, we don't know for sure how many
+	 * branches we will have after all changes have taken place.  In
+	 * fact, the total number of branches left could be less than what
+	 * we have now.  So we need to allocate space for a temporary
+	 * placeholder that is at least as large as the maximum number of
+	 * branches we *could* have, which is the current number plus all
+	 * the additions.  Once we're done with these temp placeholders, we
+	 * may have to re-allocate the final size, copy over from the temp,
+	 * and then free the temps (done near the end of this function).
+	 */
+	max_branches = cur_branches + add_branches;
+	/* allocate space for new pointers to lower dentry */
+	tmp_data = kcalloc(max_branches,
+			   sizeof(struct unionfs_data), GFP_KERNEL);
+	if (unlikely(!tmp_data)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	/* allocate space for new pointers to lower paths */
+	tmp_lower_paths = kcalloc(max_branches,
+				  sizeof(struct path), GFP_KERNEL);
+	if (unlikely(!tmp_lower_paths)) {
+		err = -ENOMEM;
+		goto out_free;
+	}
+	/* copy current info into new placeholders, incrementing refcnts */
+	memcpy(tmp_data, UNIONFS_SB(sb)->data,
+	       cur_branches * sizeof(struct unionfs_data));
+	memcpy(tmp_lower_paths, UNIONFS_D(sb->s_root)->lower_paths,
+	       cur_branches * sizeof(struct path));
+	for (i = 0; i < cur_branches; i++)
+		path_get(&tmp_lower_paths[i]); /* drop refs at end of fxn */
+
+	/*******************************************************************
+	 * For each branch command, do path_lookup on the requested branch,
+	 * and apply the change to a temp branch list.  To handle errors, we
+	 * already dup'ed the old arrays (above), and increased the refcnts
+	 * on various f/s objects.  So now we can do all the path_lookups
+	 * and branch-management commands on the new arrays.  If it fail mid
+	 * way, we free the tmp arrays and *put all objects.  If we succeed,
+	 * then we free old arrays and *put its objects, and then replace
+	 * the arrays with the new tmp list (we may have to re-allocate the
+	 * memory because the temp lists could have been larger than what we
+	 * actually needed).
+	 *******************************************************************/
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+
+		if (!optname || !*optname)
+			continue;
+		/*
+		 * At this stage optname holds a comma-delimited option, but
+		 * without the commas.  Next, we need to break the string on
+		 * the '=' symbol to separate CMD=ARG, where ARG itself can
+		 * be KEY=VAL.  For example, in mode=/foo=rw, CMD is "mode",
+		 * KEY is "/foo", and VAL is "rw".
+		 */
+		optarg = strchr(optname, '=');
+		if (optarg)
+			*optarg++ = '\0';
+		/* incgen remount option (instead of old ioctl) */
+		if (!strcmp("incgen", optname)) {
+			err = 0;
+			goto out_no_change;
+		}
+
+		/*
+		 * All of our options take an argument now.  (Insert ones
+		 * that don't above this check.)  So at this stage optname
+		 * contains the CMD part and optarg contains the ARG part.
+		 */
+		if (!optarg || !*optarg) {
+			printk(KERN_ERR "unionfs: all remount options require "
+			       "an argument (%s)\n", optname);
+			err = -EINVAL;
+			goto out_release;
+		}
+
+		if (!strcmp("add", optname)) {
+			err = do_remount_add_option(optarg, new_branches,
+						    tmp_data,
+						    tmp_lower_paths,
+						    &new_high_branch_id);
+			if (err)
+				goto out_release;
+			new_branches++;
+			if (new_branches > UNIONFS_MAX_BRANCHES) {
+				printk(KERN_ERR "unionfs: command exceeds "
+				       "%d branches\n", UNIONFS_MAX_BRANCHES);
+				err = -E2BIG;
+				goto out_release;
+			}
+			continue;
+		}
+		if (!strcmp("del", optname)) {
+			err = do_remount_del_option(optarg, new_branches,
+						    tmp_data,
+						    tmp_lower_paths);
+			if (err)
+				goto out_release;
+			new_branches--;
+			continue;
+		}
+		if (!strcmp("mode", optname)) {
+			err = do_remount_mode_option(optarg, new_branches,
+						     tmp_data,
+						     tmp_lower_paths);
+			if (err)
+				goto out_release;
+			continue;
+		}
+
+		/*
+		 * When you use "mount -o remount,ro", mount(8) will
+		 * reportedly pass the original dirs= string from
+		 * /proc/mounts.  So for now, we have to ignore dirs= and
+		 * not consider it an error, unless we want to allow users
+		 * to pass dirs= in remount.  Note that to allow the VFS to
+		 * actually process the ro/rw remount options, we have to
+		 * return 0 from this function.
+		 */
+		if (!strcmp("dirs", optname)) {
+			printk(KERN_WARNING
+			       "unionfs: remount ignoring option \"%s\"\n",
+			       optname);
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_ERR
+		       "unionfs: unrecognized option \"%s\"\n", optname);
+		goto out_release;
+	}
+
+out_no_change:
+
+	/******************************************************************
+	 * WE'RE ALMOST DONE: check if leftmost branch might be read-only,
+	 * see if we need to allocate a small-sized new vector, copy the
+	 * vectors to their correct place, release the refcnt of the older
+	 * ones, and return.  Also handle invalidating any pages that will
+	 * have to be re-read.
+	 *******************************************************************/
+
+	if (!(tmp_data[0].branchperms & MAY_WRITE)) {
+		printk(KERN_ERR "unionfs: leftmost branch cannot be read-only "
+		       "(use \"remount,ro\" to create a read-only union)\n");
+		err = -EINVAL;
+		goto out_release;
+	}
+
+	/* (re)allocate space for new pointers to lower dentry */
+	size = new_branches * sizeof(struct unionfs_data);
+	new_data = krealloc(tmp_data, size, GFP_KERNEL);
+	if (unlikely(!new_data)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/* allocate space for new pointers to lower paths */
+	size = new_branches * sizeof(struct path);
+	new_lower_paths = krealloc(tmp_lower_paths, size, GFP_KERNEL);
+	if (unlikely(!new_lower_paths)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/* allocate space for new pointers to lower inodes */
+	new_lower_inodes = kcalloc(new_branches,
+				   sizeof(struct inode *), GFP_KERNEL);
+	if (unlikely(!new_lower_inodes)) {
+		err = -ENOMEM;
+		goto out_release;
+	}
+
+	/*
+	 * OK, just before we actually put the new set of branches in place,
+	 * we need to ensure that our own f/s has no dirty objects left.
+	 * Luckily, do_remount_sb() already calls shrink_dcache_sb(sb) and
+	 * fsync_super(sb), taking care of dentries, inodes, and dirty
+	 * pages.  So all that's left is for us to invalidate any leftover
+	 * (non-dirty) pages to ensure that they will be re-read from the
+	 * new lower branches (and to support mmap).
+	 */
+
+	/*
+	 * Once we finish the remounting successfully, our superblock
+	 * generation number will have increased.  This will be detected by
+	 * our dentry-revalidation code upon subsequent f/s operations
+	 * through unionfs.  The revalidation code will rebuild the union of
+	 * lower inodes for a given unionfs inode and invalidate any pages
+	 * of such "stale" inodes (by calling our purge_inode_data
+	 * function).  This revalidation will happen lazily and
+	 * incrementally, as users perform operations on cached inodes.  We
+	 * would like to encourage this revalidation to happen sooner if
+	 * possible, so we like to try to invalidate as many other pages in
+	 * our superblock as we can.  We used to call drop_pagecache_sb() or
+	 * a variant thereof, but either method was racy (drop_caches alone
+	 * is known to be racy).  So now we let the revalidation happen on a
+	 * per file basis in ->d_revalidate.
+	 */
+
+	/* grab new lower super references; release old ones */
+	for (i = 0; i < new_branches; i++)
+		atomic_inc(&new_data[i].sb->s_active);
+	for (i = 0; i < sbmax(sb); i++)
+		atomic_dec(&UNIONFS_SB(sb)->data[i].sb->s_active);
+
+	/* copy new vectors into their correct place */
+	tmp_data = UNIONFS_SB(sb)->data;
+	UNIONFS_SB(sb)->data = new_data;
+	new_data = NULL;	/* so don't free good pointers below */
+	tmp_lower_paths = UNIONFS_D(sb->s_root)->lower_paths;
+	UNIONFS_D(sb->s_root)->lower_paths = new_lower_paths;
+	new_lower_paths = NULL;	/* so don't free good pointers below */
+
+	/* update our unionfs_sb_info and root dentry index of last branch */
+	i = sbmax(sb);		/* save no. of branches to release at end */
+	sbend(sb) = new_branches - 1;
+	dbend(sb->s_root) = new_branches - 1;
+	old_ibstart = ibstart(sb->s_root->d_inode);
+	old_ibend = ibend(sb->s_root->d_inode);
+	ibend(sb->s_root->d_inode) = new_branches - 1;
+	UNIONFS_D(sb->s_root)->bcount = new_branches;
+	new_branches = i; /* no. of branches to release below */
+
+	/*
+	 * Update lower inodes: 3 steps
+	 * 1. grab ref on all new lower inodes
+	 */
+	for (i = dbstart(sb->s_root); i <= dbend(sb->s_root); i++) {
+		struct dentry *lower_dentry =
+			unionfs_lower_dentry_idx(sb->s_root, i);
+		igrab(lower_dentry->d_inode);
+		new_lower_inodes[i] = lower_dentry->d_inode;
+	}
+	/* 2. release reference on all older lower inodes */
+	iput_lowers(sb->s_root->d_inode, old_ibstart, old_ibend, true);
+	/* 3. update root dentry's inode to new lower_inodes array */
+	UNIONFS_I(sb->s_root->d_inode)->lower_inodes = new_lower_inodes;
+	new_lower_inodes = NULL;
+
+	/* maxbytes may have changed */
+	sb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;
+	/* update high branch ID */
+	sbhbid(sb) = new_high_branch_id;
+
+	/* update our sb->generation for revalidating objects */
+	i = atomic_inc_return(&UNIONFS_SB(sb)->generation);
+	atomic_set(&UNIONFS_D(sb->s_root)->generation, i);
+	atomic_set(&UNIONFS_I(sb->s_root->d_inode)->generation, i);
+	if (!(*flags & MS_SILENT))
+		pr_info("unionfs: %s: new generation number %d\n",
+			UNIONFS_SB(sb)->dev_name, i);
+	/* finally, update the root dentry's times */
+	unionfs_copy_attr_times(sb->s_root->d_inode);
+	err = 0;		/* reset to success */
+
+	/*
+	 * The code above falls through to the next label, and releases the
+	 * refcnts of the older ones (stored in tmp_*): if we fell through
+	 * here, it means success.  However, if we jump directly to this
+	 * label from any error above, then an error occurred after we
+	 * grabbed various refcnts, and so we have to release the
+	 * temporarily constructed structures.
+	 */
+out_release:
+	/* no need to cleanup/release anything in tmp_data */
+	if (tmp_lower_paths)
+		for (i = 0; i < new_branches; i++)
+			path_put(&tmp_lower_paths[i]);
+out_free:
+	kfree(tmp_lower_paths);
+	kfree(tmp_data);
+	kfree(new_lower_paths);
+	kfree(new_data);
+	kfree(new_lower_inodes);
+out_error:
+	unionfs_check_dentry(sb->s_root);
+	unionfs_write_unlock(sb);
+	return err;
+}
+
+/*
+ * Called by iput() when the inode reference count reached zero
+ * and the inode is not hashed anywhere.  Used to clear anything
+ * that needs to be, before the inode is completely destroyed and put
+ * on the inode free list.
+ *
+ * No need to lock sb info's rwsem.
+ */
+static void unionfs_clear_inode(struct inode *inode)
+{
+	int bindex, bstart, bend;
+	struct inode *lower_inode;
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	list_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, cache);
+		list_del(&rdstate->cache);
+		free_rdstate(rdstate);
+	}
+
+	/*
+	 * Decrement a reference to a lower_inode, which was incremented
+	 * by our read_inode when it was created initially.
+	 */
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (bstart >= 0) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			lower_inode = unionfs_lower_inode_idx(inode, bindex);
+			if (!lower_inode)
+				continue;
+			unionfs_set_lower_inode_idx(inode, bindex, NULL);
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			iput(lower_inode);
+			lockdep_on();
+		}
+	}
+
+	kfree(UNIONFS_I(inode)->lower_inodes);
+	UNIONFS_I(inode)->lower_inodes = NULL;
+}
+
+static struct inode *unionfs_alloc_inode(struct super_block *sb)
+{
+	struct unionfs_inode_info *i;
+
+	i = kmem_cache_alloc(unionfs_inode_cachep, GFP_KERNEL);
+	if (unlikely(!i))
+		return NULL;
+
+	/* memset everything up to the inode to 0 */
+	memset(i, 0, offsetof(struct unionfs_inode_info, vfs_inode));
+
+	i->vfs_inode.i_version = 1;
+	return &i->vfs_inode;
+}
+
+static void unionfs_destroy_inode(struct inode *inode)
+{
+	kmem_cache_free(unionfs_inode_cachep, UNIONFS_I(inode));
+}
+
+/* unionfs inode cache constructor */
+static void init_once(void *obj)
+{
+	struct unionfs_inode_info *i = obj;
+
+	inode_init_once(&i->vfs_inode);
+}
+
+int unionfs_init_inode_cache(void)
+{
+	int err = 0;
+
+	unionfs_inode_cachep =
+		kmem_cache_create("unionfs_inode_cache",
+				  sizeof(struct unionfs_inode_info), 0,
+				  SLAB_RECLAIM_ACCOUNT, init_once);
+	if (unlikely(!unionfs_inode_cachep))
+		err = -ENOMEM;
+	return err;
+}
+
+/* unionfs inode cache destructor */
+void unionfs_destroy_inode_cache(void)
+{
+	if (unionfs_inode_cachep)
+		kmem_cache_destroy(unionfs_inode_cachep);
+}
+
+/*
+ * Called when we have a dirty inode, right here we only throw out
+ * parts of our readdir list that are too old.
+ *
+ * No need to grab sb info's rwsem.
+ */
+static int unionfs_write_inode(struct inode *inode, int sync)
+{
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	spin_lock(&UNIONFS_I(inode)->rdlock);
+	list_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, cache);
+		/* We keep this list in LRU order. */
+		if ((rdstate->access + RDCACHE_JIFFIES) > jiffies)
+			break;
+		UNIONFS_I(inode)->rdcount--;
+		list_del(&rdstate->cache);
+		free_rdstate(rdstate);
+	}
+	spin_unlock(&UNIONFS_I(inode)->rdlock);
+
+	return 0;
+}
+
+/*
+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent
+ * code can actually succeed and won't leave tasks that need handling.
+ */
+static void unionfs_umount_begin(struct super_block *sb)
+{
+	struct super_block *lower_sb;
+	int bindex, bstart, bend;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_sb = unionfs_lower_super_idx(sb, bindex);
+
+		if (lower_sb && lower_sb->s_op &&
+		    lower_sb->s_op->umount_begin)
+			lower_sb->s_op->umount_begin(lower_sb);
+	}
+
+	unionfs_read_unlock(sb);
+}
+
+static int unionfs_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct super_block *sb = mnt->mnt_sb;
+	int ret = 0;
+	char *tmp_page;
+	char *path;
+	int bindex, bstart, bend;
+	int perms;
+
+	unionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);
+
+	unionfs_lock_dentry(sb->s_root, UNIONFS_DMUTEX_CHILD);
+
+	tmp_page = (char *) __get_free_page(GFP_KERNEL);
+	if (unlikely(!tmp_page)) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	seq_printf(m, ",dirs=");
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct path p;
+		p.dentry = unionfs_lower_dentry_idx(sb->s_root, bindex);
+		p.mnt = unionfs_lower_mnt_idx(sb->s_root, bindex);
+		path = d_path(&p, tmp_page, PAGE_SIZE);
+		if (IS_ERR(path)) {
+			ret = PTR_ERR(path);
+			goto out;
+		}
+
+		perms = branchperms(sb, bindex);
+
+		seq_printf(m, "%s=%s", path,
+			   perms & MAY_WRITE ? "rw" : "ro");
+		if (bindex != bend)
+			seq_printf(m, ":");
+	}
+
+out:
+	free_page((unsigned long) tmp_page);
+
+	unionfs_unlock_dentry(sb->s_root);
+
+	unionfs_read_unlock(sb);
+
+	return ret;
+}
+
+struct super_operations unionfs_sops = {
+	.delete_inode	= unionfs_delete_inode,
+	.put_super	= unionfs_put_super,
+	.statfs		= unionfs_statfs,
+	.remount_fs	= unionfs_remount_fs,
+	.clear_inode	= unionfs_clear_inode,
+	.umount_begin	= unionfs_umount_begin,
+	.show_options	= unionfs_show_options,
+	.write_inode	= unionfs_write_inode,
+	.alloc_inode	= unionfs_alloc_inode,
+	.destroy_inode	= unionfs_destroy_inode,
+};
diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h
new file mode 100644
index 0000000..99335a3
--- /dev/null
+++ b/fs/unionfs/union.h
@@ -0,0 +1,670 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _UNION_H_
+#define _UNION_H_
+
+#include <linux/dcache.h>
+#include <linux/file.h>
+#include <linux/list.h>
+#include <linux/fs.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/namei.h>
+#include <linux/page-flags.h>
+#include <linux/pagemap.h>
+#include <linux/poll.h>
+#include <linux/security.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+#include <linux/statfs.h>
+#include <linux/string.h>
+#include <linux/vmalloc.h>
+#include <linux/writeback.h>
+#include <linux/buffer_head.h>
+#include <linux/xattr.h>
+#include <linux/fs_stack.h>
+#include <linux/magic.h>
+#include <linux/log2.h>
+#include <linux/poison.h>
+#include <linux/mman.h>
+#include <linux/backing-dev.h>
+#include <linux/splice.h>
+
+#include <asm/system.h>
+
+#include <linux/union_fs.h>
+
+/* the file system name */
+#define UNIONFS_NAME "unionfs"
+
+/* unionfs root inode number */
+#define UNIONFS_ROOT_INO     1
+
+/* number of times we try to get a unique temporary file name */
+#define GET_TMPNAM_MAX_RETRY	5
+
+/* maximum number of branches we support, to avoid memory blowup */
+#define UNIONFS_MAX_BRANCHES	128
+
+/* minimum time (seconds) required for time-based cache-coherency */
+#define UNIONFS_MIN_CC_TIME	3
+
+/* Operations vectors defined in specific files. */
+extern struct file_operations unionfs_main_fops;
+extern struct file_operations unionfs_dir_fops;
+extern struct inode_operations unionfs_main_iops;
+extern struct inode_operations unionfs_dir_iops;
+extern struct inode_operations unionfs_symlink_iops;
+extern struct super_operations unionfs_sops;
+extern struct dentry_operations unionfs_dops;
+extern struct address_space_operations unionfs_aops, unionfs_dummy_aops;
+extern struct vm_operations_struct unionfs_vm_ops;
+
+/* How long should an entry be allowed to persist */
+#define RDCACHE_JIFFIES	(5*HZ)
+
+/* compatibility with Real-Time patches */
+#ifdef CONFIG_PREEMPT_RT
+# define unionfs_rw_semaphore	compat_rw_semaphore
+#else /* not CONFIG_PREEMPT_RT */
+# define unionfs_rw_semaphore	rw_semaphore
+#endif /* not CONFIG_PREEMPT_RT */
+
+/* file private data. */
+struct unionfs_file_info {
+	int bstart;
+	int bend;
+	atomic_t generation;
+
+	struct unionfs_dir_state *rdstate;
+	struct file **lower_files;
+	int *saved_branch_ids; /* IDs of branches when file was opened */
+	const struct vm_operations_struct *lower_vm_ops;
+	bool wrote_to_file;	/* for delayed copyup */
+};
+
+/* unionfs inode data in memory */
+struct unionfs_inode_info {
+	int bstart;
+	int bend;
+	atomic_t generation;
+	/* Stuff for readdir over NFS. */
+	spinlock_t rdlock;
+	struct list_head readdircache;
+	int rdcount;
+	int hashsize;
+	int cookie;
+
+	/* The lower inodes */
+	struct inode **lower_inodes;
+
+	struct inode vfs_inode;
+};
+
+/* unionfs dentry data in memory */
+struct unionfs_dentry_info {
+	/*
+	 * The semaphore is used to lock the dentry as soon as we get into a
+	 * unionfs function from the VFS.  Our lock ordering is that children
+	 * go before their parents.
+	 */
+	struct mutex lock;
+	int bstart;
+	int bend;
+	int bopaque;
+	int bcount;
+	atomic_t generation;
+	struct path *lower_paths;
+};
+
+/* These are the pointers to our various objects. */
+struct unionfs_data {
+	struct super_block *sb;	/* lower super_block */
+	atomic_t open_files;	/* number of open files on branch */
+	int branchperms;
+	int branch_id;		/* unique branch ID at re/mount time */
+};
+
+/* unionfs super-block data in memory */
+struct unionfs_sb_info {
+	int bend;
+
+	atomic_t generation;
+
+	/*
+	 * This rwsem is used to make sure that a branch management
+	 * operation...
+	 *   1) will not begin before all currently in-flight operations
+	 *      complete.
+	 *   2) any new operations do not execute until the currently
+	 *      running branch management operation completes.
+	 *
+	 * The write_lock_owner records the PID of the task which grabbed
+	 * the rw_sem for writing.  If the same task also tries to grab the
+	 * read lock, we allow it.  This prevents a self-deadlock when
+	 * branch-management is used on a pivot_root'ed union, because we
+	 * have to ->lookup paths which belong to the same union.
+	 */
+	struct unionfs_rw_semaphore rwsem;
+	pid_t write_lock_owner;	/* PID of rw_sem owner (write lock) */
+	int high_branch_id;	/* last unique branch ID given */
+	char *dev_name;		/* to identify different unions in pr_debug */
+	struct unionfs_data *data;
+};
+
+/*
+ * structure for making the linked list of entries by readdir on left branch
+ * to compare with entries on right branch
+ */
+struct filldir_node {
+	struct list_head file_list;	/* list for directory entries */
+	char *name;		/* name entry */
+	int hash;		/* name hash */
+	int namelen;		/* name len since name is not 0 terminated */
+
+	/*
+	 * we can check for duplicate whiteouts and files in the same branch
+	 * in order to return -EIO.
+	 */
+	int bindex;
+
+	/* is this a whiteout entry? */
+	int whiteout;
+
+	/* Inline name, so we don't need to separately kmalloc small ones */
+	char iname[DNAME_INLINE_LEN_MIN];
+};
+
+/* Directory hash table. */
+struct unionfs_dir_state {
+	unsigned int cookie;	/* the cookie, based off of rdversion */
+	unsigned int offset;	/* The entry we have returned. */
+	int bindex;
+	loff_t dirpos;		/* offset within the lower level directory */
+	int size;		/* How big is the hash table? */
+	int hashentries;	/* How many entries have been inserted? */
+	unsigned long access;
+
+	/* This cache list is used when the inode keeps us around. */
+	struct list_head cache;
+	struct list_head list[0];
+};
+
+/* externs needed for fanout.h or sioq.h */
+extern int unionfs_get_nlinks(const struct inode *inode);
+extern void unionfs_copy_attr_times(struct inode *upper);
+extern void unionfs_copy_attr_all(struct inode *dest, const struct inode *src);
+
+/* include miscellaneous macros */
+#include "fanout.h"
+#include "sioq.h"
+
+/* externs for cache creation/deletion routines */
+extern void unionfs_destroy_filldir_cache(void);
+extern int unionfs_init_filldir_cache(void);
+extern int unionfs_init_inode_cache(void);
+extern void unionfs_destroy_inode_cache(void);
+extern int unionfs_init_dentry_cache(void);
+extern void unionfs_destroy_dentry_cache(void);
+
+/* Initialize and free readdir-specific  state. */
+extern int init_rdstate(struct file *file);
+extern struct unionfs_dir_state *alloc_rdstate(struct inode *inode,
+					       int bindex);
+extern struct unionfs_dir_state *find_rdstate(struct inode *inode,
+					      loff_t fpos);
+extern void free_rdstate(struct unionfs_dir_state *state);
+extern int add_filldir_node(struct unionfs_dir_state *rdstate,
+			    const char *name, int namelen, int bindex,
+			    int whiteout);
+extern struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+					      const char *name, int namelen,
+					      int is_whiteout);
+
+extern struct dentry **alloc_new_dentries(int objs);
+extern struct unionfs_data *alloc_new_data(int objs);
+
+/* We can only use 32-bits of offset for rdstate --- blech! */
+#define DIREOF (0xfffff)
+#define RDOFFBITS 20		/* This is the number of bits in DIREOF. */
+#define MAXRDCOOKIE (0xfff)
+/* Turn an rdstate into an offset. */
+static inline off_t rdstate2offset(struct unionfs_dir_state *buf)
+{
+	off_t tmp;
+
+	tmp = ((buf->cookie & MAXRDCOOKIE) << RDOFFBITS)
+		| (buf->offset & DIREOF);
+	return tmp;
+}
+
+/* Macros for locking a super_block. */
+enum unionfs_super_lock_class {
+	UNIONFS_SMUTEX_NORMAL,
+	UNIONFS_SMUTEX_PARENT,	/* when locking on behalf of file */
+	UNIONFS_SMUTEX_CHILD,	/* when locking on behalf of dentry */
+};
+static inline void unionfs_read_lock(struct super_block *sb, int subclass)
+{
+	if (UNIONFS_SB(sb)->write_lock_owner &&
+	    UNIONFS_SB(sb)->write_lock_owner == current->pid)
+		return;
+	down_read_nested(&UNIONFS_SB(sb)->rwsem, subclass);
+}
+static inline void unionfs_read_unlock(struct super_block *sb)
+{
+	if (UNIONFS_SB(sb)->write_lock_owner &&
+	    UNIONFS_SB(sb)->write_lock_owner == current->pid)
+		return;
+	up_read(&UNIONFS_SB(sb)->rwsem);
+}
+static inline void unionfs_write_lock(struct super_block *sb)
+{
+	down_write(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->write_lock_owner = current->pid;
+}
+static inline void unionfs_write_unlock(struct super_block *sb)
+{
+	up_write(&UNIONFS_SB(sb)->rwsem);
+	UNIONFS_SB(sb)->write_lock_owner = 0;
+}
+
+static inline void unionfs_double_lock_dentry(struct dentry *d1,
+					      struct dentry *d2)
+{
+	BUG_ON(d1 == d2);
+	if (d1 < d2) {
+		unionfs_lock_dentry(d1, UNIONFS_DMUTEX_PARENT);
+		unionfs_lock_dentry(d2, UNIONFS_DMUTEX_CHILD);
+	} else {
+		unionfs_lock_dentry(d2, UNIONFS_DMUTEX_PARENT);
+		unionfs_lock_dentry(d1, UNIONFS_DMUTEX_CHILD);
+	}
+}
+
+static inline void unionfs_double_unlock_dentry(struct dentry *d1,
+						struct dentry *d2)
+{
+	BUG_ON(d1 == d2);
+	if (d1 < d2) { /* unlock in reverse order than double_lock_dentry */
+		unionfs_unlock_dentry(d1);
+		unionfs_unlock_dentry(d2);
+	} else {
+		unionfs_unlock_dentry(d2);
+		unionfs_unlock_dentry(d1);
+	}
+}
+
+static inline void unionfs_double_lock_parents(struct dentry *p1,
+					       struct dentry *p2)
+{
+	if (p1 == p2) {
+		unionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_PARENT);
+		return;
+	}
+	if (p1 < p2) {
+		unionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_PARENT);
+		unionfs_lock_dentry(p2, UNIONFS_DMUTEX_REVAL_CHILD);
+	} else {
+		unionfs_lock_dentry(p2, UNIONFS_DMUTEX_REVAL_PARENT);
+		unionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_CHILD);
+	}
+}
+
+static inline void unionfs_double_unlock_parents(struct dentry *p1,
+						 struct dentry *p2)
+{
+	if (p1 == p2) {
+		unionfs_unlock_dentry(p1);
+		return;
+	}
+	if (p1 < p2) { /* unlock in reverse order of double_lock_parents */
+		unionfs_unlock_dentry(p1);
+		unionfs_unlock_dentry(p2);
+	} else {
+		unionfs_unlock_dentry(p2);
+		unionfs_unlock_dentry(p1);
+	}
+}
+
+extern int new_dentry_private_data(struct dentry *dentry, int subclass);
+extern int realloc_dentry_private_data(struct dentry *dentry);
+extern void free_dentry_private_data(struct dentry *dentry);
+extern void update_bstart(struct dentry *dentry);
+extern int init_lower_nd(struct nameidata *nd, unsigned int flags);
+extern void release_lower_nd(struct nameidata *nd, int err);
+
+/*
+ * EXTERNALS:
+ */
+
+/* replicates the directory structure up to given dentry in given branch */
+extern struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+				     const char *name, int bindex);
+
+/* partial lookup */
+extern int unionfs_partial_lookup(struct dentry *dentry,
+				  struct dentry *parent);
+extern struct dentry *unionfs_lookup_full(struct dentry *dentry,
+					  struct dentry *parent,
+					  int lookupmode);
+
+/* copies a file from dbstart to newbindex branch */
+extern int copyup_file(struct inode *dir, struct file *file, int bstart,
+		       int newbindex, loff_t size);
+extern int copyup_named_file(struct inode *dir, struct file *file,
+			     char *name, int bstart, int new_bindex,
+			     loff_t len);
+/* copies a dentry from dbstart to newbindex branch */
+extern int copyup_dentry(struct inode *dir, struct dentry *dentry,
+			 int bstart, int new_bindex, const char *name,
+			 int namelen, struct file **copyup_file, loff_t len);
+/* helper functions for post-copyup actions */
+extern void unionfs_postcopyup_setmnt(struct dentry *dentry);
+extern void unionfs_postcopyup_release(struct dentry *dentry);
+
+/* Is this directory empty: 0 if it is empty, -ENOTEMPTY if not. */
+extern int check_empty(struct dentry *dentry, struct dentry *parent,
+		       struct unionfs_dir_state **namelist);
+/* whiteout and opaque directory helpers */
+extern char *alloc_whname(const char *name, int len);
+extern bool is_whiteout_name(char **namep, int *namelenp);
+extern bool is_validname(const char *name);
+extern struct dentry *lookup_whiteout(const char *name,
+				      struct dentry *lower_parent);
+extern struct dentry *find_first_whiteout(struct dentry *dentry);
+extern int unlink_whiteout(struct dentry *wh_dentry);
+extern int check_unlink_whiteout(struct dentry *dentry,
+				 struct dentry *lower_dentry, int bindex);
+extern int create_whiteout(struct dentry *dentry, int start);
+extern int delete_whiteouts(struct dentry *dentry, int bindex,
+			    struct unionfs_dir_state *namelist);
+extern int is_opaque_dir(struct dentry *dentry, int bindex);
+extern int make_dir_opaque(struct dentry *dir, int bindex);
+extern void unionfs_set_max_namelen(long *namelen);
+
+extern void unionfs_reinterpose(struct dentry *this_dentry);
+extern struct super_block *unionfs_duplicate_super(struct super_block *sb);
+
+/* Locking functions. */
+extern int unionfs_setlk(struct file *file, int cmd, struct file_lock *fl);
+extern int unionfs_getlk(struct file *file, struct file_lock *fl);
+
+/* Common file operations. */
+extern int unionfs_file_revalidate(struct file *file, struct dentry *parent,
+				   bool willwrite);
+extern int unionfs_open(struct inode *inode, struct file *file);
+extern int unionfs_file_release(struct inode *inode, struct file *file);
+extern int unionfs_flush(struct file *file, fl_owner_t id);
+extern long unionfs_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg);
+extern int unionfs_fsync(struct file *file, struct dentry *dentry,
+			 int datasync);
+extern int unionfs_fasync(int fd, struct file *file, int flag);
+
+/* Inode operations */
+extern struct inode *unionfs_iget(struct super_block *sb, unsigned long ino);
+extern int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry);
+extern int unionfs_unlink(struct inode *dir, struct dentry *dentry);
+extern int unionfs_rmdir(struct inode *dir, struct dentry *dentry);
+
+extern bool __unionfs_d_revalidate(struct dentry *dentry,
+				   struct dentry *parent, bool willwrite);
+extern bool is_negative_lower(const struct dentry *dentry);
+extern bool is_newer_lower(const struct dentry *dentry);
+extern void purge_sb_data(struct super_block *sb);
+
+/* The values for unionfs_interpose's flag. */
+#define INTERPOSE_DEFAULT	0
+#define INTERPOSE_LOOKUP	1
+#define INTERPOSE_REVAL		2
+#define INTERPOSE_REVAL_NEG	3
+#define INTERPOSE_PARTIAL	4
+
+extern struct dentry *unionfs_interpose(struct dentry *this_dentry,
+					struct super_block *sb, int flag);
+
+#ifdef CONFIG_UNION_FS_XATTR
+/* Extended attribute functions. */
+extern void *unionfs_xattr_alloc(size_t size, size_t limit);
+static inline void unionfs_xattr_kfree(const void *p)
+{
+	kfree(p);
+}
+extern ssize_t unionfs_getxattr(struct dentry *dentry, const char *name,
+				void *value, size_t size);
+extern int unionfs_removexattr(struct dentry *dentry, const char *name);
+extern ssize_t unionfs_listxattr(struct dentry *dentry, char *list,
+				 size_t size);
+extern int unionfs_setxattr(struct dentry *dentry, const char *name,
+			    const void *value, size_t size, int flags);
+#endif /* CONFIG_UNION_FS_XATTR */
+
+/* The root directory is unhashed, but isn't deleted. */
+static inline int d_deleted(struct dentry *d)
+{
+	return d_unhashed(d) && (d != d->d_sb->s_root);
+}
+
+/* unionfs_permission, check if we should bypass error to facilitate copyup */
+#define IS_COPYUP_ERR(err) ((err) == -EROFS)
+
+/* unionfs_open, check if we need to copyup the file */
+#define OPEN_WRITE_FLAGS (O_WRONLY | O_RDWR | O_APPEND)
+#define IS_WRITE_FLAG(flag) ((flag) & OPEN_WRITE_FLAGS)
+
+static inline int branchperms(const struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+	return UNIONFS_SB(sb)->data[index].branchperms;
+}
+
+static inline int set_branchperms(struct super_block *sb, int index, int perms)
+{
+	BUG_ON(index < 0);
+	UNIONFS_SB(sb)->data[index].branchperms = perms;
+	return perms;
+}
+
+/* check if readonly lower inode, but possibly unlinked (no inode->i_sb) */
+static inline int __is_rdonly(const struct inode *inode)
+{
+	/* if unlinked, can't be readonly (?) */
+	if (!inode->i_sb)
+		return 0;
+	return IS_RDONLY(inode);
+
+}
+/* Is this file on a read-only branch? */
+static inline int is_robranch_super(const struct super_block *sb, int index)
+{
+	int ret;
+
+	ret = (!(branchperms(sb, index) & MAY_WRITE)) ? -EROFS : 0;
+	return ret;
+}
+
+/* Is this file on a read-only branch? */
+static inline int is_robranch_idx(const struct dentry *dentry, int index)
+{
+	struct super_block *lower_sb;
+
+	BUG_ON(index < 0);
+
+	if (!(branchperms(dentry->d_sb, index) & MAY_WRITE))
+		return -EROFS;
+
+	lower_sb = unionfs_lower_super_idx(dentry->d_sb, index);
+	BUG_ON(lower_sb == NULL);
+	/*
+	 * test sb flags directly, not IS_RDONLY(lower_inode) because the
+	 * lower_dentry could be a negative.
+	 */
+	if (lower_sb->s_flags & MS_RDONLY)
+		return -EROFS;
+
+	return 0;
+}
+
+static inline int is_robranch(const struct dentry *dentry)
+{
+	int index;
+
+	index = UNIONFS_D(dentry)->bstart;
+	BUG_ON(index < 0);
+
+	return is_robranch_idx(dentry, index);
+}
+
+/*
+ * EXTERNALS:
+ */
+extern int check_branch(struct nameidata *nd);
+extern int parse_branch_mode(const char *name, int *perms);
+
+/* locking helpers */
+static inline struct dentry *lock_parent(struct dentry *dentry)
+{
+	struct dentry *dir = dget_parent(dentry);
+	mutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);
+	return dir;
+}
+static inline struct dentry *lock_parent_wh(struct dentry *dentry)
+{
+	struct dentry *dir = dget_parent(dentry);
+
+	mutex_lock_nested(&dir->d_inode->i_mutex, UNIONFS_DMUTEX_WHITEOUT);
+	return dir;
+}
+
+static inline void unlock_dir(struct dentry *dir)
+{
+	mutex_unlock(&dir->d_inode->i_mutex);
+	dput(dir);
+}
+
+/* lock base inode mutex before calling lookup_one_len */
+static inline struct dentry *lookup_lck_len(const char *name,
+					    struct dentry *base, int len)
+{
+	struct dentry *d;
+	mutex_lock(&base->d_inode->i_mutex);
+	d = lookup_one_len(name, base, len);
+	mutex_unlock(&base->d_inode->i_mutex);
+	return d;
+}
+
+static inline struct vfsmount *unionfs_mntget(struct dentry *dentry,
+					      int bindex)
+{
+	struct vfsmount *mnt;
+
+	BUG_ON(!dentry || bindex < 0);
+
+	mnt = mntget(unionfs_lower_mnt_idx(dentry, bindex));
+#ifdef CONFIG_UNION_FS_DEBUG
+	if (!mnt)
+		pr_debug("unionfs: mntget: mnt=%p bindex=%d\n",
+			 mnt, bindex);
+#endif /* CONFIG_UNION_FS_DEBUG */
+
+	return mnt;
+}
+
+static inline void unionfs_mntput(struct dentry *dentry, int bindex)
+{
+	struct vfsmount *mnt;
+
+	if (!dentry && bindex < 0)
+		return;
+	BUG_ON(!dentry || bindex < 0);
+
+	mnt = unionfs_lower_mnt_idx(dentry, bindex);
+#ifdef CONFIG_UNION_FS_DEBUG
+	/*
+	 * Directories can have NULL lower objects in between start/end, but
+	 * NOT if at the start/end range.  We cannot verify that this dentry
+	 * is a type=DIR, because it may already be a negative dentry.  But
+	 * if dbstart is greater than dbend, we know that this couldn't have
+	 * been a regular file: it had to have been a directory.
+	 */
+	if (!mnt && !(bindex > dbstart(dentry) && bindex < dbend(dentry)))
+		pr_debug("unionfs: mntput: mnt=%p bindex=%d\n", mnt, bindex);
+#endif /* CONFIG_UNION_FS_DEBUG */
+	mntput(mnt);
+}
+
+#ifdef CONFIG_UNION_FS_DEBUG
+
+/* useful for tracking code reachability */
+#define UDBG pr_debug("DBG:%s:%s:%d\n", __FILE__, __func__, __LINE__)
+
+#define unionfs_check_inode(i)	__unionfs_check_inode((i),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_dentry(d)	__unionfs_check_dentry((d),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_file(f)	__unionfs_check_file((f),	\
+	__FILE__, __func__, __LINE__)
+#define unionfs_check_nd(n)	__unionfs_check_nd((n),		\
+	__FILE__, __func__, __LINE__)
+#define show_branch_counts(sb)	__show_branch_counts((sb),	\
+	__FILE__, __func__, __LINE__)
+#define show_inode_times(i)	__show_inode_times((i),		\
+	__FILE__, __func__, __LINE__)
+#define show_dinode_times(d)	__show_dinode_times((d),	\
+	__FILE__, __func__, __LINE__)
+#define show_inode_counts(i)	__show_inode_counts((i),	\
+	__FILE__, __func__, __LINE__)
+
+extern void __unionfs_check_inode(const struct inode *inode, const char *fname,
+				  const char *fxn, int line);
+extern void __unionfs_check_dentry(const struct dentry *dentry,
+				   const char *fname, const char *fxn,
+				   int line);
+extern void __unionfs_check_file(const struct file *file,
+				 const char *fname, const char *fxn, int line);
+extern void __unionfs_check_nd(const struct nameidata *nd,
+			       const char *fname, const char *fxn, int line);
+extern void __show_branch_counts(const struct super_block *sb,
+				 const char *file, const char *fxn, int line);
+extern void __show_inode_times(const struct inode *inode,
+			       const char *file, const char *fxn, int line);
+extern void __show_dinode_times(const struct dentry *dentry,
+				const char *file, const char *fxn, int line);
+extern void __show_inode_counts(const struct inode *inode,
+				const char *file, const char *fxn, int line);
+
+#else /* not CONFIG_UNION_FS_DEBUG */
+
+/* we leave useful hooks for these check functions throughout the code */
+#define unionfs_check_inode(i)		do { } while (0)
+#define unionfs_check_dentry(d)		do { } while (0)
+#define unionfs_check_file(f)		do { } while (0)
+#define unionfs_check_nd(n)		do { } while (0)
+#define show_branch_counts(sb)		do { } while (0)
+#define show_inode_times(i)		do { } while (0)
+#define show_dinode_times(d)		do { } while (0)
+#define show_inode_counts(i)		do { } while (0)
+
+#endif /* not CONFIG_UNION_FS_DEBUG */
+
+#endif	/* not _UNION_H_ */
diff --git a/fs/unionfs/unlink.c b/fs/unionfs/unlink.c
new file mode 100644
index 0000000..542c513
--- /dev/null
+++ b/fs/unionfs/unlink.c
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * Helper function for Unionfs's unlink operation.
+ *
+ * The main goal of this function is to optimize the unlinking of non-dir
+ * objects in unionfs by deleting all possible lower inode objects from the
+ * underlying branches having same dentry name as the non-dir dentry on
+ * which this unlink operation is called.  This way we delete as many lower
+ * inodes as possible, and save space.  Whiteouts need to be created in
+ * branch0 only if unlinking fails on any of the lower branch other than
+ * branch0, or if a lower branch is marked read-only.
+ *
+ * Also, while unlinking a file, if we encounter any dir type entry in any
+ * intermediate branch, then we remove the directory by calling vfs_rmdir.
+ * The following special cases are also handled:
+
+ * (1) If an error occurs in branch0 during vfs_unlink, then we return
+ *     appropriate error.
+ *
+ * (2) If we get an error during unlink in any of other lower branch other
+ *     than branch0, then we create a whiteout in branch0.
+ *
+ * (3) If a whiteout already exists in any intermediate branch, we delete
+ *     all possible inodes only up to that branch (this is an "opaqueness"
+ *     as as per Documentation/filesystems/unionfs/concepts.txt).
+ *
+ */
+static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry,
+				   struct dentry *parent)
+{
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry;
+	int bindex;
+	int err = 0;
+
+	err = unionfs_partial_lookup(dentry, parent);
+	if (err)
+		goto out;
+
+	/* trying to unlink all possible valid instances */
+	for (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+		if (!lower_dentry || !lower_dentry->d_inode)
+			continue;
+
+		lower_dir_dentry = lock_parent(lower_dentry);
+
+		/* avoid destroying the lower inode if the object is in use */
+		dget(lower_dentry);
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (!err) {
+			/* see Documentation/filesystems/unionfs/issues.txt */
+			lockdep_off();
+			if (!S_ISDIR(lower_dentry->d_inode->i_mode))
+				err = vfs_unlink(lower_dir_dentry->d_inode,
+								lower_dentry);
+			else
+				err = vfs_rmdir(lower_dir_dentry->d_inode,
+								lower_dentry);
+			lockdep_on();
+		}
+
+		/* if lower object deletion succeeds, update inode's times */
+		if (!err)
+			unionfs_copy_attr_times(dentry->d_inode);
+		dput(lower_dentry);
+		fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+		unlock_dir(lower_dir_dentry);
+
+		if (err)
+			break;
+	}
+
+	/*
+	 * Create the whiteout in branch 0 (highest priority) only if (a)
+	 * there was an error in any intermediate branch other than branch 0
+	 * due to failure of vfs_unlink/vfs_rmdir or (b) a branch marked or
+	 * mounted read-only.
+	 */
+	if (err) {
+		if ((bindex == 0) ||
+		    ((bindex == dbstart(dentry)) &&
+		     (!IS_COPYUP_ERR(err))))
+			goto out;
+		else {
+			if (!IS_COPYUP_ERR(err))
+				pr_debug("unionfs: lower object deletion "
+					     "failed in branch:%d\n", bindex);
+			err = create_whiteout(dentry, sbstart(dentry->d_sb));
+		}
+	}
+
+out:
+	if (!err)
+		inode_dec_link_count(dentry->d_inode);
+
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	return err;
+}
+
+int unionfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct inode *inode = dentry->d_inode;
+	struct dentry *parent;
+	int valid;
+
+	BUG_ON(S_ISDIR(inode->i_mode));
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	err = unionfs_unlink_whiteout(dir, dentry, parent);
+	/* call d_drop so the system "forgets" about us */
+	if (!err) {
+		unionfs_postcopyup_release(dentry);
+		unionfs_postcopyup_setmnt(parent);
+		if (inode->i_nlink == 0) /* drop lower inodes */
+			iput_lowers_all(inode, false);
+		d_drop(dentry);
+		/*
+		 * if unlink/whiteout succeeded, parent dir mtime has
+		 * changed
+		 */
+		unionfs_copy_attr_times(dir);
+	}
+
+out:
+	if (!err) {
+		unionfs_check_dentry(dentry);
+		unionfs_check_inode(dir);
+	}
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,
+			       struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct dentry *lower_dentry;
+	struct dentry *lower_dir_dentry = NULL;
+
+	/* Here we need to remove whiteout entries. */
+	err = delete_whiteouts(dentry, dbstart(dentry), namelist);
+	if (err)
+		goto out;
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	lower_dir_dentry = lock_parent(lower_dentry);
+
+	/* avoid destroying the lower inode if the file is in use */
+	dget(lower_dentry);
+	err = is_robranch(dentry);
+	if (!err)
+		err = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);
+	dput(lower_dentry);
+
+	fsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = unionfs_get_nlinks(dentry->d_inode);
+
+out:
+	if (lower_dir_dentry)
+		unlock_dir(lower_dir_dentry);
+	return err;
+}
+
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct unionfs_dir_state *namelist = NULL;
+	struct dentry *parent;
+	int dstart, dend;
+	bool valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+	unionfs_check_dentry(dentry);
+
+	/* check if this unionfs directory is empty or not */
+	err = check_empty(dentry, parent, &namelist);
+	if (err)
+		goto out;
+
+	err = unionfs_rmdir_first(dir, dentry, namelist);
+	dstart = dbstart(dentry);
+	dend = dbend(dentry);
+	/*
+	 * We create a whiteout for the directory if there was an error to
+	 * rmdir the first directory entry in the union.  Otherwise, we
+	 * create a whiteout only if there is no chance that a lower
+	 * priority branch might also have the same named directory.  IOW,
+	 * if there is not another same-named directory at a lower priority
+	 * branch, then we don't need to create a whiteout for it.
+	 */
+	if (!err) {
+		if (dstart < dend)
+			err = create_whiteout(dentry, dstart);
+	} else {
+		int new_err;
+
+		if (dstart == 0)
+			goto out;
+
+		/* exit if the error returned was NOT -EROFS */
+		if (!IS_COPYUP_ERR(err))
+			goto out;
+
+		new_err = create_whiteout(dentry, dstart - 1);
+		if (new_err != -EEXIST)
+			err = new_err;
+	}
+
+out:
+	/*
+	 * Drop references to lower dentry/inode so storage space for them
+	 * can be reclaimed.  Then, call d_drop so the system "forgets"
+	 * about us.
+	 */
+	if (!err) {
+		iput_lowers_all(dentry->d_inode, false);
+		dput(unionfs_lower_dentry_idx(dentry, dstart));
+		unionfs_set_lower_dentry_idx(dentry, dstart, NULL);
+		d_drop(dentry);
+		/* update our lower vfsmnts, in case a copyup took place */
+		unionfs_postcopyup_setmnt(dentry);
+		unionfs_check_dentry(dentry);
+		unionfs_check_inode(dir);
+	}
+
+	if (namelist)
+		free_rdstate(namelist);
+
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/fs/unionfs/whiteout.c b/fs/unionfs/whiteout.c
new file mode 100644
index 0000000..405073a
--- /dev/null
+++ b/fs/unionfs/whiteout.c
@@ -0,0 +1,584 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/*
+ * whiteout and opaque directory helpers
+ */
+
+/* What do we use for whiteouts. */
+#define UNIONFS_WHPFX ".wh."
+#define UNIONFS_WHLEN 4
+/*
+ * If a directory contains this file, then it is opaque.  We start with the
+ * .wh. flag so that it is blocked by lookup.
+ */
+#define UNIONFS_DIR_OPAQUE_NAME "__dir_opaque"
+#define UNIONFS_DIR_OPAQUE UNIONFS_WHPFX UNIONFS_DIR_OPAQUE_NAME
+
+/* construct whiteout filename */
+char *alloc_whname(const char *name, int len)
+{
+	char *buf;
+
+	buf = kmalloc(len + UNIONFS_WHLEN + 1, GFP_KERNEL);
+	if (unlikely(!buf))
+		return ERR_PTR(-ENOMEM);
+
+	strcpy(buf, UNIONFS_WHPFX);
+	strlcat(buf, name, len + UNIONFS_WHLEN + 1);
+
+	return buf;
+}
+
+/*
+ * XXX: this can be inline or CPP macro, but is here to keep all whiteout
+ * code in one place.
+ */
+void unionfs_set_max_namelen(long *namelen)
+{
+	*namelen -= UNIONFS_WHLEN;
+}
+
+/* check if @namep is a whiteout, update @namep and @namelenp accordingly */
+bool is_whiteout_name(char **namep, int *namelenp)
+{
+	if (*namelenp > UNIONFS_WHLEN &&
+	    !strncmp(*namep, UNIONFS_WHPFX, UNIONFS_WHLEN)) {
+		*namep += UNIONFS_WHLEN;
+		*namelenp -= UNIONFS_WHLEN;
+		return true;
+	}
+	return false;
+}
+
+/* is the filename valid == !(whiteout for a file or opaque dir marker) */
+bool is_validname(const char *name)
+{
+	if (!strncmp(name, UNIONFS_WHPFX, UNIONFS_WHLEN))
+		return false;
+	if (!strncmp(name, UNIONFS_DIR_OPAQUE_NAME,
+		     sizeof(UNIONFS_DIR_OPAQUE_NAME) - 1))
+		return false;
+	return true;
+}
+
+/*
+ * Look for a whiteout @name in @lower_parent directory.  If error, return
+ * ERR_PTR.  Caller must dput() the returned dentry if not an error.
+ *
+ * XXX: some callers can reuse the whname allocated buffer to avoid repeated
+ * free then re-malloc calls.  Need to provide a different API for those
+ * callers.
+ */
+struct dentry *lookup_whiteout(const char *name, struct dentry *lower_parent)
+{
+	char *whname = NULL;
+	int err = 0, namelen;
+	struct dentry *wh_dentry = NULL;
+
+	namelen = strlen(name);
+	whname = alloc_whname(name, namelen);
+	if (unlikely(IS_ERR(whname))) {
+		err = PTR_ERR(whname);
+		goto out;
+	}
+
+	/* check if whiteout exists in this branch: lookup .wh.foo */
+	wh_dentry = lookup_lck_len(whname, lower_parent, strlen(whname));
+	if (IS_ERR(wh_dentry)) {
+		err = PTR_ERR(wh_dentry);
+		goto out;
+	}
+
+	/* check if negative dentry (ENOENT) */
+	if (!wh_dentry->d_inode)
+		goto out;
+
+	/* whiteout found: check if valid type */
+	if (!S_ISREG(wh_dentry->d_inode->i_mode)) {
+		printk(KERN_ERR "unionfs: invalid whiteout %s entry type %d\n",
+		       whname, wh_dentry->d_inode->i_mode);
+		dput(wh_dentry);
+		err = -EIO;
+		goto out;
+	}
+
+out:
+	kfree(whname);
+	if (err)
+		wh_dentry = ERR_PTR(err);
+	return wh_dentry;
+}
+
+/* find and return first whiteout in parent directory, else ENOENT */
+struct dentry *find_first_whiteout(struct dentry *dentry)
+{
+	int bindex, bstart, bend;
+	struct dentry *parent, *lower_parent, *wh_dentry;
+
+	parent = dget_parent(dentry);
+
+	bstart = dbstart(parent);
+	bend = dbend(parent);
+	wh_dentry = ERR_PTR(-ENOENT);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		lower_parent = unionfs_lower_dentry_idx(parent, bindex);
+		if (!lower_parent)
+			continue;
+		wh_dentry = lookup_whiteout(dentry->d_name.name, lower_parent);
+		if (IS_ERR(wh_dentry))
+			continue;
+		if (wh_dentry->d_inode)
+			break;
+		dput(wh_dentry);
+		wh_dentry = ERR_PTR(-ENOENT);
+	}
+
+	dput(parent);
+
+	return wh_dentry;
+}
+
+/*
+ * Unlink a whiteout dentry.  Returns 0 or -errno.  Caller must hold and
+ * release dentry reference.
+ */
+int unlink_whiteout(struct dentry *wh_dentry)
+{
+	int err;
+	struct dentry *lower_dir_dentry;
+
+	/* dget and lock parent dentry */
+	lower_dir_dentry = lock_parent_wh(wh_dentry);
+
+	/* see Documentation/filesystems/unionfs/issues.txt */
+	lockdep_off();
+	err = vfs_unlink(lower_dir_dentry->d_inode, wh_dentry);
+	lockdep_on();
+	unlock_dir(lower_dir_dentry);
+
+	/*
+	 * Whiteouts are special files and should be deleted no matter what
+	 * (as if they never existed), in order to allow this create
+	 * operation to succeed.  This is especially important in sticky
+	 * directories: a whiteout may have been created by one user, but
+	 * the newly created file may be created by another user.
+	 * Therefore, in order to maintain Unix semantics, if the vfs_unlink
+	 * above failed, then we have to try to directly unlink the
+	 * whiteout.  Note: in the ODF version of unionfs, whiteout are
+	 * handled much more cleanly.
+	 */
+	if (err == -EPERM) {
+		struct inode *inode = lower_dir_dentry->d_inode;
+		err = inode->i_op->unlink(inode, wh_dentry);
+	}
+	if (err)
+		printk(KERN_ERR "unionfs: could not unlink whiteout %s, "
+		       "err = %d\n", wh_dentry->d_name.name, err);
+
+	return err;
+
+}
+
+/*
+ * Helper function when creating new objects (create, symlink, mknod, etc.).
+ * Checks to see if there's a whiteout in @lower_dentry's parent directory,
+ * whose name is taken from @dentry.  Then tries to remove that whiteout, if
+ * found.  If <dentry,bindex> is a branch marked readonly, return -EROFS.
+ * If it finds both a regular file and a whiteout, return -EIO (this should
+ * never happen).
+ *
+ * Return 0 if no whiteout was found.  Return 1 if one was found and
+ * successfully removed.  Therefore a value >= 0 tells the caller that
+ * @lower_dentry belongs to a good branch to create the new object in).
+ * Return -ERRNO if an error occurred during whiteout lookup or in trying to
+ * unlink the whiteout.
+ */
+int check_unlink_whiteout(struct dentry *dentry, struct dentry *lower_dentry,
+			  int bindex)
+{
+	int err;
+	struct dentry *wh_dentry = NULL;
+	struct dentry *lower_dir_dentry = NULL;
+
+	/* look for whiteout dentry first */
+	lower_dir_dentry = dget_parent(lower_dentry);
+	wh_dentry = lookup_whiteout(dentry->d_name.name, lower_dir_dentry);
+	dput(lower_dir_dentry);
+	if (IS_ERR(wh_dentry)) {
+		err = PTR_ERR(wh_dentry);
+		goto out;
+	}
+
+	if (!wh_dentry->d_inode) { /* no whiteout exists*/
+		err = 0;
+		goto out_dput;
+	}
+
+	/* check if regular file and whiteout were both found */
+	if (unlikely(lower_dentry->d_inode)) {
+		err = -EIO;
+		printk(KERN_ERR "unionfs: found both whiteout and regular "
+		       "file in directory %s (branch %d)\n",
+		       lower_dir_dentry->d_name.name, bindex);
+		goto out_dput;
+	}
+
+	/* check if branch is writeable */
+	err = is_robranch_super(dentry->d_sb, bindex);
+	if (err)
+		goto out_dput;
+
+	/* .wh.foo has been found, so let's unlink it */
+	err = unlink_whiteout(wh_dentry);
+	if (!err)
+		err = 1; /* a whiteout was found and successfully removed */
+out_dput:
+	dput(wh_dentry);
+out:
+	return err;
+}
+
+/*
+ * Pass an unionfs dentry and an index.  It will try to create a whiteout
+ * for the filename in dentry, and will try in branch 'index'.  On error,
+ * it will proceed to a branch to the left.
+ */
+int create_whiteout(struct dentry *dentry, int start)
+{
+	int bstart, bend, bindex;
+	struct dentry *lower_dir_dentry;
+	struct dentry *lower_dentry;
+	struct dentry *lower_wh_dentry;
+	struct nameidata nd;
+	char *name = NULL;
+	int err = -EINVAL;
+
+	verify_locked(dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* create dentry's whiteout equivalent */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (unlikely(IS_ERR(name))) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	for (bindex = start; bindex >= 0; bindex--) {
+		lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+
+		if (!lower_dentry) {
+			/*
+			 * if lower dentry is not present, create the
+			 * entire lower dentry directory structure and go
+			 * ahead.  Since we want to just create whiteout, we
+			 * only want the parent dentry, and hence get rid of
+			 * this dentry.
+			 */
+			lower_dentry = create_parents(dentry->d_inode,
+						      dentry,
+						      dentry->d_name.name,
+						      bindex);
+			if (!lower_dentry || IS_ERR(lower_dentry)) {
+				int ret = PTR_ERR(lower_dentry);
+				if (!IS_COPYUP_ERR(ret))
+					printk(KERN_ERR
+					       "unionfs: create_parents for "
+					       "whiteout failed: bindex=%d "
+					       "err=%d\n", bindex, ret);
+				continue;
+			}
+		}
+
+		lower_wh_dentry =
+			lookup_lck_len(name, lower_dentry->d_parent,
+				       dentry->d_name.len + UNIONFS_WHLEN);
+		if (IS_ERR(lower_wh_dentry))
+			continue;
+
+		/*
+		 * The whiteout already exists. This used to be impossible,
+		 * but now is possible because of opaqueness.
+		 */
+		if (lower_wh_dentry->d_inode) {
+			dput(lower_wh_dentry);
+			err = 0;
+			goto out;
+		}
+
+		err = init_lower_nd(&nd, LOOKUP_CREATE);
+		if (unlikely(err < 0))
+			goto out;
+		lower_dir_dentry = lock_parent_wh(lower_wh_dentry);
+		err = is_robranch_super(dentry->d_sb, bindex);
+		if (!err)
+			err = vfs_create(lower_dir_dentry->d_inode,
+					 lower_wh_dentry,
+					 current_umask() & S_IRUGO,
+					 &nd);
+		unlock_dir(lower_dir_dentry);
+		dput(lower_wh_dentry);
+		release_lower_nd(&nd, err);
+
+		if (!err || !IS_COPYUP_ERR(err))
+			break;
+	}
+
+	/* set dbopaque so that lookup will not proceed after this branch */
+	if (!err)
+		dbopaque(dentry) = bindex;
+
+out:
+	kfree(name);
+	return err;
+}
+
+/*
+ * Delete all of the whiteouts in a given directory for rmdir.
+ *
+ * lower directory inode should be locked
+ */
+static int do_delete_whiteouts(struct dentry *dentry, int bindex,
+			       struct unionfs_dir_state *namelist)
+{
+	int err = 0;
+	struct dentry *lower_dir_dentry = NULL;
+	struct dentry *lower_dentry;
+	char *name = NULL, *p;
+	struct inode *lower_dir;
+	int i;
+	struct list_head *pos;
+	struct filldir_node *cursor;
+
+	/* Find out lower parent dentry */
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
+
+	err = -ENOMEM;
+	name = __getname();
+	if (unlikely(!name))
+		goto out;
+	strcpy(name, UNIONFS_WHPFX);
+	p = name + UNIONFS_WHLEN;
+
+	err = 0;
+	for (i = 0; !err && i < namelist->size; i++) {
+		list_for_each(pos, &namelist->list[i]) {
+			cursor =
+				list_entry(pos, struct filldir_node,
+					   file_list);
+			/* Only operate on whiteouts in this branch. */
+			if (cursor->bindex != bindex)
+				continue;
+			if (!cursor->whiteout)
+				continue;
+
+			strlcpy(p, cursor->name, PATH_MAX - UNIONFS_WHLEN);
+			lower_dentry =
+				lookup_lck_len(name, lower_dir_dentry,
+					       cursor->namelen +
+					       UNIONFS_WHLEN);
+			if (IS_ERR(lower_dentry)) {
+				err = PTR_ERR(lower_dentry);
+				break;
+			}
+			if (lower_dentry->d_inode)
+				err = vfs_unlink(lower_dir, lower_dentry);
+			dput(lower_dentry);
+			if (err)
+				break;
+		}
+	}
+
+	__putname(name);
+
+	/* After all of the removals, we should copy the attributes once. */
+	fsstack_copy_attr_times(dentry->d_inode, lower_dir_dentry->d_inode);
+
+out:
+	return err;
+}
+
+
+void __delete_whiteouts(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+	struct deletewh_args *d = &args->deletewh;
+
+	args->err = do_delete_whiteouts(d->dentry, d->bindex, d->namelist);
+	complete(&args->comp);
+}
+
+/* delete whiteouts in a dir (for rmdir operation) using sioq if necessary */
+int delete_whiteouts(struct dentry *dentry, int bindex,
+		     struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct super_block *sb;
+	struct dentry *lower_dir_dentry;
+	struct inode *lower_dir;
+	struct sioq_args args;
+
+	sb = dentry->d_sb;
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+	BUG_ON(bindex < dbstart(dentry));
+	BUG_ON(bindex > dbend(dentry));
+	err = is_robranch_super(sb, bindex);
+	if (err)
+		goto out;
+
+	lower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	BUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));
+	lower_dir = lower_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(lower_dir->i_mode));
+
+	if (!inode_permission(lower_dir, MAY_WRITE | MAY_EXEC)) {
+		err = do_delete_whiteouts(dentry, bindex, namelist);
+	} else {
+		args.deletewh.namelist = namelist;
+		args.deletewh.dentry = dentry;
+		args.deletewh.bindex = bindex;
+		run_sioq(__delete_whiteouts, &args);
+		err = args.err;
+	}
+
+out:
+	return err;
+}
+
+/****************************************************************************
+ * Opaque directory helpers                                                 *
+ ****************************************************************************/
+
+/*
+ * is_opaque_dir: returns 0 if it is NOT an opaque dir, 1 if it is, and
+ * -errno if an error occurred trying to figure this out.
+ */
+int is_opaque_dir(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *lower_dentry;
+	struct dentry *wh_lower_dentry;
+	struct inode *lower_inode;
+	struct sioq_args args;
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_inode = lower_dentry->d_inode;
+
+	BUG_ON(!S_ISDIR(lower_inode->i_mode));
+
+	mutex_lock(&lower_inode->i_mutex);
+
+	if (!inode_permission(lower_inode, MAY_EXEC)) {
+		wh_lower_dentry =
+			lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
+				       sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	} else {
+		args.is_opaque.dentry = lower_dentry;
+		run_sioq(__is_opaque_dir, &args);
+		wh_lower_dentry = args.ret;
+	}
+
+	mutex_unlock(&lower_inode->i_mutex);
+
+	if (IS_ERR(wh_lower_dentry)) {
+		err = PTR_ERR(wh_lower_dentry);
+		goto out;
+	}
+
+	/* This is an opaque dir iff wh_lower_dentry is positive */
+	err = !!wh_lower_dentry->d_inode;
+
+	dput(wh_lower_dentry);
+out:
+	return err;
+}
+
+void __is_opaque_dir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, work);
+
+	args->ret = lookup_one_len(UNIONFS_DIR_OPAQUE, args->is_opaque.dentry,
+				   sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	complete(&args->comp);
+}
+
+int make_dir_opaque(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *lower_dentry, *diropq;
+	struct inode *lower_dir;
+	struct nameidata nd;
+	const struct cred *old_creds;
+	struct cred *new_creds;
+
+	/*
+	 * Opaque directory whiteout markers are special files (like regular
+	 * whiteouts), and should appear to the users as if they don't
+	 * exist.  They should be created/deleted regardless of directory
+	 * search/create permissions, but only for the duration of this
+	 * creation of the .wh.__dir_opaque: file.  Note, this does not
+	 * circumvent normal ->permission).
+	 */
+	new_creds = prepare_creds();
+	if (unlikely(!new_creds)) {
+		err = -ENOMEM;
+		goto out_err;
+	}
+	cap_raise(new_creds->cap_effective, CAP_DAC_READ_SEARCH);
+	cap_raise(new_creds->cap_effective, CAP_DAC_OVERRIDE);
+	old_creds = override_creds(new_creds);
+
+	lower_dentry = unionfs_lower_dentry_idx(dentry, bindex);
+	lower_dir = lower_dentry->d_inode;
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode) ||
+	       !S_ISDIR(lower_dir->i_mode));
+
+	mutex_lock(&lower_dir->i_mutex);
+	diropq = lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,
+				sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	if (IS_ERR(diropq)) {
+		err = PTR_ERR(diropq);
+		goto out;
+	}
+
+	err = init_lower_nd(&nd, LOOKUP_CREATE);
+	if (unlikely(err < 0))
+		goto out;
+	if (!diropq->d_inode)
+		err = vfs_create(lower_dir, diropq, S_IRUGO, &nd);
+	if (!err)
+		dbopaque(dentry) = bindex;
+	release_lower_nd(&nd, err);
+
+	dput(diropq);
+
+out:
+	mutex_unlock(&lower_dir->i_mutex);
+	revert_creds(old_creds);
+out_err:
+	return err;
+}
diff --git a/fs/unionfs/xattr.c b/fs/unionfs/xattr.c
new file mode 100644
index 0000000..9002e06
--- /dev/null
+++ b/fs/unionfs/xattr.c
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2003-2010 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2010 Stony Brook University
+ * Copyright (c) 2003-2010 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "union.h"
+
+/* This is lifted from fs/xattr.c */
+void *unionfs_xattr_alloc(size_t size, size_t limit)
+{
+	void *ptr;
+
+	if (size > limit)
+		return ERR_PTR(-E2BIG);
+
+	if (!size)		/* size request, no buffer is needed */
+		return NULL;
+
+	ptr = kmalloc(size, GFP_KERNEL);
+	if (unlikely(!ptr))
+		return ERR_PTR(-ENOMEM);
+	return ptr;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,
+			 size_t size)
+{
+	struct dentry *lower_dentry = NULL;
+	struct dentry *parent;
+	int err = -EOPNOTSUPP;
+	bool valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_getxattr(lower_dentry, (char *) name, value, size);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int unionfs_setxattr(struct dentry *dentry, const char *name,
+		     const void *value, size_t size, int flags)
+{
+	struct dentry *lower_dentry = NULL;
+	struct dentry *parent;
+	int err = -EOPNOTSUPP;
+	bool valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_setxattr(lower_dentry, (char *) name, (void *) value,
+			   size, flags);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int unionfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct dentry *lower_dentry = NULL;
+	struct dentry *parent;
+	int err = -EOPNOTSUPP;
+	bool valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	err = vfs_removexattr(lower_dentry, (char *) name);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
+
+/*
+ * BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+ssize_t unionfs_listxattr(struct dentry *dentry, char *list, size_t size)
+{
+	struct dentry *lower_dentry = NULL;
+	struct dentry *parent;
+	int err = -EOPNOTSUPP;
+	char *encoded_list = NULL;
+	bool valid;
+
+	unionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);
+	parent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);
+	unionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);
+
+	valid = __unionfs_d_revalidate(dentry, parent, false);
+	if (unlikely(!valid)) {
+		err = -ESTALE;
+		goto out;
+	}
+
+	lower_dentry = unionfs_lower_dentry(dentry);
+
+	encoded_list = list;
+	err = vfs_listxattr(lower_dentry, encoded_list, size);
+
+out:
+	unionfs_check_dentry(dentry);
+	unionfs_unlock_dentry(dentry);
+	unionfs_unlock_parent(dentry, parent);
+	unionfs_read_unlock(dentry->d_sb);
+	return err;
+}
diff --git a/include/linux/fs.h b/include/linux/fs.h
index ebb1cd5..b03df2d 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1744,6 +1744,7 @@ struct file_system_type {
 
 	struct lock_class_key s_lock_key;
 	struct lock_class_key s_umount_key;
+	struct lock_class_key s_vfs_rename_key;
 
 	struct lock_class_key i_lock_key;
 	struct lock_class_key i_mutex_key;
diff --git a/include/linux/fs_stack.h b/include/linux/fs_stack.h
index da317c7..64f1ced 100644
--- a/include/linux/fs_stack.h
+++ b/include/linux/fs_stack.h
@@ -1,7 +1,19 @@
+/*
+ * Copyright (c) 2006-2009 Erez Zadok
+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2006-2009 Stony Brook University
+ * Copyright (c) 2006-2009 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
 #ifndef _LINUX_FS_STACK_H
 #define _LINUX_FS_STACK_H
 
-/* This file defines generic functions used primarily by stackable
+/*
+ * This file defines generic functions used primarily by stackable
  * filesystems; none of these functions require i_mutex to be held.
  */
 
diff --git a/include/linux/magic.h b/include/linux/magic.h
index 76285e0..ff4f649 100644
--- a/include/linux/magic.h
+++ b/include/linux/magic.h
@@ -47,6 +47,8 @@
 #define REISER2FS_SUPER_MAGIC_STRING	"ReIsEr2Fs"
 #define REISER2FS_JR_SUPER_MAGIC_STRING	"ReIsEr3Fs"
 
+#define UNIONFS_SUPER_MAGIC 0xf15f083d
+
 #define SMB_SUPER_MAGIC		0x517B
 #define USBDEVICE_SUPER_MAGIC	0x9fa2
 #define CGROUP_SUPER_MAGIC	0x27e0eb
diff --git a/include/linux/namei.h b/include/linux/namei.h
index 05b441d..dca6f9a 100644
--- a/include/linux/namei.h
+++ b/include/linux/namei.h
@@ -72,6 +72,7 @@ extern int vfs_path_lookup(struct dentry *, struct vfsmount *,
 
 extern struct file *lookup_instantiate_filp(struct nameidata *nd, struct dentry *dentry,
 		int (*open)(struct inode *, struct file *));
+extern void release_open_intent(struct nameidata *);
 
 extern struct dentry *lookup_one_len(const char *, struct dentry *, int);
 
diff --git a/include/linux/splice.h b/include/linux/splice.h
index 18e7c7c..af56841 100644
--- a/include/linux/splice.h
+++ b/include/linux/splice.h
@@ -81,5 +81,10 @@ extern ssize_t splice_to_pipe(struct pipe_inode_info *,
 			      struct splice_pipe_desc *);
 extern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,
 				      splice_direct_actor *);
+extern long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,
+			    loff_t *ppos, size_t len, unsigned int flags);
+extern long vfs_splice_to(struct file *in, loff_t *ppos,
+			  struct pipe_inode_info *pipe, size_t len,
+			  unsigned int flags);
 
 #endif
diff --git a/include/linux/union_fs.h b/include/linux/union_fs.h
new file mode 100644
index 0000000..c84d97e
--- /dev/null
+++ b/include/linux/union_fs.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2003-2009 Erez Zadok
+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek
+ * Copyright (c) 2003-2009 Stony Brook University
+ * Copyright (c) 2003-2009 The Research Foundation of SUNY
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _LINUX_UNION_FS_H
+#define _LINUX_UNION_FS_H
+
+/*
+ * DEFINITIONS FOR USER AND KERNEL CODE:
+ */
+# define UNIONFS_IOCTL_INCGEN		_IOR(0x15, 11, int)
+# define UNIONFS_IOCTL_QUERYFILE	_IOR(0x15, 15, int)
+
+#endif /* _LINUX_UNIONFS_H */
+
diff --git a/security/security.c b/security/security.c
index 122b748..a02aece 100644
--- a/security/security.c
+++ b/security/security.c
@@ -557,6 +557,7 @@ int security_inode_permission(struct inode *inode, int mask)
 		return 0;
 	return security_ops->inode_permission(inode, mask);
 }
+EXPORT_SYMBOL(security_inode_permission);
 
 int security_inode_setattr(struct dentry *dentry, struct iattr *attr)
 {
* Fix abundant warning from kmalloc inside tty_buffer_request_room
* tty_buffer_alloc: Fallback and try to alloc a single page

Index: linux-2.6.33-source/drivers/char/tty_buffer.c
===================================================================
--- linux-2.6.33-source.orig/drivers/char/tty_buffer.c
+++ linux-2.6.33-source/drivers/char/tty_buffer.c
@@ -57,12 +57,27 @@
 static struct tty_buffer *tty_buffer_alloc(struct tty_struct *tty, size_t size)
 {
 	struct tty_buffer *p;
+	size_t bytes;
 
 	if (tty->buf.memory_used + size > 65536)
 		return NULL;
-	p = kmalloc(sizeof(struct tty_buffer) + 2 * size, GFP_ATOMIC);
-	if (p == NULL)
-		return NULL;
+
+	bytes = sizeof(struct tty_buffer) + 2 * size;
+	p = kmalloc(bytes, GFP_ATOMIC | __GFP_NOWARN);
+	if (p == NULL) {
+		if (bytes <= PAGE_SIZE) {
+			printk(KERN_WARNING "tty_buffer_alloc: kmalloc failed for size:%d (%d) used:%d\n", size, bytes, tty->buf.memory_used);
+			return NULL;
+		}
+
+		/* Try single page */
+		size = (PAGE_SIZE - sizeof(struct tty_buffer)) / 2;
+		p = kmalloc(PAGE_SIZE, GFP_ATOMIC);
+		if (p == NULL) {
+			printk(KERN_WARNING "tty_buffer_alloc: kmalloc second try failed size:%d (%lu) used:%d\n", size, PAGE_SIZE, tty->buf.memory_used);
+			return NULL;
+		}
+	}
 	p->used = 0;
 	p->size = size;
 	p->next = NULL;
@@ -221,8 +236,12 @@
 			} else
 				tty->buf.head = n;
 			tty->buf.tail = n;
-		} else
+			if (n->size < size)
+				size = n->size;
+		} else {
+			printk(KERN_WARNING "tty_buffer_find failed for size:%d left:%d used:%d\n", size, left, tty->buf.memory_used);
 			size = left;
+		}
 	}
 
 	spin_unlock_irqrestore(&tty->buf.lock, flags);
Colinux base


Index: linux-2.6.33-source/CREDITS
===================================================================
--- linux-2.6.33-source.orig/CREDITS
+++ linux-2.6.33-source/CREDITS
@@ -16,6 +16,13 @@
 S: (ask for current address)
 S: Finland
 
+N: Dan Aloni
+E: da-x@colinux.org
+W: http://www.colinux.org
+D: Cooperative Linux
+D: Various kernel patches
+S: Israel
+
 N: Dragos Acostachioaie
 E: dragos@iname.com
 W: http://www.arbornet.org/~dragos
Index: linux-2.6.33-source/Makefile
===================================================================
--- linux-2.6.33-source.orig/Makefile
+++ linux-2.6.33-source/Makefile
@@ -312,7 +312,11 @@
 
 AS		= $(CROSS_COMPILE)as
 LD		= $(CROSS_COMPILE)ld
+ifeq ($(GCCTRACE),Y)
+CC              = $(COLINUX_ROOT)/bin/tracewrapper.py $(CROSS_COMPILE)gcc
+else
 CC		= $(CROSS_COMPILE)gcc
+endif
 CPP		= $(CC) -E
 AR		= $(CROSS_COMPILE)ar
 NM		= $(CROSS_COMPILE)nm
Index: linux-2.6.33-source/arch/x86/Kconfig
===================================================================
--- linux-2.6.33-source.orig/arch/x86/Kconfig
+++ linux-2.6.33-source/arch/x86/Kconfig
@@ -42,7 +42,7 @@
 	select HAVE_KVM
 	select HAVE_ARCH_KGDB
 	select HAVE_ARCH_TRACEHOOK
-	select HAVE_GENERIC_DMA_COHERENT if X86_32
+	select HAVE_GENERIC_DMA_COHERENT if (X86_32 && !COOPERATIVE)
 	select HAVE_EFFICIENT_UNALIGNED_ACCESS
 	select USER_STACKTRACE_SUPPORT
 	select HAVE_DMA_API_DEBUG
@@ -71,6 +71,7 @@
 
 config GENERIC_CMOS_UPDATE
 	def_bool y
+	depends on !COOPERATIVE
 
 config CLOCKSOURCE_WATCHDOG
 	def_bool y
@@ -96,12 +97,14 @@
 
 config ZONE_DMA
 	def_bool y
+	depends on HAVE_DMA
 
 config SBUS
 	bool
 
 config GENERIC_ISA_DMA
 	def_bool y
+	depends on HAVE_DMA
 
 config GENERIC_IOMAP
 	def_bool y
@@ -194,6 +197,8 @@
 
 config GENERIC_HARDIRQS_NO__DO_IRQ
        def_bool y
+# FIXME: Use generic_handle_irq() instead __do_IRQ()
+	depends on !COOPERATIVE
 
 config GENERIC_IRQ_PROBE
 	bool
@@ -241,6 +246,7 @@
 
 config SMP
 	bool "Symmetric multi-processing support"
+	depends on !COOPERATIVE
 	---help---
 	  This enables support for systems with more than one CPU. If you have
 	  a system with only one CPU, like most personal computers, say N. If
@@ -592,6 +598,7 @@
 config HPET_TIMER
 	def_bool X86_64
 	prompt "HPET Timer Support" if X86_32
+	depends on !COOPERATIVE
 	---help---
 	  Use the IA-PC HPET (High Precision Event Timer) to manage
 	  time in preference to the PIT and RTC, if a HPET is
@@ -617,6 +624,7 @@
 config DMI
 	default y
 	bool "Enable DMI scanning" if EMBEDDED
+	depends on !COOPERATIVE
 	---help---
 	  Enabled scanning of DMI to identify machine quirks. Say Y
 	  here unless you have verified that your setup is not
@@ -780,6 +788,10 @@
 	  to use it. If you say Y here even though your machine doesn't have
 	  an IO-APIC, then the kernel will still run with no slowdown at all.
 
+config X86_UP_COPIC
+	bool 'Cooperative PIC (COPIC) support'
+	depends on COOPERATIVE
+
 config X86_LOCAL_APIC
 	def_bool y
 	depends on X86_64 || SMP || X86_32_NON_STANDARD || X86_UP_APIC
@@ -894,6 +906,7 @@
 
 config I8K
 	tristate "Dell laptop support"
+	depends on !COOPERATIVE
 	---help---
 	  This adds a driver to safely access the System Management Mode
 	  of the CPU on the Dell Inspiron 8000. The System Management Mode
@@ -915,6 +928,7 @@
 config X86_REBOOTFIXUPS
 	bool "Enable X86 board specific fixups for reboot"
 	depends on X86_32
+	depends on !COOPERATIVE
 	---help---
 	  This enables chipset and/or board specific fixups to be done
 	  in order to get reboot to work correctly. This is only needed on
@@ -994,6 +1008,7 @@
 	default HIGHMEM4G if !X86_NUMAQ
 	default HIGHMEM64G if X86_NUMAQ
 	depends on X86_32
+	depends on !COOPERATIVE
 
 config NOHIGHMEM
 	bool "off"
@@ -1100,6 +1115,7 @@
 config X86_PAE
 	bool "PAE (Physical Address Extension) Support"
 	depends on X86_32 && !HIGHMEM4G
+	depends on !COOPERATIVE
 	---help---
 	  PAE is required for NX support, and furthermore enables
 	  larger swapspace support for non-overcommit purposes. It
@@ -1230,6 +1246,7 @@
 config ARCH_SPARSEMEM_ENABLE
 	def_bool y
 	depends on X86_64 || NUMA || (EXPERIMENTAL && X86_32) || X86_32_NON_STANDARD
+	depends on !COOPERATIVE
 	select SPARSEMEM_STATIC if X86_32
 	select SPARSEMEM_VMEMMAP_ENABLE if X86_64
 
@@ -1336,6 +1353,7 @@
 config MTRR
 	bool
 	default y
+	depends on !COOPERATIVE
 	prompt "MTRR (Memory Type Range Register) support" if EMBEDDED
 	---help---
 	  On Intel P6 family processors (Pentium Pro, Pentium II and later)
@@ -1470,6 +1488,7 @@
 
 config KEXEC
 	bool "kexec system call"
+	depends on !COOPERATIVE
 	---help---
 	  kexec is a system call that implements the ability to shutdown your
 	  current kernel, and to start another kernel.  It is like a reboot
@@ -1603,6 +1622,26 @@
 	    automatically on SMP systems. )
 	  Say N if you want to disable CPU hotplug.
 
+config COOPERATIVE
+	bool 'Cooperative Mode'
+	default y
+
+config COLINUX_STATS
+	bool 'Cooperative Linux stats'
+	depends on COOPERATIVE
+	default y
+	help
+	  OS switch counters readable in /proc/colinux/stats.
+
+# FIXME: IOMEM should disabled, but was needed by keyboard and Serial device
+#config NO_IOMEM
+#	depends on COOPERATIVE
+#	def_bool y
+
+config NO_DMA
+	def_bool y
+	depends on COOPERATIVE
+
 config COMPAT_VDSO
 	def_bool y
 	prompt "Compat VDSO support"
@@ -1676,6 +1715,7 @@
 	depends on NUMA
 
 menu "Power management and ACPI options"
+	depends on !COOPERATIVE
 
 config ARCH_HIBERNATION_HEADER
 	def_bool y
Index: linux-2.6.33-source/arch/x86/Kconfig.cpu
===================================================================
--- linux-2.6.33-source.orig/arch/x86/Kconfig.cpu
+++ linux-2.6.33-source/arch/x86/Kconfig.cpu
@@ -392,7 +392,7 @@
 
 config X86_TSC
 	def_bool y
-	depends on ((MWINCHIP3D || MCRUSOE || MEFFICEON || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2 || MVIAC7 || MGEODEGX1 || MGEODE_LX || MCORE2 || MATOM) && !X86_NUMAQ) || X86_64
+	depends on ((MWINCHIP3D || MCRUSOE || MEFFICEON || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2 || MVIAC7 || MGEODEGX1 || MGEODE_LX || MCORE2 || MATOM) && !X86_NUMAQ && !COOPERATIVE) || X86_64
 
 config X86_CMPXCHG64
 	def_bool y
Index: linux-2.6.33-source/arch/x86/kernel/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/Makefile
+++ linux-2.6.33-source/arch/x86/kernel/Makefile
@@ -2,7 +2,11 @@
 # Makefile for the linux kernel.
 #
 
-extra-y                := head_$(BITS).o head$(BITS).o head.o init_task.o vmlinux.lds
+extra-y                := head_$(BITS).o
+ifndef CONFIG_COOPERATIVE
+extra-y                += head$(BITS).o head.o
+endif
+extra-y                += init_task.o vmlinux.lds
 
 CPPFLAGS_vmlinux.lds += -U$(UTS_MACHINE)
 
@@ -31,17 +35,24 @@
 
 obj-y			:= process_$(BITS).o signal.o entry_$(BITS).o
 obj-y			+= traps.o irq.o irq_$(BITS).o dumpstack_$(BITS).o
-obj-y			+= time.o ioport.o ldt.o dumpstack.o
-obj-y			+= setup.o x86_init.o i8259.o irqinit.o
+obj-y			+= ldt.o dumpstack.o
+obj-y			+= setup.o irqinit.o
 obj-$(CONFIG_X86_VISWS)	+= visws_quirks.o
+ifndef CONFIG_COOPERATIVE
 obj-$(CONFIG_X86_32)	+= probe_roms_32.o
+endif
 obj-$(CONFIG_X86_32)	+= sys_i386_32.o i386_ksyms_32.o
 obj-$(CONFIG_X86_64)	+= sys_x86_64.o x8664_ksyms_64.o
 obj-$(CONFIG_X86_64)	+= syscall_64.o vsyscall_64.o
-obj-y			+= bootflag.o e820.o
-obj-y			+= pci-dma.o quirks.o i8237.o topology.o kdebugfs.o
-obj-y			+= alternative.o i8253.o pci-nommu.o hw_breakpoint.o
+ifndef CONFIG_COOPERATIVE
+obj-y			+= bootflag.o
+endif
+obj-$(CONFIG_HAS_DMA)	+= pci-dma.o pci-nommu.o
+obj-y			+= quirks.o i8237.o topology.o kdebugfs.o
+obj-y			+= alternative.o hw_breakpoint.o
+ifndef CONFIG_COOPERATIVE
 obj-y			+= tsc.o io_delay.o rtc.o
+endif
 
 obj-$(CONFIG_X86_TRAMPOLINE)	+= trampoline.o
 obj-y				+= process.o
@@ -57,11 +68,12 @@
 obj-y				+= cpu/
 obj-y				+= acpi/
 obj-$(CONFIG_SFI)		+= sfi.o
-obj-y				+= reboot.o
 obj-$(CONFIG_MCA)		+= mca_32.o
 obj-$(CONFIG_X86_MSR)		+= msr.o
 obj-$(CONFIG_X86_CPUID)		+= cpuid.o
+ifndef CONFIG_COOPERATIVE
 obj-$(CONFIG_PCI)		+= early-quirks.o
+endif
 apm-y				:= apm_32.o
 obj-$(CONFIG_APM)		+= apm.o
 obj-$(CONFIG_SMP)		+= smp.o
@@ -130,3 +142,19 @@
 	obj-$(CONFIG_PCI_MMCONFIG)	+= mmconf-fam10h_64.o
 	obj-y				+= vsmp_64.o
 endif
+
+###
+# coLinux specific files
+ifdef CONFIG_COOPERATIVE
+obj-y			+= cooperative.o
+obj-y			+= timer_cooperative.o
+obj-y			+= ioport_cooperative.o i8259_cooperative.o
+obj-y			+= reboot_cooperative.o
+obj-y			+= x86_init_cooperative.o
+else
+obj-y			+= i8253.o i8259.o
+obj-y			+= time.o ioport.o
+obj-y			+= e820.o
+obj-y			+= reboot.o
+obj-y			+= x86_init.o
+endif
Index: linux-2.6.33-source/arch/x86/kernel/cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/cooperative.c
@@ -0,0 +1,221 @@
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/reboot.h>
+
+#include <linux/cooperative_internal.h>
+#include <asm/cooperative_internal.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/desc.h>
+#include <asm/mmu_context.h>
+#include <asm/debugreg.h>
+#include <asm/i387.h>
+
+CO_TRACE_STOP;
+
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+int co_passage_page_holding_count = 0;
+#endif
+bool co_host_fpu_saved = 0;
+char co_host_fpu[0x200] __attribute__ ((__aligned__(16)));
+
+static void __init co_early_cpu_init(void)
+{
+	/*
+	 * On the first switch to Linux we must set up a valid TR because
+	 * the passage page code assumes such one exists. This is basically
+	 * copied code from cpu_init().
+	 *
+	 * P.S this is protected by CO_TRACE_STOP so that we don't
+	 * have a monitor context switch.
+	 */
+	struct task_struct *me;
+	struct tss_struct *t;
+	int cpu;
+	int i;
+	struct desc_struct *gdt;
+
+	cpu = stack_smp_processor_id();
+	t = &per_cpu(init_tss, cpu);
+
+	me = current;
+
+	write_cr4(mmu_cr4_features);
+
+	/*
+	 * Initialize the per-CPU GDT with the boot GDT,
+	 * and set up the GDT descriptor:
+	 */
+
+	switch_to_new_gdt(cpu);
+	loadsegment(fs, 0);
+
+	load_idt(&idt_descr);
+
+	memset(me->thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
+
+	/*
+	 * Delete NT
+	 */
+	__asm__("pushfl ; andl $0xffffbfff,(%esp) ; popfl");
+
+	t->x86_tss.io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
+
+	/*
+	 * <= is required because the CPU will access up to
+	 * 8 bits beyond the end of the IO permission bitmap.
+	 */
+	for (i = 0; i <= IO_BITMAP_LONGS; i++)
+		t->io_bitmap[i] = ~0UL;
+
+	atomic_inc(&init_mm.mm_count);
+	me->active_mm = &init_mm;
+	enter_lazy_tlb(&init_mm, me);
+
+	load_sp0(t, &current->thread);
+	set_tss_desc(cpu, t);
+	gdt = get_cpu_gdt_table(cpu);
+	gdt[GDT_ENTRY_TSS].b &= 0xfffffdff;
+
+	load_TR_desc();
+	load_LDT(&init_mm.context);
+
+	/* Clear %gs. */
+	asm volatile ("mov %0, %%gs" : : "r" (0));
+}
+
+/*
+ * 'co_start' is the first Linux code that runs in the
+ * coLinux kernel context. It receives %ecx which contains the
+ * address of the passage page. The passage page code sets %ecx
+ * to this value in its context restore part.
+ */
+
+void __init co_start(void)
+{
+	co_early_cpu_init();
+	co_start_kernel();
+}
+
+static void co_switch_wrapper_protected(void)
+{
+	kernel_fpu_begin();
+
+	if (co_host_fpu_saved) {
+		CO_FPU_RESTORE(co_host_fpu);
+		co_host_fpu_saved = 0;
+	}
+
+	/* And switch... */
+	co_switch();
+
+	kernel_fpu_end();
+}
+
+void co_switch_wrapper(void)
+{
+	/* taken from irq.c: debugging check for stack overflow */
+	long esp;
+
+	__asm__ __volatile__("andl %%esp,%0" : "=r" (esp) : "0" (THREAD_SIZE - 1));
+	if (unlikely(esp < (sizeof(struct thread_info) + STACK_WARN))) {
+		printk("co_switch_wrapper: stack overflow: %ld\n", esp - sizeof(struct thread_info));
+		co_terminate(CO_TERMINATE_STACK_OVERFLOW);
+	}
+
+#ifdef CONFIG_COLINUX_STATS
+	co_proc_counts.switches[co_passage_page->operation]++;
+#endif
+	co_switch_wrapper_protected();
+}
+
+void co_debug(const char *fmt, ...)
+{
+}
+
+#define MAX_TRACE_POINTS 1024
+
+typedef struct {
+	unsigned char *code;
+	unsigned char original_byte;
+	int off;
+} co_tracepoint_t;
+
+co_tracepoint_t tracepoints[MAX_TRACE_POINTS];
+static int active_tracepoints = 0;
+
+void co_kernel_breakpoint(struct pt_regs * regs)
+{
+	int i = 0;
+	unsigned char *code = (unsigned char *)regs->ip;
+	if (!code)
+		return;
+
+	code--;
+	for (i=0; i < active_tracepoints; i++) {
+		if (tracepoints[i].code == code) {
+			co_debug("TRACEPOINT: %p", code);
+			break;
+		}
+	}
+
+	if (i == active_tracepoints) {
+		/* Bad, we don't know this tracepoint */
+		co_terminate(CO_TERMINATE_INVALID_OPERATION);
+		return;
+	}
+
+	*tracepoints[i].code = tracepoints[i].original_byte;
+	regs->flags |= (1 << 8); /* Enable TF */
+	regs->ip = (unsigned long)code;
+	tracepoints[i].off = 1;
+}
+
+void co_kernel_set_breakpoints(void)
+{
+	int i;
+
+	for (i=0; i < active_tracepoints; i++)
+		if (tracepoints[i].code  &&  tracepoints[i].off) {
+			*tracepoints[i].code = 0xcc;
+			tracepoints[i].off = 0;
+		}
+}
+
+int co_kernel_debug(struct pt_regs *regs, long error_code, unsigned int condition)
+{
+	/* if not a single step trap */
+	if (!(condition & DR_STEP))
+		return 0;
+
+	/* if userspace */
+	if (regs->cs & 3)
+		return 0;
+
+	regs->flags &= ~(1 << 8); /* Disable TF */
+
+	co_kernel_set_breakpoints();
+
+	return 1;
+}
+
+void co_kernel_tracepoint_add(unsigned char *code)
+{
+	if (active_tracepoints >= MAX_TRACE_POINTS)
+		return;
+
+	tracepoints[active_tracepoints].code = code;
+	tracepoints[active_tracepoints].original_byte = *code;
+	tracepoints[active_tracepoints].off = 0;
+	active_tracepoints++;
+	*code = 0xcc;
+}
+
+co_arch_info_t co_arch_info = {
+	.kernel_cs = __KERNEL_CS,
+	.kernel_ds = __KERNEL_DS,
+};
+
+CO_TRACE_CONTINUE;
Index: linux-2.6.33-source/arch/x86/kernel/entry_32.S
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/entry_32.S
+++ linux-2.6.33-source/arch/x86/kernel/entry_32.S
@@ -864,7 +864,11 @@
 	SAVE_ALL
 	TRACE_IRQS_OFF
 	movl %esp,%eax
+#ifdef CONFIG_COOPERATIVE
+	call proxy_interrupt_handler
+#else
 	call do_IRQ
+#endif
 	jmp ret_from_intr
 ENDPROC(common_interrupt)
 	CFI_ENDPROC
@@ -917,6 +921,9 @@
 	CFI_ADJUST_CFA_OFFSET 4
 	pushl $do_device_not_available
 	CFI_ADJUST_CFA_OFFSET 4
+#if defined(CONFIG_COOPERATIVE)
+	DISABLE_INTERRUPTS(CLBR_NONE)	# FIXME: Need we this realy?
+#endif
 	jmp error_code
 	CFI_ENDPROC
 END(device_not_available)
Index: linux-2.6.33-source/arch/x86/kernel/head_32.S
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/head_32.S
+++ linux-2.6.33-source/arch/x86/kernel/head_32.S
@@ -359,6 +359,7 @@
  */
 	call setup_idt
 
+ENTRY(co_arch_start_kernel)
 checkCPUtype:
 
 	movl $-1,X86_CPUID		#  -1 for no CPUID initially
@@ -567,6 +568,10 @@
 #endif
 	call dump_stack
 hlt_loop:
+#ifdef CONFIG_COOPERATIVE
+	movl $2,%eax		/* CO_TERMINATE_PANIC */
+	call co_terminate
+#endif
 	hlt
 	jmp hlt_loop
 
@@ -607,7 +612,11 @@
 	__REFDATA
 .align 4
 ENTRY(initial_code)
+#ifdef CONFIG_COOPERATIVE
+	.long start_kernel
+#else /* CONFIG_COOPERATIVE */
 	.long i386_start_kernel
+#endif
 
 /*
  * BSS section
@@ -655,7 +664,7 @@
 
 .data
 ENTRY(stack_start)
-	.long init_thread_union+THREAD_SIZE
+	.long init_thread_union+THREAD_SIZE-100
 	.long __BOOT_DS
 
 ready:	.byte 0
Index: linux-2.6.33-source/arch/x86/kernel/setup.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/setup.c
+++ linux-2.6.33-source/arch/x86/kernel/setup.c
@@ -49,6 +49,7 @@
 #include <asm/pci-direct.h>
 #include <linux/init_ohci1394_dma.h>
 #include <linux/kvm_para.h>
+#include <linux/cooperative_internal.h>
 
 #include <linux/errno.h>
 #include <linux/kernel.h>
@@ -299,8 +300,10 @@
 
 static void __init reserve_brk(void)
 {
+#ifndef CONFIG_COOPERATIVE
 	if (_brk_end > _brk_start)
 		reserve_early(__pa(_brk_start), __pa(_brk_end), "BRK");
+#endif
 
 	/* Mark brk area as locked down and no longer taking any
 	   new allocations */
@@ -309,6 +312,7 @@
 
 #ifdef CONFIG_BLK_DEV_INITRD
 
+#ifndef CONFIG_COOPERATIVE
 #define MAX_MAP_CHUNK	(NR_FIX_BTMAPS << PAGE_SHIFT)
 static void __init relocate_initrd(void)
 {
@@ -371,9 +375,20 @@
 		ramdisk_image, ramdisk_image + ramdisk_size - 1,
 		ramdisk_here, ramdisk_here + ramdisk_size - 1);
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 static void __init reserve_initrd(void)
 {
+#ifdef CONFIG_COOPERATIVE
+	if (co_boot_params.co_initrd != NULL) {
+		initrd_start = (unsigned long)co_boot_params.co_initrd;
+		initrd_end = (unsigned long)co_boot_params.co_initrd + co_boot_params.co_initrd_size;
+		printk(KERN_INFO "initrd enabled: 0x%lx-0x%lx  size: 0x%08lx\n",
+		       initrd_start, initrd_end, co_boot_params.co_initrd_size);
+
+		reserve_bootmem(virt_to_phys(co_boot_params.co_initrd), co_boot_params.co_initrd_size, BOOTMEM_DEFAULT);
+	}
+#else /* CONFIG_COOPERATIVE */
 	u64 ramdisk_image = boot_params.hdr.ramdisk_image;
 	u64 ramdisk_size  = boot_params.hdr.ramdisk_size;
 	u64 ramdisk_end   = ramdisk_image + ramdisk_size;
@@ -410,6 +425,7 @@
 	relocate_initrd();
 
 	free_early(ramdisk_image, ramdisk_end);
+#endif /* CONFIG_COOPERATIVE */
 }
 #else
 static void __init reserve_initrd(void)
@@ -417,6 +433,7 @@
 }
 #endif /* CONFIG_BLK_DEV_INITRD */
 
+#ifndef CONFIG_COOPERATIVE
 static void __init parse_setup_data(void)
 {
 	struct setup_data *data;
@@ -482,6 +499,7 @@
 		early_iounmap(data, sizeof(*data));
 	}
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 /*
  * --------- Crashkernel reservation ------------------------------
@@ -549,6 +567,7 @@
 }
 #endif
 
+#ifndef CONFIG_COOPERATIVE
 static struct resource standard_io_resources[] = {
 	{ .name = "dma1", .start = 0x00, .end = 0x1f,
 		.flags = IORESOURCE_BUSY | IORESOURCE_IO },
@@ -581,6 +600,7 @@
 		request_resource(&ioport_resource, &standard_io_resources[i]);
 
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 /*
  * Note: elfcorehdr_addr is not just limited to vmcore. It is also used by
@@ -618,6 +638,7 @@
 }
 #endif
 
+#ifndef CONFIG_COOPERATIVE
 /* List of systems that have known low memory corruption BIOS problems */
 static struct dmi_system_id __initdata bad_bios_dmi_table[] = {
 #ifdef CONFIG_X86_RESERVE_LOW_64K
@@ -677,6 +698,7 @@
 #endif
 	{}
 };
+#endif /* !CONFIG_COOPERATIVE */
 
 /*
  * Determine if we were loaded by an EFI loader.  If so, then we have also been
@@ -751,10 +773,12 @@
 
 	x86_init.oem.arch_setup();
 
+#ifndef CONFIG_COOPERATIVE
 	setup_memory_map();
 	parse_setup_data();
 	/* update the e820_saved too */
 	e820_reserve_setup_data();
+#endif /* !CONFIG_COOPERATIVE */
 
 	copy_edd();
 
@@ -772,6 +796,9 @@
 	bss_resource.start = virt_to_phys(&__bss_start);
 	bss_resource.end = virt_to_phys(&__bss_stop)-1;
 
+#ifdef CONFIG_COOPERATIVE
+	strlcpy(boot_command_line, co_boot_params.co_boot_parameters, COMMAND_LINE_SIZE);
+#endif
 #ifdef CONFIG_CMDLINE_BOOL
 #ifdef CONFIG_CMDLINE_OVERRIDE
 	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
@@ -804,8 +831,10 @@
 	/* Must be before kernel pagetables are setup */
 	vmi_activate();
 
+#ifndef CONFIG_COOPERATIVE
 	/* after early param, so could get panic from serial */
 	reserve_early_setup_data();
+#endif /* !CONFIG_COOPERATIVE */
 
 	if (acpi_mps_check()) {
 #ifdef CONFIG_X86_LOCAL_APIC
@@ -814,16 +843,19 @@
 		setup_clear_cpu_cap(X86_FEATURE_APIC);
 	}
 
+#ifndef CONFIG_COOPERATIVE
 #ifdef CONFIG_PCI
 	if (pci_early_dump_regs)
 		early_dump_pci_devices();
 #endif
 
 	finish_e820_parsing();
+#endif /* !CONFIG_COOPERATIVE */
 
 	if (efi_enabled)
 		efi_init();
 
+#ifndef CONFIG_COOPERATIVE
 	dmi_scan_machine();
 
 	dmi_check_system(bad_bios_dmi_table);
@@ -835,13 +867,16 @@
 	init_hypervisor_platform();
 
 	x86_init.resources.probe_roms();
+#endif /* !CONFIG_COOPERATIVE */
 
 	/* after parse_early_param, so could debug it */
 	insert_resource(&iomem_resource, &code_resource);
 	insert_resource(&iomem_resource, &data_resource);
 	insert_resource(&iomem_resource, &bss_resource);
 
-
+#ifdef CONFIG_COOPERATIVE
+	max_pfn = co_boot_params.co_memory_size >> PAGE_SHIFT;
+#else /* CONFIG_COOPERATIVE */
 #ifdef CONFIG_X86_32
 	if (ppro_with_ram_bug()) {
 		e820_update_range(0x70000000ULL, 0x40000ULL, E820_RAM,
@@ -866,6 +901,7 @@
 	mtrr_bp_init();
 	if (mtrr_trim_uncached_memory(max_pfn))
 		max_pfn = e820_end_of_ram_pfn();
+#endif /* CONFIG_COOPERATIVE */
 
 #ifdef CONFIG_X86_32
 	/* max_low_pfn get updated here */
@@ -933,8 +969,6 @@
 		init_ohci1394_dma_on_all_controllers();
 #endif
 
-	reserve_initrd();
-
 	reserve_crashkernel();
 
 	vsmp_init();
@@ -961,6 +995,7 @@
 #endif
 
 	initmem_init(0, max_pfn, acpi, k8);
+	reserve_initrd();
 
 #ifdef CONFIG_X86_64
 	/*
@@ -1018,15 +1053,21 @@
 
 	kvm_guest_init();
 
+#ifndef CONFIG_COOPERATIVE
 	e820_reserve_resources();
 	e820_mark_nosave_regions(max_low_pfn);
+#endif /* !CONFIG_COOPERATIVE */
 
 	x86_init.resources.reserve_resources();
 
+#ifndef CONFIG_COOPERATIVE
 	e820_setup_gap();
+#endif /* !CONFIG_COOPERATIVE */
 
 #ifdef CONFIG_VT
-#if defined(CONFIG_VGA_CONSOLE)
+#ifdef CONFIG_COOPERATIVE_CONSOLE
+	conswitchp = &colinux_con;
+#elif defined(CONFIG_VGA_CONSOLE)
 	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
 		conswitchp = &vga_con;
 #elif defined(CONFIG_DUMMY_CONSOLE)
@@ -1040,6 +1081,7 @@
 
 #ifdef CONFIG_X86_32
 
+#ifndef CONFIG_COOPERATIVE
 static struct resource video_ram_resource = {
 	.name	= "Video RAM area",
 	.start	= 0xa0000,
@@ -1052,5 +1094,6 @@
 	request_resource(&iomem_resource, &video_ram_resource);
 	reserve_standard_io_resources();
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 #endif /* CONFIG_X86_32 */
Index: linux-2.6.33-source/arch/x86/kernel/traps.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/traps.c
+++ linux-2.6.33-source/arch/x86/kernel/traps.c
@@ -30,6 +30,7 @@
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/io.h>
+#include <linux/cooperative_internal.h>
 
 #ifdef CONFIG_EISA
 #include <linux/ioport.h>
@@ -56,6 +57,7 @@
 #include <asm/mce.h>
 
 #include <asm/mach_traps.h>
+#include <asm/cooperative_internal.h>
 
 #ifdef CONFIG_X86_64
 #include <asm/x86_init.h>
@@ -172,6 +174,10 @@
 	return;
 
 kernel_trap:
+	if (cooperative_mode_enabled() && trapnr == 3) {
+		co_kernel_breakpoint(regs);
+		return;
+	}
 	if (!fixup_exception(regs)) {
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_no = trapnr;
@@ -308,6 +314,7 @@
 	die("general protection fault", regs, error_code);
 }
 
+#ifndef CONFIG_COOPERATIVE
 static notrace __kprobes void
 mem_parity_error(unsigned char reason, struct pt_regs *regs)
 {
@@ -431,6 +438,7 @@
 	reassert_nmi();
 #endif
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 dotraplinkage notrace __kprobes void
 do_nmi(struct pt_regs *regs, long error_code)
@@ -439,8 +447,10 @@
 
 	inc_irq_stat(__nmi_count);
 
+#ifndef CONFIG_COOPERATIVE
 	if (!ignore_nmis)
 		default_do_nmi(regs);
+#endif /* !CONFIG_COOPERATIVE */
 
 	nmi_exit();
 }
@@ -558,6 +568,10 @@
 	/* Store the virtualized DR6 value */
 	tsk->thread.debugreg6 = dr6;
 
+	if (cooperative_mode_enabled() &&
+	    co_kernel_debug(regs, error_code, dr6))
+		return;
+
 	if (notify_die(DIE_DEBUG, "debug", regs, PTR_ERR(&dr6), error_code,
 							SIGTRAP) == NOTIFY_STOP)
 		return;
@@ -833,6 +847,13 @@
 
 	clts();				/* Allow maths ops (or we recurse) */
 
+#ifdef CONFIG_COOPERATIVE
+	if (!co_host_fpu_saved) {
+		CO_FPU_SAVE(co_host_fpu);
+		co_host_fpu_saved = 1;
+	}
+#endif /* CONFIG_COOPERATIVE */
+
 	__math_state_restore();
 }
 EXPORT_SYMBOL_GPL(math_state_restore);
Index: linux-2.6.33-source/arch/x86/mm/fault.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/fault.c
+++ linux-2.6.33-source/arch/x86/mm/fault.c
@@ -317,7 +317,7 @@
 		goto out;
 
 	pte = pte_offset_kernel(pmd, address);
-	printk("*pte = %0*Lx ", sizeof(*pte) * 2, (u64)pte_val(*pte));
+	printk("*pte = %0*Lx ", sizeof(*pte) * 2, (u64)CO_P_TO_PP(pte_val(*pte)));
 out:
 	printk("\n");
 }
Index: linux-2.6.33-source/arch/x86/mm/init_32.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/init_32.c
+++ linux-2.6.33-source/arch/x86/mm/init_32.c
@@ -27,6 +27,7 @@
 #include <linux/bootmem.h>
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
+#include <linux/cooperative_internal.h>
 #include <linux/memory_hotplug.h>
 #include <linux/initrd.h>
 #include <linux/cpumask.h>
@@ -54,10 +55,15 @@
 
 unsigned long highstart_pfn, highend_pfn;
 
+#ifndef CONFIG_COOPERATIVE
 static noinline int do_test_wp_bit(void);
+#endif
 
 bool __read_mostly __vmalloc_start_set = false;
 
+/* colinux start_va */
+static long co_start_va = 0;
+
 static __init void *alloc_low_page(void)
 {
 	unsigned long pfn = e820_table_end++;
@@ -121,7 +127,7 @@
 			page_table = (pte_t *)alloc_low_page();
 
 		paravirt_alloc_pte(&init_mm, __pa(page_table) >> PAGE_SHIFT);
-		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+		set_pmd(pmd, __pmd(CO_PP_TO_P(__pa(page_table)) | _PAGE_TABLE));
 		BUG_ON(page_table != pte_offset_kernel(pmd, 0));
 	}
 
@@ -223,6 +229,7 @@
 	}
 }
 
+#ifndef CONFIG_COOPERATIVE
 static inline int is_kernel_text(unsigned long addr)
 {
 	if (addr >= PAGE_OFFSET && addr <= (unsigned long)__init_end)
@@ -370,6 +377,7 @@
 	}
 	return 0;
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 pte_t *kmap_pte;
 pgprot_t kmap_prot;
@@ -471,6 +479,7 @@
 
 void __init native_pagetable_setup_start(pgd_t *base)
 {
+#ifndef CONFIG_COOPERATIVE
 	unsigned long pfn, va;
 	pgd_t *pgd;
 	pud_t *pud;
@@ -499,6 +508,7 @@
 		pte_clear(NULL, va, pte);
 	}
 	paravirt_alloc_pmd(&init_mm, __pa(base) >> PAGE_SHIFT);
+#endif /* CONFIG_COOPERATIVE */
 }
 
 void __init native_pagetable_setup_done(pgd_t *base)
@@ -717,7 +727,18 @@
 	num_physpages = highend_pfn;
 	high_memory = (void *) __va(highstart_pfn * PAGE_SIZE - 1) + 1;
 #else
+#ifdef CONFIG_COOPERATIVE
+	/* Allocate boot memory from host */
+	max_low_pfn = max_pfn = co_boot_params.co_memory_size >> PAGE_SHIFT;
+	min_low_pfn = PFN_UP(__pa((unsigned long)&_end)) + 0x10;
+	co_start_va = (unsigned long)__va(min_low_pfn << PAGE_SHIFT);
+	co_alloc_pages(co_start_va, 0x20);
+
+	/* Add single region without check via e820_find_active_region */
+	add_active_range(0, 0, max_low_pfn);
+#else /* CONFIG_COOPERATIVE */
 	e820_register_active_regions(0, 0, max_low_pfn);
+#endif /* CONFIG_COOPERATIVE */
 	sparse_memory_present_with_active_regions(0);
 	num_physpages = max_low_pfn;
 	high_memory = (void *) __va(max_low_pfn * PAGE_SIZE - 1) + 1;
@@ -738,8 +759,10 @@
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
 	memset(max_zone_pfns, 0, sizeof(max_zone_pfns));
+#ifndef CONFIG_COOPERATIVE
 	max_zone_pfns[ZONE_DMA] =
 		virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+#endif
 	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
 #ifdef CONFIG_HIGHMEM
 	max_zone_pfns[ZONE_HIGHMEM] = highend_pfn;
@@ -748,6 +771,7 @@
 	free_area_init_nodes(max_zone_pfns);
 }
 
+#ifndef CONFIG_COOPERATIVE
 static unsigned long __init setup_node_bootmem(int nodeid,
 				 unsigned long start_pfn,
 				 unsigned long end_pfn,
@@ -768,25 +792,40 @@
 
 	return bootmap + bootmap_size;
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 void __init setup_bootmem_allocator(void)
 {
-	int nodeid;
-	unsigned long bootmap_size, bootmap;
 	/*
 	 * Initialize the boot-time allocator (with low memory only):
 	 */
+#ifdef CONFIG_COOPERATIVE
+	unsigned long bootmap_size;
+
+	bootmap_size = init_bootmem(min_low_pfn, max_low_pfn);
+	{
+		unsigned long bootmem_end = co_start_va + bootmap_size + (0x10 << PAGE_SHIFT);
+		unsigned long physical_end = __PAGE_OFFSET + (max_low_pfn << PAGE_SHIFT);
+
+		free_bootmem(__pa(bootmem_end), physical_end - bootmem_end);
+	}
+#else /* CONFIG_COOPERATIVE */
+	int nodeid;
+	unsigned long bootmap_size, bootmap;
+
 	bootmap_size = bootmem_bootmap_pages(max_low_pfn)<<PAGE_SHIFT;
 	bootmap = find_e820_area(0, max_pfn_mapped<<PAGE_SHIFT, bootmap_size,
 				 PAGE_SIZE);
 	if (bootmap == -1L)
 		panic("Cannot find bootmem map of size %ld\n", bootmap_size);
 	reserve_early(bootmap, bootmap + bootmap_size, "BOOTMAP");
+#endif /* CONFIG_COOPERATIVE */
 
 	printk(KERN_INFO "  mapped low ram: 0 - %08lx\n",
 		 max_pfn_mapped<<PAGE_SHIFT);
 	printk(KERN_INFO "  low ram: 0 - %08lx\n", max_low_pfn<<PAGE_SHIFT);
 
+#ifndef CONFIG_COOPERATIVE
 	for_each_online_node(nodeid) {
 		 unsigned long start_pfn, end_pfn;
 
@@ -804,6 +843,7 @@
 		bootmap = setup_node_bootmem(nodeid, start_pfn, end_pfn,
 						 bootmap);
 	}
+#endif /* !CONFIG_COOPERATIVE */
 
 	after_bootmem = 1;
 }
@@ -836,6 +876,7 @@
  * black magic jumps to work around some nasty CPU bugs, but fortunately the
  * switch to using exceptions got rid of all that.
  */
+#ifndef CONFIG_COOPERATIVE
 static void __init test_wp_bit(void)
 {
 	printk(KERN_INFO
@@ -856,13 +897,16 @@
 		printk(KERN_CONT "Ok.\n");
 	}
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 void __init mem_init(void)
 {
 	int codesize, reservedpages, datasize, initsize;
 	int tmp;
 
+#ifndef CONFIG_COOPERATIVE
 	pci_iommu_alloc();
+#endif
 
 #ifdef CONFIG_FLATMEM
 	BUG_ON(!mem_map);
@@ -895,15 +939,15 @@
 		totalhigh_pages << (PAGE_SHIFT-10));
 
 	printk(KERN_INFO "virtual kernel memory layout:\n"
-		"    fixmap  : 0x%08lx - 0x%08lx   (%4ld kB)\n"
+		"   fixmap  : 0x%08lx - 0x%08lx  (%4ld kB)\n"
 #ifdef CONFIG_HIGHMEM
-		"    pkmap   : 0x%08lx - 0x%08lx   (%4ld kB)\n"
+		"   pkmap   : 0x%08lx - 0x%08lx  (%4ld kB)\n"
 #endif
-		"    vmalloc : 0x%08lx - 0x%08lx   (%4ld MB)\n"
-		"    lowmem  : 0x%08lx - 0x%08lx   (%4ld MB)\n"
-		"      .init : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-		"      .data : 0x%08lx - 0x%08lx   (%4ld kB)\n"
-		"      .text : 0x%08lx - 0x%08lx   (%4ld kB)\n",
+#ifdef CONFIG_COOPERATIVE
+		"   colinux : 0x%08lx - 0x%08lx  (%4ld MB)\n"
+#endif
+		"   vmalloc : 0x%08lx - 0x%08lx  (%4ld MB)\n",
+
 		FIXADDR_START, FIXADDR_TOP,
 		(FIXADDR_TOP - FIXADDR_START) >> 10,
 
@@ -911,9 +955,19 @@
 		PKMAP_BASE, PKMAP_BASE+LAST_PKMAP*PAGE_SIZE,
 		(LAST_PKMAP*PAGE_SIZE) >> 10,
 #endif
+#ifdef CONFIG_COOPERATIVE
+		CO_VPTR_BASE_START, CO_VPTR_BASE_END,
+		(CO_VPTR_BASE_END - CO_VPTR_BASE_START) >> 20,
+#endif
 
 		VMALLOC_START, VMALLOC_END,
-		(VMALLOC_END - VMALLOC_START) >> 20,
+		(VMALLOC_END - VMALLOC_START) >> 20);
+
+	printk(KERN_INFO
+		"   lowmem  : 0x%08lx - 0x%08lx  (%4ld MB)\n"
+		"     .init : 0x%08lx - 0x%08lx  (%4ld kB)\n"
+		"     .data : 0x%08lx - 0x%08lx  (%4ld kB)\n"
+		"     .text : 0x%08lx - 0x%08lx  (%4ld kB)\n",
 
 		(unsigned long)__va(0), (unsigned long)high_memory,
 		((unsigned long)high_memory - (unsigned long)__va(0)) >> 20,
@@ -946,11 +1000,19 @@
 	BUG_ON(PKMAP_BASE + LAST_PKMAP*PAGE_SIZE	> FIXADDR_START);
 	BUG_ON(VMALLOC_END				> PKMAP_BASE);
 #endif
+#ifdef CONFIG_COOPERATIVE
+	BUG_ON(CO_VPTR_BASE_END				> FIXADDR_START);
+	BUG_ON(VMALLOC_END				> CO_VPTR_BASE_START);
+	if (VMALLOC_START > VMALLOC_END)
+		panic("LOWMEM overlaps vmalloc. Decrease total memory with 'mem=...'!");
+#endif
 	BUG_ON(VMALLOC_START				>= VMALLOC_END);
 	BUG_ON((unsigned long)high_memory		> VMALLOC_START);
 
+#ifndef CONFIG_COOPERATIVE
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
+#endif
 
 	save_pg_dir();
 	zap_low_mappings(true);
@@ -972,6 +1034,7 @@
  * This function cannot be __init, since exceptions don't work in that
  * section.  Put this after the callers, so that it cannot be inlined.
  */
+#ifndef CONFIG_COOPERATIVE
 static noinline int do_test_wp_bit(void)
 {
 	char tmp_reg;
@@ -991,6 +1054,7 @@
 
 	return flag;
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 #ifdef CONFIG_DEBUG_RODATA
 const int rodata_test_data = 0xC3;
Index: linux-2.6.33-source/arch/x86/mm/init.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/init.c
+++ linux-2.6.33-source/arch/x86/mm/init.c
@@ -28,6 +28,7 @@
 #endif
 ;
 
+#ifndef CONFIG_COOPERATIVE
 static void __init find_early_table_space(unsigned long end, int use_pse,
 					  int use_gbpages)
 {
@@ -86,6 +87,7 @@
 	printk(KERN_DEBUG "kernel direct mapping tables up to %lx @ %lx-%lx\n",
 		end, e820_table_start << PAGE_SHIFT, e820_table_top << PAGE_SHIFT);
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 struct map_range {
 	unsigned long start;
@@ -146,6 +148,7 @@
 	use_gbpages = direct_gbpages;
 #endif
 
+#ifndef CONFIG_COOPERATIVE
 	/* Enable PSE if available */
 	if (cpu_has_pse)
 		set_in_cr4(X86_CR4_PSE);
@@ -160,6 +163,7 @@
 		page_size_mask |= 1 << PG_LEVEL_1G;
 	if (use_pse)
 		page_size_mask |= 1 << PG_LEVEL_2M;
+#endif /* !CONFIG_COOPERATIVE */
 
 	memset(mr, 0, sizeof(mr));
 	nr_range = 0;
@@ -256,6 +260,9 @@
 			(mr[i].page_size_mask & (1<<PG_LEVEL_1G))?"1G":(
 			 (mr[i].page_size_mask & (1<<PG_LEVEL_2M))?"2M":"4k"));
 
+#ifdef CONFIG_COOPERATIVE
+	ret = end;
+#else /* CONFIG_COOPERATIVE */
 	/*
 	 * Find space for the kernel direct mapping tables.
 	 *
@@ -310,6 +317,7 @@
 
 	if (!after_bootmem)
 		early_memtest(start, end);
+#endif /* CONFIG_COOPERATIVE */
 
 	return ret >> PAGE_SHIFT;
 }
@@ -349,16 +357,20 @@
 	 * create a kernel page fault:
 	 */
 #ifdef CONFIG_DEBUG_PAGEALLOC
+#ifndef CONFIG_COOPERATIVE
 	printk(KERN_INFO "debug: unmapping init memory %08lx..%08lx\n",
 		begin, PAGE_ALIGN(end));
 	set_memory_np(begin, (end - begin) >> PAGE_SHIFT);
+#endif /* !CONFIG_COOPERATIVE */
 #else
 	/*
 	 * We just marked the kernel text read only above, now that
 	 * we are going to free part of that, we need to make that
 	 * writeable first.
 	 */
+#ifndef CONFIG_COOPERATIVE
 	set_memory_rw(begin, (end - begin) >> PAGE_SHIFT);
+#endif /* !CONFIG_COOPERATIVE */
 
 	printk(KERN_INFO "Freeing %s: %luk freed\n", what, (end - begin) >> 10);
 
Index: linux-2.6.33-source/arch/x86/mm/pageattr.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/pageattr.c
+++ linux-2.6.33-source/arch/x86/mm/pageattr.c
@@ -1122,6 +1122,8 @@
 }
 EXPORT_SYMBOL(set_memory_nx);
 
+// FIXME: Make it usable. Flags must change on host too
+#ifndef CONFIG_COOPERATIVE
 int set_memory_ro(unsigned long addr, int numpages)
 {
 	return change_page_attr_clear(&addr, numpages, __pgprot(_PAGE_RW), 0);
@@ -1138,6 +1140,7 @@
 {
 	return change_page_attr_clear(&addr, numpages, __pgprot(_PAGE_PRESENT), 0);
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 int set_memory_4k(unsigned long addr, int numpages)
 {
@@ -1234,6 +1237,7 @@
 }
 EXPORT_SYMBOL(set_pages_nx);
 
+#ifndef CONFIG_COOPERATIVE
 int set_pages_ro(struct page *page, int numpages)
 {
 	unsigned long addr = (unsigned long)page_address(page);
@@ -1247,6 +1251,7 @@
 
 	return set_memory_rw(addr, numpages);
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 #ifdef CONFIG_DEBUG_PAGEALLOC
 
Index: linux-2.6.33-source/arch/x86/mm/ioremap.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/ioremap.c
+++ linux-2.6.33-source/arch/x86/mm/ioremap.c
@@ -13,6 +13,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/mmiotrace.h>
+#include <linux/cooperative_internal.h>
 
 #include <asm/cacheflush.h>
 #include <asm/e820.h>
@@ -26,8 +27,10 @@
 
 int page_is_ram(unsigned long pagenr)
 {
+#ifndef CONFIG_COOPERATIVE
 	resource_size_t addr, end;
 	int i;
+#endif
 
 	/*
 	 * A special case is the first 4Kb of memory;
@@ -45,6 +48,7 @@
 		    pagenr < (BIOS_END >> PAGE_SHIFT))
 		return 0;
 
+#ifndef CONFIG_COOPERATIVE
 	for (i = 0; i < e820.nr_map; i++) {
 		/*
 		 * Not usable memory:
@@ -58,6 +62,7 @@
 		if ((pagenr >= addr) && (pagenr < end))
 			return 1;
 	}
+#endif /* !CONFIG_COOPERATIVE */
 	return 0;
 }
 
@@ -87,6 +92,7 @@
 	return err;
 }
 
+#ifndef CONFIG_COOPERATIVE
 /*
  * Remap an arbitrary physical address space into the kernel virtual
  * address space. Needed when the kernel wants to access high addresses
@@ -216,6 +222,7 @@
 	free_memtype(phys_addr, phys_addr + size);
 	return NULL;
 }
+#endif /* !CONFIG_COOPERATIVE */
 
 /**
  * ioremap_nocache     -   map bus memory into CPU space
@@ -240,6 +247,11 @@
  */
 void __iomem *ioremap_nocache(resource_size_t phys_addr, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap_nocache %zu:%lu\n", phys_addr, size);
+	return NULL;
+#else /* CONFIG_COOPERATIVE */
+
 	/*
 	 * Ideally, this should be:
 	 *	pat_enabled ? _PAGE_CACHE_UC : _PAGE_CACHE_UC_MINUS;
@@ -251,6 +263,7 @@
 
 	return __ioremap_caller(phys_addr, size, val,
 				__builtin_return_address(0));
+#endif /* CONFIG_COOPERATIVE */
 }
 EXPORT_SYMBOL(ioremap_nocache);
 
@@ -266,26 +279,41 @@
  */
 void __iomem *ioremap_wc(resource_size_t phys_addr, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap_wc %zu:%lu\n", phys_addr, size);
+	return NULL;
+#else /* CONFIG_COOPERATIVE */
 	if (pat_enabled)
 		return __ioremap_caller(phys_addr, size, _PAGE_CACHE_WC,
 					__builtin_return_address(0));
 	else
 		return ioremap_nocache(phys_addr, size);
+#endif /* CONFIG_COOPERATIVE */
 }
 EXPORT_SYMBOL(ioremap_wc);
 
 void __iomem *ioremap_cache(resource_size_t phys_addr, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap_cache %zu:%lu\n", phys_addr, size);
+	return NULL;
+#else /* CONFIG_COOPERATIVE */
 	return __ioremap_caller(phys_addr, size, _PAGE_CACHE_WB,
 				__builtin_return_address(0));
+#endif /* CONFIG_COOPERATIVE */
 }
 EXPORT_SYMBOL(ioremap_cache);
 
 void __iomem *ioremap_prot(resource_size_t phys_addr, unsigned long size,
 				unsigned long prot_val)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap_prot %zu:%lu\n", phys_addr, size);
+	return NULL;
+#else /* CONFIG_COOPERATIVE */
 	return __ioremap_caller(phys_addr, size, (prot_val & _PAGE_CACHE_MASK),
 				__builtin_return_address(0));
+#endif /* CONFIG_COOPERATIVE */
 }
 EXPORT_SYMBOL(ioremap_prot);
 
Index: linux-2.6.33-source/arch/x86/include/asm/bug.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/bug.h
+++ linux-2.6.33-source/arch/x86/include/asm/bug.h
@@ -4,6 +4,10 @@
 #ifdef CONFIG_BUG
 #define HAVE_ARCH_BUG
 
+#ifdef CONFIG_COOPERATIVE
+extern void co_terminate_bug(int code, int line, const char *file);
+#define BUG() do { co_terminate_bug(0, __LINE__, __FILE__); } while(0)
+#else /* CONFIG_COOPERATIVE */
 #ifdef CONFIG_DEBUG_BUGVERBOSE
 
 #ifdef CONFIG_X86_32
@@ -34,6 +38,7 @@
 #endif
 
 #endif /* !CONFIG_BUG */
+#endif /* CONFIG_COOPERATIVE */
 
 #include <asm-generic/bug.h>
 #endif /* _ASM_X86_BUG_H */
Index: linux-2.6.33-source/arch/x86/include/asm/cooperative.h
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/include/asm/cooperative.h
@@ -0,0 +1,205 @@
+/*
+ *  linux/include/asm/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the lower level interfaces between the Cooperative Linux
+ *  kernel and the host OS driver. It's for both external inclusion from the
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_ASM_COOPERATIVE_H__
+#define __LINUX_ASM_COOPERATIVE_H__
+
+typedef struct {
+	unsigned short size;
+	struct x86_idt_entry *table;
+} __attribute__((packed)) x86_idt_t;
+
+typedef struct {
+	unsigned short limit;
+	struct x86_dt_entry *base;
+} __attribute__((packed)) x86_gdt_t;
+
+typedef struct {
+	unsigned char border2[0x4];
+
+	unsigned long cs;
+        #define CO_ARCH_STATE_STACK_CS "0x04"
+
+	unsigned long ds;
+        #define CO_ARCH_STATE_STACK_DS "0x08"
+
+	unsigned long es;
+        #define CO_ARCH_STATE_STACK_ES "0x0C"
+
+	unsigned long cr3;
+        #define CO_ARCH_STATE_STACK_CR3 "0x10"
+
+	unsigned long cr4;
+        #define CO_ARCH_STATE_STACK_CR4 "0x14"
+
+	unsigned long cr2;
+        #define CO_ARCH_STATE_STACK_CR2 "0x18"
+
+	unsigned long cr0;
+        #define CO_ARCH_STATE_STACK_CR0 "0x1C"
+
+	x86_gdt_t gdt;
+        #define CO_ARCH_STATE_STACK_GDT "0x20"
+
+	unsigned long fs;
+        #define CO_ARCH_STATE_STACK_FS  "0x26"
+
+	unsigned long gs;
+        #define CO_ARCH_STATE_STACK_GS  "0x2A"
+
+	unsigned short ldt;
+        #define CO_ARCH_STATE_STACK_LDT "0x2E"
+
+	x86_idt_t idt;
+        #define CO_ARCH_STATE_STACK_IDT "0x30"
+
+	unsigned short tr;
+        #define CO_ARCH_STATE_STACK_TR  "0x36"
+
+	unsigned long return_eip;
+        #define CO_ARCH_STATE_STACK_RETURN_EIP  "0x38"
+
+	unsigned long flags;
+        #define CO_ARCH_STATE_STACK_FLAGS "0x3C"
+
+	unsigned long esp;
+        #define CO_ARCH_STATE_STACK_ESP "0x40"
+
+	unsigned long ss;
+        #define CO_ARCH_STATE_STACK_SS "0x44"
+
+	unsigned long dr0;
+        #define CO_ARCH_STATE_STACK_DR0 "0x48"
+
+	unsigned long dr1;
+        #define CO_ARCH_STATE_STACK_DR1 "0x4C"
+
+	unsigned long dr2;
+        #define CO_ARCH_STATE_STACK_DR2 "0x50"
+
+	unsigned long dr3;
+        #define CO_ARCH_STATE_STACK_DR3 "0x54"
+
+	unsigned long dr6;
+        #define CO_ARCH_STATE_STACK_DR6 "0x58"
+
+	unsigned long dr7;
+        #define CO_ARCH_STATE_STACK_DR7 "0x5C"
+
+	union {
+		unsigned long temp_cr3;
+		unsigned long other_map;
+	} __attribute__((packed));
+        #define CO_ARCH_STATE_STACK_TEMP_CR3 "0x60"
+        #define CO_ARCH_STATE_STACK_OTHERMAP "0x60"
+
+	unsigned long relocate_eip;
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP "0x64"
+
+	unsigned long pad1;
+        #define CO_ARCH_STATE_STACK_RELOCATE_EIP_AFTER "0x68"
+
+	unsigned long va;
+        #define CO_ARCH_STATE_STACK_VA "0x6C"
+
+	unsigned long sysenter_cs;
+        #define CO_ARCH_STATE_SYSENTER_CS "0x70"
+
+	unsigned long sysenter_esp;
+        #define CO_ARCH_STATE_SYSENTER_ESP "0x74"
+
+	unsigned long sysenter_eip;
+        #define CO_ARCH_STATE_SYSENTER_EIP "0x78"
+} __attribute__((packed)) co_arch_state_stack_t;
+
+#define CO_MAX_PARAM_SIZE 0x400
+
+typedef struct co_arch_passage_page_normal_address_space {
+	unsigned long pgd[0x400];
+	unsigned long pte[2][0x400];
+} co_arch_passage_page_normal_address_space_t;
+
+typedef struct co_arch_passage_page_pae_address_space {
+	unsigned long long main[0x200];
+	unsigned long long pgd[2][0x200];
+	unsigned long long pte[2][0x200];
+} co_arch_passage_page_pae_address_space_t;
+
+typedef struct co_arch_passage_page {
+	union {
+		struct {
+			union {
+				struct {
+					union {
+						unsigned long self_physical_address;
+						unsigned long temp_pgd_physical;
+					} __attribute__((packed));
+					unsigned long dr0;
+					unsigned long dr1;
+					unsigned long dr2;
+					unsigned long dr3;
+					unsigned long dr6;
+					unsigned long dr7;
+					unsigned char code[0x260];
+				} __attribute__((packed));
+				unsigned char pad[0x280]; /* Be careful! see NOTE below */
+			} __attribute__((packed));
+
+			/* Machine states */
+
+			/*
+			 * NOTE: *_state fields must be aligned at 16 bytes boundary since
+			 * the fxsave/fxload instructions expect an aligned arugment.
+			 */
+
+			co_arch_state_stack_t host_state;
+			co_arch_state_stack_t linuxvm_state;
+
+			/* Control parameters */
+			unsigned long operation;
+			unsigned long params[];
+		} __attribute__((packed));
+		unsigned char first_page[0x1000];
+	};
+
+	/* page tables for passage address spaces */
+	union {
+		co_arch_passage_page_normal_address_space_t guest_normal;
+		co_arch_passage_page_normal_address_space_t temp_space;
+	} __attribute__((packed));
+	union {
+		co_arch_passage_page_normal_address_space_t host_normal;
+		co_arch_passage_page_pae_address_space_t host_pae;
+	} __attribute__((packed));
+} co_arch_passage_page_t;
+
+/*
+ * Address space layout:
+ */
+
+#define CO_VPTR_BASE                         (0xffc00000UL)
+#define CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP   (CO_VPTR_BASE - 0x1000000UL)
+#define CO_VPTR_PSEUDO_RAM_PAGE_TABLES       (CO_VPTR_BASE - 0x1100000UL)
+#define CO_VPTR_PASSAGE_PAGE                 (CO_VPTR_BASE - 0x1101000UL)
+#define CO_VPTR_IO_AREA_SIZE                 (0x10000UL)
+#define CO_VPTR_IO_AREA_START                (CO_VPTR_BASE - 0x1200000UL)
+#define CO_VPTR_SELF_MAP                     (CO_VPTR_BASE - 0x1400000UL)
+
+#define CO_VPTR_BASE_START			CO_VPTR_SELF_MAP
+#define CO_VPTR_BASE_END			CO_VPTR_BASE
+
+#define CO_LOWMEMORY_MAX_MB 984
+
+typedef struct {
+	unsigned long kernel_cs;
+	unsigned long kernel_ds;
+} __attribute__((packed)) co_arch_info_t;
+
+#endif
Index: linux-2.6.33-source/arch/x86/include/asm/cooperative_internal.h
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/include/asm/cooperative_internal.h
@@ -0,0 +1,53 @@
+/*
+ *  linux/include/asm/cooperative_internal.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ */
+
+#ifndef __LINUX_ASM_COOPERATIVE_INTERNAL_H__
+#define __LINUX_ASM_COOPERATIVE_INTERNAL_H__
+
+#include <asm/ptrace.h>
+
+#ifdef CONFIG_COOPERATIVE
+
+extern bool co_host_fpu_saved;
+extern char co_host_fpu[0x200];
+
+extern void co_kernel_breakpoint(struct pt_regs * regs);
+extern int co_kernel_debug(struct pt_regs * regs, long error_code, unsigned int condition);
+
+#define CO_FPU_SAVE(x) \
+do \
+{ \
+	if (cpu_has_fxsr) \
+		asm("fxsave " #x " ; fnclex"); \
+	else \
+		asm("fnsave " #x " ; fwait"); \
+} \
+while (0)
+
+#define CO_FPU_RESTORE(x) \
+do \
+{ \
+	if (cpu_has_fxsr) \
+		asm("fxrstor " #x); \
+	else \
+		asm("frstor " #x); \
+} \
+while (0)
+
+#else
+
+static inline void co_kernel_breakpoint(struct pt_regs * regs)
+{
+}
+
+static inline int co_kernel_debug(struct pt_regs * regs, long error_code, unsigned int condition)
+{
+	return 0;
+}
+
+#endif
+
+#endif
Index: linux-2.6.33-source/arch/x86/include/asm/dma.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/dma.h
+++ linux-2.6.33-source/arch/x86/include/asm/dma.h
@@ -287,6 +287,7 @@
  *
  * Assumes DMA flip-flop is clear.
  */
+#ifndef CONFIG_COOPERATIVE
 static inline int get_dma_residue(unsigned int dmanr)
 {
 	unsigned int io_port;
@@ -301,6 +302,7 @@
 
 	return (dmanr <= 3) ? count : (count << 1);
 }
+#endif
 
 
 /* These are in kernel/dma.c: */
Index: linux-2.6.33-source/arch/x86/include/asm/irq_vectors.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/irq_vectors.h
+++ linux-2.6.33-source/arch/x86/include/asm/irq_vectors.h
@@ -67,6 +67,18 @@
 #define IRQ14_VECTOR			(IRQ0_VECTOR + 14)
 #define IRQ15_VECTOR			(IRQ0_VECTOR + 15)
 
+#ifdef CONFIG_COOPERATIVE
+#define TIMER_IRQ 0
+#define KEYBOARD_IRQ 1
+#define SERIAL_IRQ 3
+#define SOUND_IRQ 5
+#define POWER_IRQ 9
+#define NETWORK_IRQ 10
+#define SCSI_IRQ 11
+#define MOUSE_IRQ 12
+#define BLOCKDEV_IRQ 15
+#endif
+
 /*
  * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
  *
@@ -157,7 +169,9 @@
 #define CPU_VECTOR_LIMIT		(  8 * NR_CPUS      )
 #define IO_APIC_VECTOR_LIMIT		( 32 * MAX_IO_APICS )
 
-#ifdef CONFIG_X86_IO_APIC
+#ifdef CONFIG_COOPERATIVE
+# define NR_IRQS			(NR_VECTORS - FIRST_EXTERNAL_VECTOR)
+#elif defined(CONFIG_X86_IO_APIC)
 # ifdef CONFIG_SPARSE_IRQ
 #  define NR_IRQS					\
 	(CPU_VECTOR_LIMIT > IO_APIC_VECTOR_LIMIT ?	\
Index: linux-2.6.33-source/arch/x86/include/asm/mc146818rtc.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/mc146818rtc.h
+++ linux-2.6.33-source/arch/x86/include/asm/mc146818rtc.h
@@ -87,6 +87,8 @@
 #define current_lock_cmos_reg() 0
 #endif
 
+#ifndef CONFIG_COOPERATIVE
+
 /*
  * The yet supported machines all access the RTC index register via
  * an ISA port access but the way to access the date register differs ...
@@ -99,6 +101,11 @@
 extern int mach_set_rtc_mmss(unsigned long nowtime);
 extern unsigned long mach_get_cmos_time(void);
 
+#else
+#define CMOS_READ(addr) (0)
+#define CMOS_WRITE(val, addr) do {} while(0)
+#endif
+
 #define RTC_IRQ 8
 
 #endif /* _ASM_X86_MC146818RTC_H */
Index: linux-2.6.33-source/arch/x86/include/asm/page.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/page.h
+++ linux-2.6.33-source/arch/x86/include/asm/page.h
@@ -14,6 +14,7 @@
 #endif	/* CONFIG_X86_64 */
 
 #ifndef __ASSEMBLY__
+#include <asm/cooperative.h>
 
 struct page;
 
@@ -53,6 +54,20 @@
 extern bool __virt_addr_valid(unsigned long kaddr);
 #define virt_addr_valid(kaddr)	__virt_addr_valid((unsigned long) (kaddr))
 
+#ifdef CONFIG_COOPERATIVE
+#define CO_PA(pfn)		(((unsigned long *)CO_VPTR_PSEUDO_RAM_PAGE_TABLES)[pfn])
+#define CO_VA_PFN(pa)		(((unsigned long *)CO_VPTR_PHYSICAL_TO_PSEUDO_PFN_MAP)[((pa) >> PAGE_SHIFT)])
+#define CO_PFN_PP_TO_P(pfn)	(CO_PA(pfn) >> PAGE_SHIFT)
+#define CO_PFN_P_TO_PP(pfn)	(CO_VA_PFN(pfn << PAGE_SHIFT))
+#define CO_PP_TO_P(pa)	        ((CO_PFN_PP_TO_P(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#define CO_P_TO_PP(pa)	        ((CO_PFN_P_TO_PP(pa >> PAGE_SHIFT) << PAGE_SHIFT) | (pa & ~PAGE_MASK))
+#else
+#define CO_PFN_P_TO_PP(pfn)	pfn
+#define CO_PFN_PP_TO_P(pfn)	pfn
+#define CO_PP_TO_P(pa)        	pa
+#define CO_P_TO_PP(pa)	        pa
+#endif
+
 #endif	/* __ASSEMBLY__ */
 
 #include <asm-generic/memory_model.h>
Index: linux-2.6.33-source/arch/x86/include/asm/pgtable-2level.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pgtable-2level.h
+++ linux-2.6.33-source/arch/x86/include/asm/pgtable-2level.h
@@ -1,6 +1,8 @@
 #ifndef _ASM_X86_PGTABLE_2LEVEL_H
 #define _ASM_X86_PGTABLE_2LEVEL_H
 
+#include <asm/cooperative.h>
+
 #define pte_ERROR(e) \
 	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, (e).pte_low)
 #define pgd_ERROR(e) \
Index: linux-2.6.33-source/arch/x86/include/asm/pgtable.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pgtable.h
+++ linux-2.6.33-source/arch/x86/include/asm/pgtable.h
@@ -124,7 +124,7 @@
 
 static inline unsigned long pte_pfn(pte_t pte)
 {
-	return (pte_val(pte) & PTE_PFN_MASK) >> PAGE_SHIFT;
+	return CO_PFN_P_TO_PP((pte_val(pte) & PTE_PFN_MASK) >> PAGE_SHIFT);
 }
 
 static inline unsigned long pmd_pfn(pmd_t pmd)
@@ -230,13 +230,13 @@
 
 static inline pte_t pfn_pte(unsigned long page_nr, pgprot_t pgprot)
 {
-	return __pte(((phys_addr_t)page_nr << PAGE_SHIFT) |
+	return __pte(((phys_addr_t)CO_PFN_PP_TO_P(page_nr) << PAGE_SHIFT) |
 		     massage_pgprot(pgprot));
 }
 
 static inline pmd_t pfn_pmd(unsigned long page_nr, pgprot_t pgprot)
 {
-	return __pmd(((phys_addr_t)page_nr << PAGE_SHIFT) |
+	return __pmd(((phys_addr_t)CO_PFN_PP_TO_P(page_nr) << PAGE_SHIFT) |
 		     massage_pgprot(pgprot));
 }
 
@@ -341,14 +341,14 @@
 
 static inline unsigned long pmd_page_vaddr(pmd_t pmd)
 {
-	return (unsigned long)__va(pmd_val(pmd) & PTE_PFN_MASK);
+	return (unsigned long)__va(CO_P_TO_PP(pmd_val(pmd)) & PTE_PFN_MASK);
 }
 
 /*
  * Currently stuck as a macro due to indirect forward reference to
  * linux/mmzone.h's __section_mem_map_addr() definition:
  */
-#define pmd_page(pmd)	pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT)
+#define pmd_page(pmd)	pfn_to_page(CO_P_TO_PP(pmd_val(pmd)) >> PAGE_SHIFT)
 
 /*
  * the pmd page can be thought of an array like this: pmd_t[PTRS_PER_PMD]
Index: linux-2.6.33-source/arch/x86/include/asm/processor.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/processor.h
+++ linux-2.6.33-source/arch/x86/include/asm/processor.h
@@ -243,6 +243,7 @@
 } __attribute__((packed)) ____cacheline_aligned;
 #endif
 
+#ifdef __KERNEL__
 /*
  * IO-bitmap sizes:
  */
@@ -677,6 +678,7 @@
 
 	return eax;
 }
+#endif /* __KERNEL__ */
 
 static inline unsigned int cpuid_ebx(unsigned int op)
 {
Index: linux-2.6.33-source/include/linux/cooperative.h
===================================================================
--- /dev/null
+++ linux-2.6.33-source/include/linux/cooperative.h
@@ -0,0 +1,399 @@
+/*
+ *  linux/include/linux/cooperative.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This file defines the interfaces between the Cooperative Linux kernel
+ *  and the host OS driver. It's for both external inclusion from the
+ *  and internal inclusion in the kernel sources.
+ */
+
+#ifndef __LINUX_COOPERATIVE_H__
+#define __LINUX_COOPERATIVE_H__
+
+#ifdef __KERNEL__
+#ifndef CO_KERNEL
+#define CO_COLINUX_KERNEL
+#define CO_KERNEL
+#endif
+#endif
+
+#include <asm/cooperative.h>
+
+#define CO_LINUX_API_VERSION    14
+
+#pragma pack(0)
+
+#define CO_BOOTPARAM_STRING_LENGTH 0x100
+
+typedef enum {
+	CO_OPERATION_EMPTY=0,
+	CO_OPERATION_START,
+	CO_OPERATION_IDLE,
+	CO_OPERATION_TERMINATE,
+	CO_OPERATION_MESSAGE_TO_MONITOR,
+	CO_OPERATION_MESSAGE_FROM_MONITOR,
+	CO_OPERATION_FORWARD_INTERRUPT,
+	CO_OPERATION_DEVICE,
+	CO_OPERATION_GET_TIME,
+	CO_OPERATION_DEBUG_LINE,
+	CO_OPERATION_GET_HIGH_PREC_TIME,
+	CO_OPERATION_TRACE_POINT,
+	CO_OPERATION_FREE_PAGES,
+	CO_OPERATION_ALLOC_PAGES,
+	CO_OPERATION_PRINTK_unused,
+	CO_OPERATION_GETPP,
+	CO_OPERATION_MAX	/* Must be last entry all times */
+} co_operation_t;
+
+#define CO_MODULE_MAX_CONET    16
+#define CO_MODULE_MAX_COBD     32
+#define CO_MODULE_MAX_COFS     32
+#define CO_MODULE_MAX_SERIAL   32
+#define CO_MODULE_MAX_COSCSI   32
+#define CO_MODULE_MAX_COVIDEO	2
+#define CO_MODULE_MAX_COAUDIO	2
+
+typedef enum {
+	CO_MODULE_LINUX,
+	CO_MODULE_MONITOR,
+	CO_MODULE_DAEMON,
+	CO_MODULE_IDLE,
+	CO_MODULE_KERNEL_SWITCH,
+	CO_MODULE_USER_SWITCH,
+	CO_MODULE_CONSOLE,
+	CO_MODULE_PRINTK,
+
+	CO_MODULE_CONET0,
+	CO_MODULE_CONET_END=CO_MODULE_CONET0+CO_MODULE_MAX_CONET-1,
+
+	CO_MODULE_COBD0,
+	CO_MODULE_COBD_END=CO_MODULE_COBD0+CO_MODULE_MAX_COBD-1,
+
+	CO_MODULE_COFS0,
+	CO_MODULE_COFS_END=CO_MODULE_COFS0+CO_MODULE_MAX_COFS-1,
+
+	CO_MODULE_SERIAL0,
+	CO_MODULE_SERIAL_END=CO_MODULE_SERIAL0+CO_MODULE_MAX_SERIAL-1,
+
+	CO_MODULE_COSCSI0,
+	CO_MODULE_COSCSI_END=CO_MODULE_COSCSI0+CO_MODULE_MAX_COSCSI-1,
+
+	CO_MODULE_COVIDEO0,
+	CO_MODULE_COVIDEO_END=CO_MODULE_COVIDEO0+CO_MODULE_MAX_COVIDEO-1,
+
+	CO_MODULE_COAUDIO0,
+	CO_MODULE_COAUDIO_END=CO_MODULE_COAUDIO0+CO_MODULE_MAX_COAUDIO-1,
+	CO_MODULES_MAX,
+} co_module_t;
+
+typedef enum {
+	CO_PRIORITY_DISCARDABLE=0,
+	CO_PRIORITY_IMPORTANT,
+} co_priority_t;
+
+typedef enum {
+	CO_MESSAGE_TYPE_STRING=0,
+	CO_MESSAGE_TYPE_OTHER=1,
+} co_message_type_t;
+
+typedef struct {
+	co_module_t from;
+	co_module_t to;
+	co_priority_t priority;
+	co_message_type_t type;
+	unsigned long size;
+	unsigned char data[0];
+} __attribute__((packed)) co_message_t;
+
+typedef enum {
+	CO_DEVICE_BLOCK=0,
+	CO_DEVICE_CONSOLE,
+	CO_DEVICE_KEYBOARD,
+	CO_DEVICE_NETWORK,
+	CO_DEVICE_TIMER,
+	CO_DEVICE_POWER,
+	CO_DEVICE_SERIAL,
+	CO_DEVICE_FILESYSTEM,
+
+	CO_DEVICE_MOUSE,
+	CO_DEVICE_SCSI,
+	CO_DEVICE_VIDEO,
+	CO_DEVICE_AUDIO,
+	CO_DEVICE_PCI,
+
+	CO_DEVICES_TOTAL,
+} co_device_t;
+
+typedef enum {
+	CO_KBD_SCANCODE_RAW=0,
+	CO_KBD_SCANCODE_ASCII
+} mode_data_from_keyboard_t;
+
+typedef struct {
+	unsigned char code;
+	mode_data_from_keyboard_t mode;
+} __attribute__((packed)) co_scan_code_t;
+
+#define CO_MOUSE_MAX_X 2048
+#define CO_MOUSE_MAX_Y 2048
+
+typedef struct {
+	unsigned	btns;
+	unsigned	abs_x;
+	unsigned	abs_y;
+	int		rel_z;
+} __attribute__((packed)) co_mouse_data_t;
+
+typedef enum {
+	CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL=0,
+	CO_LINUX_MESSAGE_POWER_SHUTDOWN,
+	CO_LINUX_MESSAGE_POWER_OFF,
+} co_linux_message_power_type_t;
+
+typedef struct {
+	co_linux_message_power_type_t type;
+} __attribute__((packed)) co_linux_message_power_t;
+
+typedef struct {
+	unsigned long tick_count;
+} __attribute__((packed)) co_linux_message_idle_t;
+
+typedef struct {
+	co_device_t device;
+	unsigned int unit;
+	unsigned long size;
+	char data[];
+} __attribute__((packed)) co_linux_message_t;
+
+typedef enum {
+	CO_TERMINATE_END=0,
+	CO_TERMINATE_REBOOT,
+	CO_TERMINATE_POWEROFF,
+	CO_TERMINATE_PANIC,
+	CO_TERMINATE_HALT,
+	CO_TERMINATE_FORCED_OFF,
+	CO_TERMINATE_FORCED_END,
+	CO_TERMINATE_INVALID_OPERATION,
+	CO_TERMINATE_STACK_OVERFLOW,
+	CO_TERMINATE_BUG,
+	CO_TERMINATE_VMXE,
+} co_termination_reason_t;
+
+#ifdef CO_KERNEL
+
+#ifndef asmlinkage
+#define asmlinkage __attribute__((regparm(0)))
+#endif
+
+typedef void asmlinkage (*co_switcher_t)(co_arch_passage_page_t *page,
+			      void *from,
+			      void *to);
+
+#define co_passage_page_func_low(_from_,_to_)	\
+	(((co_switcher_t)(co_passage_page->code))	\
+	 (co_passage_page,				\
+	  &_from_.border2,			\
+	  &_to_.border2))
+
+# ifdef CO_COLINUX_KERNEL
+#  define co_passage_page  ((co_arch_passage_page_t *)(CO_VPTR_PASSAGE_PAGE))
+#  define co_current (co_passage_page->linuxvm_state)
+#  define co_other (co_passage_page->host_state)
+# else
+#  define co_passage_page  (cmon->passage_page)
+#  define co_other (co_passage_page->linuxvm_state)
+#  define co_current (co_passage_page->host_state)
+# endif
+
+# define co_switch() co_passage_page_func_low(co_current, co_other)
+
+#endif /* CO_KERNEL */
+
+/*
+ * Defines operations on various virtual devices.
+ */
+
+typedef enum {
+	CO_OPERATION_CONSOLE_STARTUP=0,
+	CO_OPERATION_CONSOLE_INIT=1,
+	CO_OPERATION_CONSOLE_DEINIT,
+	CO_OPERATION_CONSOLE_CLEAR,
+	CO_OPERATION_CONSOLE_PUTC,
+	CO_OPERATION_CONSOLE_PUTCS,
+	CO_OPERATION_CONSOLE_CURSOR_DRAW,
+	CO_OPERATION_CONSOLE_CURSOR_ERASE,
+	CO_OPERATION_CONSOLE_CURSOR_MOVE,
+	CO_OPERATION_CONSOLE_SCROLL_UP,
+	CO_OPERATION_CONSOLE_SCROLL_DOWN,
+	CO_OPERATION_CONSOLE_BMOVE,
+	CO_OPERATION_CONSOLE_SWITCH,
+	CO_OPERATION_CONSOLE_BLANK,
+	CO_OPERATION_CONSOLE_FONT_OP,
+	CO_OPERATION_CONSOLE_SET_PALETTE,
+	CO_OPERATION_CONSOLE_SCROLLDELTA,
+	CO_OPERATION_CONSOLE_SET_ORIGIN,
+	CO_OPERATION_CONSOLE_SAVE_SCREEN,
+	CO_OPERATION_CONSOLE_INVERT_REGION,
+	CO_OPERATION_CONSOLE_CONFIG,
+	CO_OPERATION_CONSOLE_INIT_SCROLLBUFFER,
+} co_operation_console_t;
+
+
+typedef char co_console_code;
+typedef unsigned short co_console_character;
+typedef unsigned short co_console_unit;
+
+typedef struct {
+	co_console_unit x;
+	co_console_unit y;
+	co_console_unit height;
+} __attribute__((packed)) co_cursor_pos_t;
+
+typedef struct {
+	co_operation_console_t type;
+	union {
+		struct {
+			co_console_unit top;
+			co_console_unit bottom;
+			co_console_unit lines;
+			co_console_character charattr;
+		} scroll;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+			co_console_character data[];
+		} putcs;
+		struct {
+			co_console_unit x;
+			co_console_unit y;
+			co_console_character charattr;
+		} putc;
+		struct {
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+			co_console_character charattr;
+		} clear;
+		struct {
+			co_console_unit y;
+			co_console_unit x;
+			co_console_unit count;
+		} invert;
+		struct {
+			co_console_unit row;
+			co_console_unit column;
+			co_console_unit top;
+			co_console_unit left;
+			co_console_unit bottom;
+			co_console_unit right;
+		} bmove;
+		struct {
+			co_console_unit rows;
+			co_console_unit cols;
+			co_console_unit attr;
+		} config;
+		co_cursor_pos_t cursor;
+	};
+} __attribute__((packed)) co_console_message_t;
+
+typedef struct {
+	unsigned long messages_waiting;
+	unsigned char buffer[];
+} co_io_buffer_t;
+
+typedef struct {
+	unsigned long index;
+	unsigned long flags;
+	unsigned long func;
+	unsigned long pid;
+} __attribute__((packed)) co_trace_point_info_t;
+
+typedef enum {
+	CO_BLOCK_OPEN=0,
+	CO_BLOCK_STAT,
+	CO_BLOCK_READ,
+	CO_BLOCK_WRITE,
+	CO_BLOCK_CLOSE,
+	CO_BLOCK_GET_ALIAS,
+} co_block_request_type_t;
+
+typedef enum {
+	CO_BLOCK_REQUEST_RETCODE_OK=0,
+	CO_BLOCK_REQUEST_RETCODE_ERROR=-1,
+} co_block_request_retcode_t;
+
+typedef enum {
+	CO_NETWORK_GET_MAC=0,
+} co_network_request_type_t;
+
+#ifdef CO_KERNEL
+/* If we are compiling kernel code (Linux or Host Driver) */
+# ifdef CO_COLINUX_KERNEL
+/* Inside Linux, vm_ptr_t considered a valid pointer in its virtual address space */
+typedef void *vm_ptr_t;
+#  else
+/* But inside the host, the type is considered not to be a pointer in its own address space */
+typedef unsigned long vm_ptr_t;
+# endif
+
+typedef struct {
+	co_block_request_type_t type;
+	long rc;
+	union {
+		struct {
+			unsigned long long offset;
+			unsigned long long size;
+			unsigned long long disk_size;
+			vm_ptr_t address;
+			void * irq_request;
+			int async;
+		};
+		struct {
+			char alias[20];
+		};
+	};
+} __attribute__((packed)) co_block_request_t;
+
+typedef struct {
+	void * irq_request;
+	int uptodate;
+} __attribute__((packed)) co_block_intr_t;
+
+typedef struct {
+	co_network_request_type_t type;
+	unsigned int unit;
+	char mac_address[6];
+	char _pad[2];
+	int result;
+} __attribute__((packed)) co_network_request_t;
+
+#endif /* CO_KERNEL */
+
+typedef struct {
+	unsigned long api_version;
+	unsigned long compiler_major;
+	unsigned long compiler_minor;
+	unsigned long compiler_abi;
+} __attribute__((packed)) co_info_t;
+
+typedef struct {
+	unsigned long co_core_end;
+	unsigned long co_memory_size;
+	void *co_initrd;
+	unsigned long co_initrd_size;
+	unsigned long co_cpu_khz;
+	unsigned long filler[5];		// compatible old api: empty 5,6,7,8,9
+	char co_boot_parameters[CO_BOOTPARAM_STRING_LENGTH]; // params[10]
+} __attribute__((packed)) co_boot_params_t;
+
+#ifndef COLINUX_TRACE
+#define CO_TRACE_STOP
+#define CO_TRACE_CONTINUE
+#endif
+
+#pragma pack()
+
+#endif
Index: linux-2.6.33-source/include/linux/cooperative_internal.h
===================================================================
--- /dev/null
+++ linux-2.6.33-source/include/linux/cooperative_internal.h
@@ -0,0 +1,143 @@
+/*
+ *  linux/include/linux/cooperative_internal.h
+ *
+ *  Copyright (C) 2004 Dan Aloni
+ *
+ *  This header gathers the functions and variables in Cooperative Mode
+ *  when CONFIG_COOPERATIVE is defined.
+ */
+#ifndef __LINUX_COOPERATIVE_LINUX_H__
+#define __LINUX_COOPERATIVE_LINUX_H__
+
+#include <linux/cooperative.h>
+#include <linux/list.h>
+#include <asm/ptrace.h>
+
+#ifdef CONFIG_COOPERATIVE
+
+#define ENABLE_PASSAGE_HOLDING_CHECK
+
+typedef struct {
+	struct list_head node;
+	co_message_t msg;
+} co_message_node_t;
+
+extern co_boot_params_t co_boot_params;
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+extern int co_passage_page_holding_count;
+#endif
+
+#ifdef CONFIG_COLINUX_STATS
+typedef struct co_proc_counts {
+	unsigned long switches[CO_OPERATION_MAX];
+} co_proc_counts_t;
+
+extern co_proc_counts_t co_proc_counts;
+#endif
+
+#define co_io_buffer ((co_io_buffer_t *)CO_VPTR_IO_AREA_START)
+#define cooperative_mode_enabled()     1
+
+extern void co_debug(const char *fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+extern void co_printk(const char *line, int size);
+
+extern void co_switch_wrapper(void);
+extern void co_callback(struct pt_regs *regs);
+extern void co_idle_processor(void);
+NORET_TYPE void co_terminate(co_termination_reason_t reason) ATTRIB_NORET;
+NORET_TYPE void co_terminate_panic(const char *text, int len) ATTRIB_NORET;
+NORET_TYPE void co_terminate_bug(int code, int line, const char *file) ATTRIB_NORET;
+extern void co_free_pages(unsigned long vaddr, int pages);
+extern int co_alloc_pages(unsigned long vaddr, int pages);
+extern void co_start_kernel(void);
+extern void co_arch_start_kernel(void);
+
+extern void co_send_message(co_module_t from,
+			    co_module_t to,
+			    co_priority_t priority,
+			    co_message_type_t type,
+			    unsigned long size,
+			    const char *data);
+
+extern int co_get_message(co_message_node_t **message, co_device_t device);
+static inline void co_free_message(co_message_node_t *message)
+{
+	kfree(message);
+}
+
+extern void *co_map_buffer(void *, int);
+
+static inline void co_passage_page_ref_up(void)
+{
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+	co_passage_page_holding_count++;
+#endif
+}
+
+static inline void co_passage_page_ref_down(void)
+{
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+	co_passage_page_holding_count--;
+#endif
+}
+
+static inline int co_passage_page_held(void)
+{
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+	return co_passage_page_holding_count;
+#else
+	return 0;
+#endif
+}
+
+static inline void co_passage_page_acquire(unsigned long *flags)
+{
+	local_irq_save(*flags);
+	co_passage_page_ref_up();
+}
+
+static inline void co_passage_page_release(unsigned long flags)
+{
+	co_passage_page_ref_down();
+	local_irq_restore(flags);
+}
+
+#ifdef ENABLE_PASSAGE_HOLDING_CHECK
+#define co_passage_page_assert_valid() do {	\
+	BUG_ON(co_passage_page_held());		\
+} while (0)
+#else
+#define co_passage_page_assert_valid() /* nothing */
+#endif
+
+static inline co_message_t *co_send_message_save(unsigned long *flags)
+{
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(flags);
+
+	if (co_io_buffer->messages_waiting) {
+		co_passage_page_release(*flags);
+		return NULL;
+	}
+
+	co_passage_page->operation = CO_OPERATION_MESSAGE_TO_MONITOR;
+	co_io_buffer->messages_waiting = 1;
+	return ((co_message_t *)co_io_buffer->buffer);
+}
+
+static inline void co_send_message_restore(unsigned long flags)
+{
+	co_switch_wrapper();
+	co_passage_page_release(flags);
+}
+
+#else
+
+#define co_printk(line, size)          do {} while (0)
+#define co_terminate(reason)           do {} while (0)
+#define cooperative_mode_enabled()     0
+
+#endif
+
+#endif
Index: linux-2.6.33-source/kernel/Makefile
===================================================================
--- linux-2.6.33-source.orig/kernel/Makefile
+++ linux-2.6.33-source/kernel/Makefile
@@ -85,6 +85,7 @@
 obj-$(CONFIG_TREE_RCU_TRACE) += rcutree_trace.o
 obj-$(CONFIG_TINY_RCU) += rcutiny.o
 obj-$(CONFIG_RELAY) += relay.o
+obj-$(CONFIG_COOPERATIVE) += cooperative.o
 obj-$(CONFIG_SYSCTL) += utsname_sysctl.o
 obj-$(CONFIG_TASK_DELAY_ACCT) += delayacct.o
 obj-$(CONFIG_TASKSTATS) += taskstats.o tsacct.o
Index: linux-2.6.33-source/kernel/cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/kernel/cooperative.c
@@ -0,0 +1,442 @@
+/*
+ *  linux/kernel/cooperative.c
+ *
+ *  Cooperative mode (coLinux) support routines.
+ *
+ *  Dan Aloni <da-x@colinux.org>, 2003-2004 (C).
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/irq.h>
+#include <linux/cooperative_internal.h>
+
+CO_TRACE_STOP;
+
+co_boot_params_t co_boot_params;
+
+typedef struct {
+	struct list_head list;
+	int num_messages;
+} co_message_queue_t;
+
+int co_messages_active = 0;
+co_message_queue_t co_outgoing_messages;
+co_message_queue_t co_incoming_messages;
+co_message_queue_t *co_incoming_queued_messages;
+
+#ifdef CONFIG_COLINUX_STATS
+co_proc_counts_t co_proc_counts;
+#endif
+
+void __init co_start_kernel(void)
+{
+        memcpy(&co_boot_params, co_passage_page->params, sizeof(co_boot_params));
+	co_arch_start_kernel();
+}
+
+void co_send_message(co_module_t from,
+		     co_module_t to,
+		     co_priority_t priority,
+		     co_message_type_t type,
+		     unsigned long size,
+		     const char *data)
+{
+	unsigned long flags;
+	co_message_t *buffer;
+
+	BUG_ON((sizeof(co_message_t) + size) > CO_VPTR_IO_AREA_SIZE - sizeof(co_io_buffer_t));
+
+	buffer = co_send_message_save(&flags);
+	if (!buffer)
+		return;
+
+	buffer->from = from;
+	buffer->to = to;
+	buffer->priority = priority;
+	buffer->type = type;
+	buffer->size = size;
+	memcpy(buffer->data, data, size);
+
+	co_send_message_restore(flags);
+}
+
+static void co_message_add_to_incoming(co_message_t *message, unsigned long size)
+{
+	co_message_node_t *message_copy;
+
+	message_copy = kmalloc(size + sizeof(co_message_node_t) - sizeof(co_message_t),
+			       GFP_ATOMIC);
+	if (!message_copy)
+		return;
+
+	memcpy(&message_copy->msg, message, size);
+	list_add_tail(&message_copy->node, &co_incoming_messages.list);
+}
+
+static void co_handle_jiffies(long count)
+{
+	if (count > HZ) {
+		long secs = count / HZ;
+
+		/* 'warp_clock' for long distances */
+		write_seqlock(&xtime_lock);
+		xtime.tv_sec += secs;
+		count -= (secs * HZ);
+		update_xtime_cache(0);
+		write_sequnlock(&xtime_lock);
+		clock_was_set();
+	}
+
+	while (count > 0) {
+		irq_enter();
+		__do_IRQ(TIMER_IRQ);
+		irq_exit();
+		count--;
+	}
+}
+
+/* called with disabled interrupts */
+static void co_handle_incoming_message(co_message_node_t *node_message)
+{
+	co_linux_message_t *message;
+	co_message_queue_t *queue;
+	int irq;
+
+	message = (co_linux_message_t *)&node_message->msg.data;
+	switch (message->device) {
+	case CO_DEVICE_POWER: irq = POWER_IRQ; break;
+	case CO_DEVICE_KEYBOARD: irq = KEYBOARD_IRQ; break;
+#ifdef CONFIG_CONET_COOPERATIVE
+	case CO_DEVICE_NETWORK: irq = NETWORK_IRQ; break;
+#endif
+#ifdef CONFIG_SERIAL_COOPERATIVE
+	case CO_DEVICE_SERIAL: irq = SERIAL_IRQ; break;
+#endif
+	case CO_DEVICE_SCSI: irq = SCSI_IRQ; break;
+	case CO_DEVICE_MOUSE: irq = MOUSE_IRQ; break;
+	case CO_DEVICE_BLOCK: irq = BLOCKDEV_IRQ; break;
+	default:
+		BUG_ON((unsigned long)message->device >= (unsigned long)CO_DEVICES_TOTAL);
+		co_free_message(node_message);
+		return;
+	}
+
+	/* Add to the queue */
+	queue = &co_incoming_queued_messages[message->device];
+	list_add(&node_message->node, &queue->list);
+	queue->num_messages++;
+
+	irq_enter();
+	__do_IRQ(irq);
+	irq_exit();
+}
+
+static void co_handle_incoming_messages(void)
+{
+	if (!co_messages_active)
+		return;
+
+	/*
+	 * Pop a message from the incoming queue.
+	 */
+	while (!list_empty(&co_incoming_messages.list)) {
+		co_message_node_t *message;
+
+		message = list_entry(co_incoming_messages.list.next,
+				     co_message_node_t, node);
+		BUG_ON((unsigned long)message->msg.from >= (unsigned long)CO_MODULES_MAX);
+		BUG_ON((unsigned long)message->msg.to >= (unsigned long)CO_MODULES_MAX);
+		list_del(&message->node);
+
+		/*
+		 * Let the interrupt routine of the arch dependant code
+		 * handle the message, and be responsible to free it.
+		 */
+		co_handle_incoming_message(message);
+	}
+}
+
+void co_callback(struct pt_regs *regs)
+{
+	long io_size;
+	unsigned long new_jiffies;
+	struct pt_regs null_regs;
+
+	BUG_ON(!irqs_disabled());
+	if (co_passage_page->operation != CO_OPERATION_MESSAGE_FROM_MONITOR) {
+		co_passage_page_ref_down();
+		return;
+	}
+
+#ifdef CONFIG_COLINUX_STATS
+	co_proc_counts.switches[CO_OPERATION_MESSAGE_FROM_MONITOR]++;
+#endif
+	io_size = co_passage_page->params[0];
+	new_jiffies = co_passage_page->params[1];
+
+	if (co_messages_active  &&  io_size > 0  &&  io_size <= CO_VPTR_IO_AREA_SIZE) {
+		static unsigned char temp_storage[CO_VPTR_IO_AREA_SIZE];
+		unsigned char *io_buffer = temp_storage;
+		unsigned char *io_buffer_end = &temp_storage[io_size];
+
+		/* Copy into temp, because kmalloc calls host to mapping pages */
+		memcpy(temp_storage, co_io_buffer->buffer, io_size);
+		co_io_buffer->messages_waiting = 0;
+		co_passage_page_ref_down();
+
+		while (io_buffer < io_buffer_end) {
+			co_message_t *message = (co_message_t *)io_buffer;
+			co_linux_message_t *linux_message = (co_linux_message_t *)message->data;
+			unsigned long size = message->size + sizeof(*message);
+
+			BUG_ON((unsigned long)message->from >= (unsigned long)CO_MODULES_MAX);
+			BUG_ON((unsigned long)message->to >= (unsigned long)CO_MODULES_MAX);
+			BUG_ON((unsigned long)linux_message->device >= (unsigned long)CO_DEVICES_TOTAL);
+
+			co_message_add_to_incoming(message, size);
+			io_buffer += size;
+		}
+	} else {
+		co_io_buffer->messages_waiting = 0;
+		co_passage_page_ref_down();
+	}
+
+	memset (&null_regs, 0, sizeof(null_regs));
+
+	/* Have only, if from proxy_interrupt_handler(), needs for user_mode() */
+	if (regs)
+		null_regs.cs = regs->cs;
+	set_irq_regs(&null_regs);
+
+	co_handle_jiffies(new_jiffies);
+	co_handle_incoming_messages();
+}
+
+void co_idle_processor(void)
+{
+	co_passage_page_assert_valid();
+	local_irq_disable();
+	co_passage_page_ref_up();
+	co_passage_page->operation = CO_OPERATION_IDLE;
+	co_switch_wrapper();
+	co_callback(NULL);
+	local_irq_enable();
+}
+
+void co_printk(const char *line, int size)
+{
+	unsigned long flags;
+	co_message_t *co_message;
+
+	co_message = co_send_message_save(&flags);
+	if (co_message) {
+		co_message->from = CO_MODULE_LINUX;
+		co_message->to = CO_MODULE_PRINTK;
+		co_message->priority = CO_PRIORITY_DISCARDABLE;
+		co_message->type = CO_MESSAGE_TYPE_STRING;
+		if (size > 200)
+			size = 200;
+		co_message->size = size + 1;
+		memcpy(co_message->data, line, size);
+		co_message->data[size] = '\0';
+		co_send_message_restore(flags);
+	}
+}
+
+NORET_TYPE void co_terminate_panic(const char *text, int len)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = CO_TERMINATE_PANIC;
+	co_passage_page->params[1] = 0;
+	co_passage_page->params[2] = 0;
+	co_passage_page->params[3] = len;
+	memcpy((char *)&co_passage_page->params[4], text, len+1);
+	co_switch_wrapper();
+	while(1);
+}
+
+NORET_TYPE void co_terminate_bug(int code, int line, const char *file)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = CO_TERMINATE_BUG;
+	co_passage_page->params[1] = code;
+	co_passage_page->params[2] = line;
+	co_passage_page->params[3] = strlen(file);
+	strcpy((char *)&co_passage_page->params[4], file);
+	co_switch_wrapper();
+	while(1);
+}
+NORET_TYPE EXPORT_SYMBOL(co_terminate_bug);
+
+void co_terminate(co_termination_reason_t reason)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_TERMINATE;
+	co_passage_page->params[0] = reason;
+	co_passage_page->params[3] = 0; /* len */
+	co_switch_wrapper();
+	while(1);
+}
+EXPORT_SYMBOL(co_terminate);
+
+int co_get_message(co_message_node_t **message, co_device_t device)
+{
+	co_message_queue_t *queue;
+	co_message_node_t *node;
+	unsigned long flags;
+
+	if (!co_messages_active)
+		return 0;
+
+	local_irq_save(flags);
+	queue = &co_incoming_queued_messages[device];
+	if (list_empty(&queue->list)) {
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	node = list_entry(queue->list.prev, co_message_node_t, node);
+	list_del(&node->node);
+	queue->num_messages--;
+	local_irq_restore(flags);
+
+	*message = node;
+	return 1;
+}
+
+co_info_t co_info = {
+	.api_version = CO_LINUX_API_VERSION,
+	.compiler_major = __GNUC__,
+	.compiler_minor = __GNUC_MINOR__,
+	.compiler_abi = __GXX_ABI_VERSION,
+};
+
+static int __init initcall_message_queues(void)
+{
+	int queue_index;
+
+	INIT_LIST_HEAD(&co_outgoing_messages.list);
+	INIT_LIST_HEAD(&co_incoming_messages.list);
+
+	co_incoming_queued_messages =
+		kmalloc(sizeof(co_message_queue_t) * CO_DEVICES_TOTAL, GFP_KERNEL);
+	if (!co_incoming_queued_messages)
+		panic("unable to allocate message queues\n");
+
+	for (queue_index=0; queue_index < CO_DEVICES_TOTAL; queue_index++) {
+		co_message_queue_t *queue = &co_incoming_queued_messages[queue_index];
+		queue->num_messages = 0;
+		INIT_LIST_HEAD(&queue->list);
+	}
+
+	co_messages_active = 1;
+
+	return 0;
+}
+
+
+void co_free_pages(unsigned long vaddr, int pages)
+{
+	unsigned long flags;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_FREE_PAGES;
+	co_passage_page->params[0] = vaddr;
+	co_passage_page->params[1] = pages;
+	co_switch_wrapper();
+	co_passage_page_release(flags);
+}
+
+int co_alloc_pages(unsigned long vaddr, int size)
+{
+	unsigned long flags;
+	long result;
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_ALLOC_PAGES;
+	co_passage_page->params[0] = vaddr;
+	co_passage_page->params[1] = size;
+	co_switch_wrapper();
+	result = (long)co_passage_page->params[4];
+	co_passage_page_release(flags);
+
+	if (result < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+__initcall(initcall_message_queues);
+
+#ifdef CONFIG_COLINUX_STATS
+static int co_guest_read_status(char *page, char **start, off_t off, int count, int *eof, void *clear)
+{
+	co_proc_counts_t hold;
+	int len;
+
+	local_irq_disable();
+	hold = co_proc_counts;
+	if (clear)
+		memset(&co_proc_counts, 0, sizeof(co_proc_counts));
+	local_irq_enable();
+
+	len = sprintf(page,	"idle:\t%lu\n"
+				"msgto:\t%lu\n"
+				"mfrom:\t%lu\n"
+				"intr:\t%lu\n"
+				"dev:\t%lu\n"
+				"time:\t%lu\n"
+				"hpt:\t%lu\n"
+				"free:\t%lu\n"
+				"alloc:\t%lu\n"
+				"getpp:\t%lu\n",
+			hold.switches[CO_OPERATION_IDLE],
+			hold.switches[CO_OPERATION_MESSAGE_TO_MONITOR],
+			hold.switches[CO_OPERATION_MESSAGE_FROM_MONITOR],
+			hold.switches[CO_OPERATION_FORWARD_INTERRUPT],
+			hold.switches[CO_OPERATION_DEVICE],
+			hold.switches[CO_OPERATION_GET_TIME],
+			hold.switches[CO_OPERATION_GET_HIGH_PREC_TIME],
+			hold.switches[CO_OPERATION_FREE_PAGES],
+			hold.switches[CO_OPERATION_ALLOC_PAGES],
+			hold.switches[CO_OPERATION_GETPP]);
+
+	return len;
+}
+
+static __init int co_create_proc_stats(void)
+{
+	struct proc_dir_entry *co_guest_dir;
+
+	co_guest_dir = proc_mkdir("colinux", NULL);
+	if(co_guest_dir) {
+		create_proc_read_entry("stats",
+					0444, co_guest_dir,
+					co_guest_read_status, NULL);
+		create_proc_read_entry("stats_clear",
+					0444, co_guest_dir,
+					co_guest_read_status, (void*)1);
+	}
+
+	return 0;
+}
+
+__initcall(co_create_proc_stats);
+#endif /* CONFIG_COLINUX_STATS */
+
+CO_TRACE_CONTINUE;
Index: linux-2.6.33-source/kernel/panic.c
===================================================================
--- linux-2.6.33-source.orig/kernel/panic.c
+++ linux-2.6.33-source/kernel/panic.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/nmi.h>
 #include <linux/dmi.h>
+#include <linux/cooperative_internal.h>
 
 int panic_on_oops;
 static unsigned long tainted_mask;
@@ -68,7 +69,7 @@
 
 	bust_spinlocks(1);
 	va_start(args, fmt);
-	vsnprintf(buf, sizeof(buf), fmt, args);
+	i = vsnprintf(buf, sizeof(buf), fmt, args);
 	va_end(args);
 	printk(KERN_EMERG "Kernel panic - not syncing: %s\n",buf);
 #ifdef CONFIG_DEBUG_BUGVERBOSE
@@ -84,6 +85,9 @@
 
 	kmsg_dump(KMSG_DUMP_PANIC);
 
+	if (cooperative_mode_enabled())
+		co_terminate_panic(buf, i);
+
 	/*
 	 * Note smp_send_stop is the usual smp shutdown function, which
 	 * unfortunately means it may not be hardened to work in a panic
Index: linux-2.6.33-source/kernel/printk.c
===================================================================
--- linux-2.6.33-source.orig/kernel/printk.c
+++ linux-2.6.33-source/kernel/printk.c
@@ -51,6 +51,8 @@
 {
 }
 
+#include <linux/cooperative_internal.h>
+
 #define __LOG_BUF_LEN	(1 << CONFIG_LOG_BUF_SHIFT)
 
 /* printk's without a loglevel use this.. */
@@ -740,6 +742,8 @@
 		}
 	}
 
+	co_printk(printk_buf, printed_len);
+
 	/*
 	 * Copy the output into log_buf.  If the caller didn't provide
 	 * appropriate log level tags, we insert them here
Index: linux-2.6.33-source/mm/bootmem.c
===================================================================
--- linux-2.6.33-source.orig/mm/bootmem.c
+++ linux-2.6.33-source/mm/bootmem.c
@@ -12,6 +12,7 @@
 #include <linux/pfn.h>
 #include <linux/bootmem.h>
 #include <linux/module.h>
+#include <linux/cooperative_internal.h>
 #include <linux/kmemleak.h>
 
 #include <asm/bug.h>
@@ -544,6 +545,21 @@
 
 		region = phys_to_virt(PFN_PHYS(bdata->node_min_pfn) +
 				start_off);
+
+		if (cooperative_mode_enabled()) {
+			unsigned long alloc_address = (unsigned long)region;
+			unsigned long alloc_size = size;
+
+			alloc_size += (alloc_address & (~PAGE_MASK));
+			alloc_address &= PAGE_MASK;
+			alloc_size = (alloc_size + PAGE_SIZE - 1) >> PAGE_SHIFT;
+
+			if (co_alloc_pages(alloc_address, alloc_size)) {
+				free_bootmem((unsigned long)region, size);
+				return NULL;
+			}
+		}
+
 		memset(region, 0, size);
 		/*
 		 * The min_count is set to 0 so that bootmem allocated blocks
Index: linux-2.6.33-source/mm/page_alloc.c
===================================================================
--- linux-2.6.33-source.orig/mm/page_alloc.c
+++ linux-2.6.33-source/mm/page_alloc.c
@@ -49,6 +49,7 @@
 #include <linux/debugobjects.h>
 #include <linux/kmemleak.h>
 #include <linux/memory.h>
+#include <linux/cooperative_internal.h>
 #include <trace/events/kmem.h>
 
 #include <asm/tlbflush.h>
@@ -338,6 +339,34 @@
 	return bad;
 }
 
+#ifdef CONFIG_COOPERATIVE
+static int co_persistent_alloc_pages(unsigned long address, int size)
+{
+	int result, retries_left;
+
+	for (retries_left = 10; retries_left > 0; retries_left--) {
+		result = co_alloc_pages(address, size);
+		if (result) {
+			unsigned long cache_size;
+			/*
+			 * Whoops, we have allocated too much of the
+			 * host OS's memory, time to free some cache.
+			 */
+			cache_size = global_page_state(NR_FILE_PAGES)-total_swapcache_pages;
+			cache_size /= 2;
+			if (cache_size < size*2)
+				cache_size = size*2;
+			shrink_all_memory(cache_size);
+		} else {
+			return 0;
+		}
+	}
+
+	WARN_ON(result != 0);
+	return result;
+}
+#endif /* CONFIG_COOPERATIVE */
+
 static inline void prep_zero_page(struct page *page, int order, gfp_t gfp_flags)
 {
 	int i;
@@ -453,6 +482,11 @@
 {
 	unsigned long page_idx;
 
+#ifdef CONFIG_COOPERATIVE
+	co_free_pages((unsigned long)page_address(page), 1 << order);
+	ClearPageCoHostMapped(page);
+#endif /* CONFIG_COOPERATIVE */
+
 	if (unlikely(PageCompound(page)))
 		if (unlikely(destroy_compound_page(page, order)))
 			return;
@@ -692,6 +726,12 @@
 			return 1;
 	}
 
+#ifdef CONFIG_COOPERATIVE
+	if (!TestSetPageCoHostMapped(page))
+		if (co_persistent_alloc_pages((unsigned long)page_address(page), 1 << order))
+			return 1;
+#endif /* CONFIG_COOPERATIVE */
+
 	set_page_private(page, 0);
 	set_page_refcounted(page);
 
@@ -1237,6 +1277,7 @@
 	VM_BUG_ON(bad_range(zone, page));
 	if (prep_new_page(page, order, gfp_flags))
 		goto again;
+
 	return page;
 
 failed:
@@ -1918,7 +1959,7 @@
 		dump_stack();
 		show_mem();
 	}
-	return page;
+	return NULL;
 got_pg:
 	if (kmemcheck_enabled)
 		kmemcheck_pagealloc_alloc(page, order, gfp_mask);
Index: linux-2.6.33-source/mm/vmscan.c
===================================================================
--- linux-2.6.33-source.orig/mm/vmscan.c
+++ linux-2.6.33-source/mm/vmscan.c
@@ -2332,7 +2332,7 @@
 	return nr;
 }
 
-#ifdef CONFIG_HIBERNATION
+#if defined(CONFIG_HIBERNATION) || defined(CONFIG_COOPERATIVE)
 /*
  * Try to free `nr_to_reclaim' of memory, system-wide, and return the number of
  * freed pages.
Index: linux-2.6.33-source/drivers/char/mem.c
===================================================================
--- linux-2.6.33-source.orig/drivers/char/mem.c
+++ linux-2.6.33-source/drivers/char/mem.c
@@ -22,6 +22,7 @@
 #include <linux/device.h>
 #include <linux/highmem.h>
 #include <linux/crash_dump.h>
+#include <linux/cooperative_internal.h>
 #include <linux/backing-dev.h>
 #include <linux/bootmem.h>
 #include <linux/splice.h>
@@ -130,6 +131,9 @@
 	ssize_t read, sz;
 	char *ptr;
 
+	if (cooperative_mode_enabled())
+		return -ENOMEM;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 	read = 0;
@@ -188,6 +192,9 @@
 	unsigned long copied;
 	void *ptr;
 
+	if (cooperative_mode_enabled())
+		return -ENOMEM;
+
 	if (!valid_phys_addr_range(p, count))
 		return -EFAULT;
 
@@ -298,6 +305,9 @@
 {
 	size_t size = vma->vm_end - vma->vm_start;
 
+	if (cooperative_mode_enabled())
+		return -EFAULT;
+
 	if (!valid_mmap_phys_addr_range(vma->vm_pgoff, size))
 		return -EINVAL;
 
@@ -333,6 +343,9 @@
 {
 	unsigned long pfn;
 
+	if (cooperative_mode_enabled())
+		return -EFAULT;
+
 	/* Turn a kernel-virtual address into a physical page frame */
 	pfn = __pa((u64)vma->vm_pgoff << PAGE_SHIFT) >> PAGE_SHIFT;
 
@@ -397,6 +410,9 @@
 	char * kbuf; /* k-addr because vread() takes vmlist_lock rwlock */
 	int err = 0;
 
+	if (cooperative_mode_enabled())
+		return -ENOMEM;
+
 	read = 0;
 	if (p < (unsigned long) high_memory) {
 		low_count = count;
@@ -527,6 +543,9 @@
 	char * kbuf; /* k-addr because vwrite() takes vmlist_lock rwlock */
 	int err = 0;
 
+	if (cooperative_mode_enabled())
+		return -ENOMEM;
+
 	if (p < (unsigned long) high_memory) {
 		unsigned long to_write = min_t(unsigned long, count,
 					       (unsigned long)high_memory - p);
Index: linux-2.6.33-source/arch/x86/kernel/cpu/bugs.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/cpu/bugs.c
+++ linux-2.6.33-source/arch/x86/kernel/cpu/bugs.c
@@ -25,6 +25,8 @@
 
 __setup("no-hlt", no_halt);
 
+// Ignore, if have no emulation compiled in
+#ifdef CONFIG_MATH_EMULATION
 static int __init no_387(char *s)
 {
 	boot_cpu_data.hard_math = 0;
@@ -33,6 +35,7 @@
 }
 
 __setup("no387", no_387);
+#endif
 
 static double __initdata x = 4195835.0;
 static double __initdata y = 3145727.0;
Index: linux-2.6.33-source/arch/x86/kernel/reboot_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/reboot_cooperative.c
@@ -0,0 +1,133 @@
+/*
+ *  linux/arch/x86/kernel/reboot_cooperative.c
+ */
+
+#include <linux/module.h>
+#include <linux/reboot.h>
+#include <linux/kthread.h>
+#include <linux/syscalls.h>
+#include <linux/interrupt.h>
+#include <linux/cooperative_internal.h>
+
+/* sys_reboot needs this dummy. */
+void (*pm_power_off)(void);
+
+/*
+ * This is a hack to make ctrl_alt_del work as a poweroff, so the OS can be
+ * notified, unmount and sync everything.
+ */
+static int co_powering_off;
+
+static int co_powerd(void *__unused)
+{
+	extern char * envp_init[];
+	static char *const argv_shutdown[]= { "/sbin/shutdown", "-h", "now", NULL };
+	static char *const argv_halt[]= { "/sbin/halt", NULL };
+
+	if (kernel_execve(argv_shutdown[0], argv_shutdown, envp_init) >= 0)
+		return 0;
+	printk(KERN_INFO "%s spawn failed\n", argv_shutdown[0]);
+
+	if (kernel_execve(argv_halt[0], argv_halt, envp_init) >= 0)
+		return 0;
+	printk(KERN_INFO "%s spawn failed\n", argv_halt[0]);
+
+	printk(KERN_INFO "Fallback into reboot and power off\n");
+	co_powering_off++;
+	ctrl_alt_del();
+
+	return 0;
+}
+
+static void deferred_shutdown(struct work_struct *dummy)
+{
+	kthread_run(co_powerd, NULL, "copowerd");
+}
+
+/*
+ * This function will call from interrupt context.
+ */
+static void co_shedule_shutdown(void)
+{
+	static DECLARE_WORK(shutdown_work, deferred_shutdown);
+
+	schedule_work(&shutdown_work);
+}
+
+
+static void co_machine_restart(void)
+{
+	co_terminate(CO_TERMINATE_REBOOT);
+}
+
+void machine_power_off(void)
+{
+	co_terminate(CO_TERMINATE_POWEROFF);
+}
+
+void machine_shutdown(void)
+{
+	co_terminate(CO_TERMINATE_HALT);
+}
+
+void machine_emergency_restart(void)
+{
+	co_machine_restart();
+}
+
+void machine_restart(char *cmd)
+{
+	if (co_powering_off)
+		machine_power_off();
+	else
+		co_machine_restart();
+}
+
+void machine_halt(void)
+{
+	co_terminate(CO_TERMINATE_HALT);
+}
+
+static irqreturn_t power_interrupt(int irq, void *dev_id)
+{
+	co_message_node_t *node_message;
+
+	if (co_get_message(&node_message, CO_DEVICE_POWER)) {
+		co_linux_message_t *message;
+		co_linux_message_power_t *type;
+
+		message = (co_linux_message_t *)&node_message->msg.data;
+		type = (co_linux_message_power_t *)message->data;
+		switch (type->type) {
+		case CO_LINUX_MESSAGE_POWER_ALT_CTRL_DEL:
+			ctrl_alt_del();
+			break;
+		case CO_LINUX_MESSAGE_POWER_SHUTDOWN:
+			co_shedule_shutdown();
+			break;
+		case CO_LINUX_MESSAGE_POWER_OFF:
+			machine_power_off();
+			break;
+		default:
+			printk(KERN_ERR "power interrupt: buggy type %d\n", type->type);
+		}
+		co_free_message(node_message);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init co_power_init(void)
+{
+	int rc;
+
+	rc = request_irq(POWER_IRQ, &power_interrupt, IRQF_SAMPLE_RANDOM, "power", NULL);
+	if (rc) {
+		printk(KERN_ERR "POWER: unable to get irq %d", POWER_IRQ);
+		return rc;
+	}
+
+	return 0;
+}
+
+__initcall(co_power_init);
Index: linux-2.6.33-source/arch/x86/kernel/i8259_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/i8259_cooperative.c
@@ -0,0 +1,103 @@
+/*
+ *  linux/arch/x86/kernel/i8259_cooperative.c
+ */
+
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/cooperative_internal.h>
+
+#include <asm/irq.h>
+#include <asm/desc.h>
+
+CO_TRACE_STOP;
+
+/* Function must have the same prototype as do_IRQ() */
+unsigned int /*__irq_entry*/ proxy_interrupt_handler(struct pt_regs *regs)
+{
+	/* high bit used in ret_from_ code  */
+	unsigned vector = ~regs->orig_ax;
+
+	co_passage_page_assert_valid();
+	co_passage_page_ref_up();
+	co_passage_page->operation = CO_OPERATION_FORWARD_INTERRUPT;
+	co_passage_page->params[0] = vector; /* IRQ vector */
+	co_passage_page->host_state.flags &= ~(1 << 9); /* Turn IF off */
+	co_switch_wrapper();
+	co_callback(regs);
+	return 1;
+}
+
+CO_TRACE_CONTINUE;
+
+/*
+ * Not like you have any other choice other than using
+ * COPIC in Cooperative mode.
+ */
+
+static void end_COPIC_irq(unsigned int irq)
+{
+}
+
+static void mask_and_ack_COPIC(unsigned int irq)
+{
+}
+
+static unsigned int startup_COPIC_irq(unsigned int irq)
+{
+	return 0;
+}
+
+#define shutdown_COPIC_irq	disable_COPIC_irq
+
+static void disable_COPIC_irq(unsigned int irq)
+{
+}
+
+static void enable_COPIC_irq(unsigned int irq)
+{
+}
+
+static struct irq_chip co_pic_irq_chip = {
+	.name = "COPIC",
+	.startup = startup_COPIC_irq,
+	.shutdown = shutdown_COPIC_irq,
+	.enable = enable_COPIC_irq,
+	.disable = disable_COPIC_irq,
+	.mask_ack = mask_and_ack_COPIC,
+	.end = end_COPIC_irq,
+	.set_affinity = NULL
+};
+
+void __init init_ISA_irqs (void)
+{
+	int i;
+
+	printk("Setting proxy interrupt vectors (0..%d)\n", NR_IRQS-1);
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc[i].status = IRQ_DISABLED;
+		irq_desc[i].action = NULL;
+		irq_desc[i].depth = 1;
+
+		set_irq_chip_and_handler_name(i, &co_pic_irq_chip, handle_simple_irq, "CO");
+	}
+
+}
+
+void __init init_IRQ(void)
+{
+	int i;
+
+	/* all the set up before the call gates are initialised */
+	init_ISA_irqs();
+
+	/*
+	 * Cover the whole vector space, no vector can escape us.
+	 */
+	for (i = 0; i < (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) {
+		int vector = FIRST_EXTERNAL_VECTOR + i;
+		if (i >= NR_IRQS)
+			break;
+		if (vector != SYSCALL_VECTOR)
+			set_intr_gate(vector, interrupt[i]);
+	}
+}
Index: linux-2.6.33-source/arch/x86/kernel/ioport_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/ioport_cooperative.c
@@ -0,0 +1,15 @@
+/*
+ *	linux/arch/x86/kernel/ioport_cooperative.c
+ */
+
+#include <linux/syscalls.h>
+
+asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int turn_on)
+{
+	return -EPERM;
+}
+
+asmlinkage long sys_iopl(unsigned long unused)
+{
+	return -EPERM;
+}
Index: linux-2.6.33-source/lib/iomap.c
===================================================================
--- linux-2.6.33-source.orig/lib/iomap.c
+++ linux-2.6.33-source/lib/iomap.c
@@ -58,6 +58,7 @@
 		bad_io_access(port, #is_pio );			\
 } while (0)
 
+#ifndef CONFIG_COOPERATIVE
 #ifndef pio_read16be
 #define pio_read16be(port) swab16(inw(port))
 #define pio_read32be(port) swab32(inl(port))
@@ -223,6 +224,7 @@
 EXPORT_SYMBOL(iowrite8_rep);
 EXPORT_SYMBOL(iowrite16_rep);
 EXPORT_SYMBOL(iowrite32_rep);
+#endif
 
 /* Create a virtual mapping cookie for an IO port range */
 void __iomem *ioport_map(unsigned long port, unsigned int nr)
Index: linux-2.6.33-source/drivers/char/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/char/Kconfig
+++ linux-2.6.33-source/drivers/char/Kconfig
@@ -1100,6 +1100,7 @@
 config DEVPORT
 	bool
 	depends on !M68K
+	depends on !COOPERATIVE
 	depends on ISA || PCI
 	default y
 
Index: linux-2.6.33-source/drivers/crypto/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/crypto/Kconfig
+++ linux-2.6.33-source/drivers/crypto/Kconfig
@@ -52,6 +52,7 @@
 config CRYPTO_DEV_GEODE
 	tristate "Support for the Geode LX AES engine"
 	depends on X86_32 && PCI
+	depends on !COOPERATIVE
 	select CRYPTO_ALGAPI
 	select CRYPTO_BLKCIPHER
 	help
Index: linux-2.6.33-source/drivers/usb/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/usb/Kconfig
+++ linux-2.6.33-source/drivers/usb/Kconfig
@@ -17,6 +17,7 @@
 # NOTE:  SL-811 option should be board-specific ...
 config USB_ARCH_HAS_HCD
 	boolean
+	depends on !COOPERATIVE
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
 	default y if PCMCIA && !M32R			# sl811_cs
@@ -27,6 +28,7 @@
 # many non-PCI SOC chips embed OHCI
 config USB_ARCH_HAS_OHCI
 	boolean
+	depends on !COOPERATIVE
 	# ARM:
 	default y if SA1111
 	default y if ARCH_OMAP
@@ -55,6 +57,7 @@
 # some non-PCI hcds implement EHCI
 config USB_ARCH_HAS_EHCI
 	boolean
+	depends on !COOPERATIVE
 	default y if PPC_83xx
 	default y if SOC_AU1200
 	default y if ARCH_IXP4XX
Index: linux-2.6.33-source/arch/x86/mm/comap.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/mm/comap.c
@@ -0,0 +1,130 @@
+
+/*
+ * This source code is a part of coLinux source package.
+ *
+ * Copyright (C) 2008 Steve Shoecraft <sshoecraft@earthlink.net>
+ *
+ * The code is licensed under the GPL.  See the COPYING file in
+ * the root directory.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+
+static unsigned long *get_pp(void *host_buffer, int size) {
+	unsigned long *pp, flags;
+	int npages,pp_size,rc;
+
+	/* Get # of pages */
+	npages = size >> PAGE_SHIFT;
+	if ((npages * PAGE_SIZE) < size) npages++;
+
+	/* Alloc mem for phys pages */
+	pp_size = npages * sizeof(unsigned long);
+	pp = kmalloc(pp_size, GFP_KERNEL);
+	if (!pp) {
+		printk(KERN_ERR "co_map_buffer: error allocating memory for physical pages!\n");
+		return 0;
+	}
+
+	/* Request physical pages from the host */
+	co_passage_page_assert_valid();
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_GETPP;
+	co_passage_page->params[0] = (unsigned long) pp;
+	co_passage_page->params[1] = (unsigned long) host_buffer;
+	co_passage_page->params[2] = size;
+	co_switch_wrapper();
+	rc = co_passage_page->params[0];
+	co_passage_page_release(flags);
+	if (rc) {
+		printk(KERN_ERR "co_map_buffer: error getting physical pages from host!\n");
+		return 0;
+	}
+
+	return pp;
+}
+
+#define VM_OPTS VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_PFNMAP | VM_RAND_READ
+
+void *co_map_buffer(void *host_buffer, int size) {
+	unsigned long addr, *pp, *pd, *pt, pa;
+	struct vm_struct *area;
+	void *buffer;
+	int i,npages,pd_index,pt_index;
+
+	/* Get the physical pages for the host buffer */
+	pp = get_pp(host_buffer, size);
+	if (!pp) return 0;
+
+	/* Get an area of virtual memory */
+	area = get_vm_area(size, VM_OPTS);
+	buffer = area->addr;
+
+        npages = size >> PAGE_SHIFT;
+
+	addr = (unsigned long) buffer;
+	pd = (unsigned long *) init_mm.pgd;
+	while(npages) {
+		/* Get pt */
+		pd_index = pgd_index(addr);
+		if (pd[pd_index] != 0) {
+			pa = pd[pd_index] & PAGE_MASK;
+			pt = __va(CO_P_TO_PP(pa));
+		} else {
+			pt = (unsigned long *) kmalloc(PAGE_SIZE, GFP_KERNEL);
+			if (!pt) {
+				printk(KERN_ERR "co_map_buffer: unable to alloc new pt entry!\n");
+				return 0;
+			}
+			memset(pt, 0, PAGE_SIZE);
+			pa = CO_PP_TO_P(__pa(pt)) | _PAGE_TABLE;
+			pd[pd_index] = pa;
+		}
+
+		/* Fill pt */
+		pt_index = pte_index(addr);
+		for(i=pt_index; i < 1024; i++) {
+			if (!npages) break;
+			BUG_ON(pt[i] != 0);
+			pt[i] = *pp | _PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_DIRTY | _PAGE_ACCESSED;
+			pp++;
+			addr += PAGE_SIZE;
+			npages--;
+		}
+	}
+
+	return buffer;
+}
+
+#if 0
+void dump_pt(void *buf, int size) {
+	unsigned long addr, *pd, *pt;
+	int x, pd_index, pt_index, npages;
+
+	npages = size >> PAGE_SHIFT;
+
+	addr = (unsigned long) buf;
+	pd = (unsigned long *)  __va(read_cr3());
+	printk(KERN_INFO "pd: %p\n", pd);
+	while(npages) {
+		pd_index = pgd_index(addr);
+		printk(KERN_INFO "pd[%04d]: %lx\n", pd_index, pd[pd_index]);
+		BUG_ON(pd[pd_index] == 0);
+		pt = __va(CO_P_TO_PP(pd[pd_index] & PAGE_MASK));
+		pt_index = pte_index(addr);
+		for(x=pt_index; x < 1024; x++) {
+			if (!npages) break;
+			printk(KERN_INFO "%04d: pt[%04d]: %08lx\n", npages, x, pt[x]);
+			addr += PAGE_SIZE;
+			npages--;
+		}
+	}
+}
+#endif
Index: linux-2.6.33-source/arch/x86/kernel/vmlinux.lds.S
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/vmlinux.lds.S
+++ linux-2.6.33-source/arch/x86/kernel/vmlinux.lds.S
@@ -101,6 +101,7 @@
 #endif
 		. = ALIGN(8);
 		_stext = .;
+		_kernel_start = .;		/* coLinux kernel entry */
 		TEXT_TEXT
 		SCHED_TEXT
 		LOCK_TEXT
Index: linux-2.6.33-source/arch/x86/include/asm/fixmap.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/fixmap.h
+++ linux-2.6.33-source/arch/x86/include/asm/fixmap.h
@@ -25,6 +25,7 @@
 #else
 #include <asm/vsyscall.h>
 #endif
+#include <asm/cooperative.h>
 
 /*
  * We can't declare FIXADDR_TOP as variable for x86_64 because vsyscall
Index: linux-2.6.33-source/arch/x86/include/asm/io_32.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/io_32.h
+++ linux-2.6.33-source/arch/x86/include/asm/io_32.h
@@ -102,10 +102,18 @@
 
 #endif /* __KERNEL__ */
 
+#ifdef CONFIG_COOPERATIVE
+static inline void native_io_delay(void)
+{
+	asm volatile("jmp 1f; 1: jmp 1f; 1:" : : : "memory");
+}
+static inline void io_delay_init(void) {}
+#else
 extern void native_io_delay(void);
 
 extern int io_delay_type;
 extern void io_delay_init(void);
+#endif
 
 #if defined(CONFIG_PARAVIRT)
 #include <asm/paravirt.h>
Index: linux-2.6.33-source/arch/x86/include/asm/mmzone_32.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/mmzone_32.h
+++ linux-2.6.33-source/arch/x86/include/asm/mmzone_32.h
@@ -7,6 +7,7 @@
 #define _ASM_X86_MMZONE_32_H
 
 #include <asm/smp.h>
+#include <asm/cooperative.h>
 
 #ifdef CONFIG_NUMA
 extern struct pglist_data *node_data[];
Index: linux-2.6.33-source/arch/x86/include/asm/pgtable_32.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pgtable_32.h
+++ linux-2.6.33-source/arch/x86/include/asm/pgtable_32.h
@@ -17,6 +17,7 @@
 #include <asm/fixmap.h>
 #include <linux/threads.h>
 #include <asm/paravirt.h>
+#include <asm/cooperative.h>
 
 #include <linux/bitops.h>
 #include <linux/slab.h>
Index: linux-2.6.33-source/arch/x86/include/asm/pgtable_32_types.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pgtable_32_types.h
+++ linux-2.6.33-source/arch/x86/include/asm/pgtable_32_types.h
@@ -42,6 +42,8 @@
 
 #ifdef CONFIG_HIGHMEM
 # define VMALLOC_END	(PKMAP_BASE - 2 * PAGE_SIZE)
+#elif defined(CONFIG_COOPERATIVE)
+# define VMALLOC_END	(CO_VPTR_BASE_START - 2 * PAGE_SIZE)
 #else
 # define VMALLOC_END	(FIXADDR_START - 2 * PAGE_SIZE)
 #endif
Index: linux-2.6.33-source/kernel/sysctl.c
===================================================================
--- linux-2.6.33-source.orig/kernel/sysctl.c
+++ linux-2.6.33-source/kernel/sysctl.c
@@ -105,7 +105,7 @@
 static int __maybe_unused two = 2;
 static unsigned long one_ul = 1;
 static int one_hundred = 100;
-#ifdef CONFIG_PRINTK
+#if defined(CONFIG_PRINTK) && !defined(CONFIG_COOPERATIVE)
 static int ten_thousand = 10000;
 #endif
 
@@ -675,6 +675,7 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#ifndef CONFIG_COOPERATIVE
 	{
 		.procname	= "printk_delay",
 		.data		= &printk_delay_msec,
@@ -684,6 +685,7 @@
 		.extra1		= &zero,
 		.extra2		= &ten_thousand,
 	},
+#endif /* !CONFIG_COOPERATIVE */
 #endif
 	{
 		.procname	= "ngroups_max",
@@ -744,6 +746,7 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#ifndef CONFIG_COOPERATIVE
 	{
 		.procname	= "io_delay_type",
 		.data		= &io_delay_type,
@@ -751,6 +754,7 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#endif /* !CONFIG_COOPERATIVE */
 #endif
 #if defined(CONFIG_MMU)
 	{
Index: linux-2.6.33-source/arch/x86/include/asm/system.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/system.h
+++ linux-2.6.33-source/arch/x86/include/asm/system.h
@@ -6,6 +6,7 @@
 #include <asm/cpufeature.h>
 #include <asm/cmpxchg.h>
 #include <asm/nops.h>
+#include <asm/page.h>
 
 #include <linux/kernel.h>
 #include <linux/irqflags.h>
@@ -309,8 +310,22 @@
 #define write_cr0(x)	(native_write_cr0(x))
 #define read_cr2()	(native_read_cr2())
 #define write_cr2(x)	(native_write_cr2(x))
+#ifdef CONFIG_COOPERATIVE
+
+static inline unsigned long read_cr3(void)
+{
+	return CO_P_TO_PP(native_read_cr3());
+}
+
+static inline void write_cr3(unsigned long val)
+{
+	native_write_cr3(CO_PP_TO_P(val));
+}
+
+#else
 #define read_cr3()	(native_read_cr3())
 #define write_cr3(x)	(native_write_cr3(x))
+#endif
 #define read_cr4()	(native_read_cr4())
 #define read_cr4_safe()	(native_read_cr4_safe())
 #define write_cr4(x)	(native_write_cr4(x))
Index: linux-2.6.33-source/arch/x86/power/hibernate_32.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/power/hibernate_32.c
+++ linux-2.6.33-source/arch/x86/power/hibernate_32.c
@@ -65,7 +65,7 @@
 		if (!page_table)
 			return NULL;
 
-		set_pmd(pmd, __pmd(__pa(page_table) | _PAGE_TABLE));
+		set_pmd(pmd, __pmd(CO_PP_TO_P(__pa(page_table)) | _PAGE_TABLE));
 
 		BUG_ON(page_table != pte_offset_kernel(pmd, 0));
 
Index: linux-2.6.33-source/arch/x86/kernel/i8237.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/i8237.c
+++ linux-2.6.33-source/arch/x86/kernel/i8237.c
@@ -23,6 +23,7 @@
 
 static int i8237A_resume(struct sys_device *dev)
 {
+#ifndef CONFIG_COOPERATIVE
 	unsigned long flags;
 	int i;
 
@@ -41,6 +42,7 @@
 	enable_dma(4);
 
 	release_dma_lock(flags);
+#endif
 
 	return 0;
 }
Index: linux-2.6.33-source/arch/x86/mm/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/mm/Makefile
+++ linux-2.6.33-source/arch/x86/mm/Makefile
@@ -25,4 +25,6 @@
 obj-$(CONFIG_K8_NUMA)		+= k8topology_64.o
 obj-$(CONFIG_ACPI_NUMA)		+= srat_$(BITS).o
 
+obj-$(CONFIG_COOPERATIVE)	+= comap.o
+
 obj-$(CONFIG_MEMTEST)		+= memtest.o
Index: linux-2.6.33-source/arch/x86/include/asm/pgalloc.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pgalloc.h
+++ linux-2.6.33-source/arch/x86/include/asm/pgalloc.h
@@ -4,6 +4,7 @@
 #include <linux/threads.h>
 #include <linux/mm.h>		/* for struct page */
 #include <linux/pagemap.h>
+#include <asm/cooperative.h>
 
 static inline int  __paravirt_pgd_alloc(struct mm_struct *mm) { return 0; }
 
@@ -63,7 +64,7 @@
 				       pmd_t *pmd, pte_t *pte)
 {
 	paravirt_alloc_pte(mm, __pa(pte) >> PAGE_SHIFT);
-	set_pmd(pmd, __pmd(__pa(pte) | _PAGE_TABLE));
+	set_pmd(pmd, __pmd(CO_PP_TO_P(__pa(pte)) | _PAGE_TABLE));
 }
 
 static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd,
@@ -72,7 +73,7 @@
 	unsigned long pfn = page_to_pfn(pte);
 
 	paravirt_alloc_pte(mm, pfn);
-	set_pmd(pmd, __pmd(((pteval_t)pfn << PAGE_SHIFT) | _PAGE_TABLE));
+	set_pmd(pmd, __pmd(((pteval_t)CO_PFN_PP_TO_P(pfn) << PAGE_SHIFT) | _PAGE_TABLE));
 }
 
 #define pmd_pgtable(pmd) pmd_page(pmd)
Index: linux-2.6.33-source/arch/x86/kernel/process.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/process.c
+++ linux-2.6.33-source/arch/x86/kernel/process.c
@@ -12,6 +12,7 @@
 #include <linux/user-return-notifier.h>
 #include <linux/dmi.h>
 #include <linux/utsname.h>
+#include <linux/cooperative_internal.h>
 #include <trace/events/power.h>
 #include <linux/hw_breakpoint.h>
 #include <asm/system.h>
@@ -357,6 +358,12 @@
 }
 #endif
 
+#ifdef CONFIG_COOPERATIVE
+void __cpuinit select_idle_routine(const struct cpuinfo_x86 *c)
+{
+	pm_idle = co_idle_processor;
+}
+#else /* CONFIG_COOPERATIVE */
 /*
  * We use this if we don't have any better
  * idle routine..
@@ -682,6 +689,7 @@
 	return 0;
 }
 early_param("idle", idle_setup);
+#endif /* CONFIG_COOPERATIVE */
 
 unsigned long arch_align_stack(unsigned long sp)
 {
Index: linux-2.6.33-source/arch/x86/kvm/Kconfig
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kvm/Kconfig
+++ linux-2.6.33-source/arch/x86/kvm/Kconfig
@@ -6,7 +6,7 @@
 
 menuconfig VIRTUALIZATION
 	bool "Virtualization"
-	depends on HAVE_KVM || X86
+	depends on (HAVE_KVM || X86) && !COOPERATIVE
 	default y
 	---help---
 	  Say Y here to get to see options for using your Linux host to run other
Index: linux-2.6.33-source/arch/x86/include/asm/io.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/io.h
+++ linux-2.6.33-source/arch/x86/include/asm/io.h
@@ -167,7 +167,12 @@
  */
 static inline void __iomem *ioremap(resource_size_t offset, unsigned long size)
 {
+#ifdef CONFIG_COOPERATIVE
+	panic("ioremap %ld:%ld\n", (long)offset, size);
+	return NULL;
+#else
 	return ioremap_nocache(offset, size);
+#endif
 }
 
 extern void iounmap(volatile void __iomem *addr);
Index: linux-2.6.33-source/arch/x86/kernel/irqinit.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/irqinit.c
+++ linux-2.6.33-source/arch/x86/kernel/irqinit.c
@@ -43,6 +43,7 @@
  * (these are usually mapped into the 0x30-0xff vector range)
  */
 
+#ifndef CONFIG_COOPERATIVE
 #ifdef CONFIG_X86_32
 /*
  * Note that on a 486, we don't want to do a SIGFPE on an irq13
@@ -82,6 +83,7 @@
 	.handler = no_action,
 	.name = "cascade",
 };
+#endif /* !CONFIG_COOPERATIVE */
 
 DEFINE_PER_CPU(vector_irq_t, vector_irq) = {
 	[0 ... IRQ0_VECTOR - 1] = -1,
@@ -116,6 +118,7 @@
 	return 0;
 }
 
+#ifndef CONFIG_COOPERATIVE
 void __init init_ISA_irqs(void)
 {
 	int i;
@@ -249,3 +252,4 @@
 	irq_ctx_init(smp_processor_id());
 #endif
 }
+#endif /* !CONFIG_COOPERATIVE */
Index: linux-2.6.33-source/arch/x86/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/Makefile
+++ linux-2.6.33-source/arch/x86/Makefile
@@ -116,8 +116,10 @@
 # Kernel objects
 
 head-y := arch/x86/kernel/head_$(BITS).o
+ifndef CONFIG_COOPERATIVE
 head-y += arch/x86/kernel/head$(BITS).o
 head-y += arch/x86/kernel/head.o
+endif
 head-y += arch/x86/kernel/init_task.o
 
 libs-y  += arch/x86/lib/
Index: linux-2.6.33-source/arch/x86/kernel/x86_init_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/x86_init_cooperative.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2009 Thomas Gleixner <tglx@linutronix.de>
+ *
+ *  For licencing details see kernel-base/COPYING
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+
+#include <asm/bios_ebda.h>
+#include <asm/paravirt.h>
+#include <asm/mpspec.h>
+#include <asm/setup.h>
+#include <asm/apic.h>
+#include <asm/e820.h>
+#include <asm/time.h>
+#include <asm/irq.h>
+#include <asm/pat.h>
+#include <asm/tsc.h>
+#include <asm/iommu.h>
+
+void __cpuinit x86_init_noop(void) { }
+void __init x86_init_uint_noop(unsigned int unused) { }
+void __init x86_init_pgd_noop(pgd_t *unused) { }
+int __init iommu_init_noop(void) { return 0; }
+void iommu_shutdown_noop(void) { }
+
+static void __init reserve_standard_io_resources_noop(void) { }
+static unsigned long mach_get_cmos_time_noop(void) { return 0; }
+static int mach_set_rtc_mmss_noop(unsigned long unused) { return 0; }
+static void __init hpet_time_init_noop(void) { }
+static void __init native_init_IRQ_noop(void) { }
+static char *__init default_machine_specific_memory_setup_noop(void) { return "CO-dummy"; }
+static unsigned long native_calibrate_tsc_noop(void) { return 0; }
+
+/*
+ * The platform setup functions are preset with the default functions
+ * for standard PC hardware.
+ */
+struct x86_init_ops x86_init __initdata = {
+
+	.resources = {
+		.probe_roms		= x86_init_noop,
+		.reserve_resources	= reserve_standard_io_resources_noop,
+		.memory_setup		= default_machine_specific_memory_setup_noop,
+	},
+
+	.mpparse = {
+		.mpc_record		= x86_init_uint_noop,
+		.setup_ioapic_ids	= x86_init_noop,
+		.mpc_apic_id		= default_mpc_apic_id,
+		.smp_read_mpc_oem	= default_smp_read_mpc_oem,
+		.mpc_oem_bus_info	= default_mpc_oem_bus_info,
+		.find_smp_config	= default_find_smp_config,
+		.get_smp_config		= default_get_smp_config,
+	},
+
+	.irqs = {
+		.pre_vector_init	= init_ISA_irqs,
+		.intr_init		= native_init_IRQ_noop,
+		.trap_init		= x86_init_noop,
+	},
+
+	.oem = {
+		.arch_setup		= x86_init_noop,
+		.banner			= default_banner,
+	},
+
+	.paging = {
+		.pagetable_setup_start	= native_pagetable_setup_start,
+		.pagetable_setup_done	= native_pagetable_setup_done,
+	},
+
+	.timers = {
+		.setup_percpu_clockev	= setup_boot_APIC_clock,
+		.tsc_pre_init		= x86_init_noop,
+		.timer_init		= hpet_time_init_noop,
+	},
+
+	.iommu = {
+		.iommu_init		= iommu_init_noop,
+	},
+};
+
+struct x86_cpuinit_ops x86_cpuinit __cpuinitdata = {
+	.setup_percpu_clockev		= setup_secondary_APIC_clock,
+};
+
+struct x86_platform_ops x86_platform = {
+	.calibrate_tsc			= native_calibrate_tsc_noop,
+	.get_wallclock			= mach_get_cmos_time_noop,
+	.set_wallclock			= mach_set_rtc_mmss_noop,
+	.iommu_shutdown			= iommu_shutdown_noop,
+	.is_untracked_pat_range		= is_ISA_range,
+};
Index: linux-2.6.33-source/arch/x86/kernel/cpu/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/cpu/Makefile
+++ linux-2.6.33-source/arch/x86/kernel/cpu/Makefile
@@ -14,7 +14,10 @@
 
 obj-y			:= intel_cacheinfo.o addon_cpuid_features.o
 obj-y			+= proc.o capflags.o powerflags.o common.o
-obj-y			+= vmware.o hypervisor.o sched.o
+ifndef CONFIG_COOPERATIVE
+obj-y			+= vmware.o hypervisor.o
+endif
+obj-y			+= sched.o
 
 obj-$(CONFIG_X86_32)	+= bugs.o cmpxchg.o
 obj-$(CONFIG_X86_64)	+= bugs_64.o
Index: linux-2.6.33-source/arch/x86/kernel/cpu/common.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/cpu/common.c
+++ linux-2.6.33-source/arch/x86/kernel/cpu/common.c
@@ -818,7 +818,9 @@
 	detect_ht(c);
 #endif
 
+#ifndef CONFIG_COOPERATIVE
 	init_hypervisor(c);
+#endif
 
 	/*
 	 * Clear/Set all flags overriden by options, need do it
@@ -864,7 +866,9 @@
 void __init identify_boot_cpu(void)
 {
 	identify_cpu(&boot_cpu_data);
+#ifndef CONFIG_COOPERATIVE
 	init_c1e_mask();
+#endif
 #ifdef CONFIG_X86_32
 	sysenter_setup();
 	enable_sep_cpu();
Index: linux-2.6.33-source/include/linux/page-flags.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/page-flags.h
+++ linux-2.6.33-source/include/linux/page-flags.h
@@ -110,6 +110,11 @@
 #endif
 	__NR_PAGEFLAGS,
 
+/* coLinux flag should not clear by PAGE_FLAGS_CHECK_AT_PREP */
+#ifdef CONFIG_COOPERATIVE
+	PG_co_host_mapped,	/* Page is mapped on coLinux host */
+#endif
+
 	/* Filesystems */
 	PG_checked = PG_owner_priv_1,
 
@@ -284,6 +289,11 @@
 
 u64 stable_page_flags(struct page *page);
 
+#ifdef CONFIG_COOPERATIVE
+CLEARPAGEFLAG(CoHostMapped, co_host_mapped)
+TESTSETFLAG(CoHostMapped, co_host_mapped)
+#endif
+
 static inline int PageUptodate(struct page *page)
 {
 	int ret = test_bit(PG_uptodate, &(page)->flags);
Index: linux-2.6.33-source/arch/x86/kernel/cpu/intel.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/cpu/intel.c
+++ linux-2.6.33-source/arch/x86/kernel/cpu/intel.c
@@ -91,7 +91,9 @@
 	if (c->x86_power & (1 << 8)) {
 		set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
 		set_cpu_cap(c, X86_FEATURE_NONSTOP_TSC);
+#ifndef CONFIG_COOPERATIVE
 		if (!check_tsc_unstable())
+#endif
 			sched_clock_stable = 1;
 	}
 
Index: linux-2.6.33-source/scripts/mkmakefile
===================================================================
--- linux-2.6.33-source.orig/scripts/mkmakefile
+++ linux-2.6.33-source/scripts/mkmakefile
@@ -44,7 +44,10 @@
 
 Makefile:;
 
-\$(all) %/: all
+\$(all): all
+	@:
+
+%/: all
 	@:
 
 EOF
Index: linux-2.6.33-source/arch/x86/lib/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/lib/Makefile
+++ linux-2.6.33-source/arch/x86/lib/Makefile
@@ -16,7 +16,11 @@
 
 obj-$(CONFIG_SMP) += msr-smp.o cache-smp.o
 
+ifdef CONFIG_COOPERATIVE
+lib-y := delay_cooperative.o
+else
 lib-y := delay.o
+endif
 lib-y += thunk_$(BITS).o
 lib-y += usercopy_$(BITS).o getuser.o putuser.o
 lib-y += memcpy_$(BITS).o
Index: linux-2.6.33-source/arch/x86/kernel/timer_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/kernel/timer_cooperative.c
@@ -0,0 +1,142 @@
+/*
+ *  Cooperative mode timer.
+ *
+ *  Dan Aloni <da-x@colinux.org>, 2003-2004 (C).
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include <asm/timer.h>
+#include <asm/delay.h>
+
+#include <linux/clockchips.h>
+#include <linux/clocksource.h>
+#include <linux/cooperative.h>
+#include <linux/cooperative_internal.h>
+
+#define CO_CLOCK_SHIFT 20
+
+/* FSEC = 10^-15
+   NSEC = 10^-9 */
+#define FSEC_PER_NSEC	1000000
+
+/* 100Hz is fix from damons 10ms setup */
+#define CO_HOST_HZ 100
+
+unsigned int cpu_khz;
+EXPORT_SYMBOL(cpu_khz);
+
+/*
+ * Functions copied from time.c
+ */
+unsigned long profile_pc(struct pt_regs *regs)
+{
+	unsigned long pc = instruction_pointer(regs);
+
+	return pc;
+}
+EXPORT_SYMBOL(profile_pc);
+
+/* Read system date and clock at startup */
+void read_persistent_clock(struct timespec *ts)
+{
+	unsigned long flags;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_GET_TIME;
+	co_switch_wrapper();
+	ts->tv_sec = co_passage_page->params[0];
+	ts->tv_nsec = 0;
+	co_passage_page_release(flags);
+}
+
+/* need by ntp.c */
+int update_persistent_clock(struct timespec now)
+{
+	return 0;
+}
+
+
+/*
+ * Clock source related code, based on arch/arm/mach-omap1/time.c
+ */
+
+static cycle_t query_host_highprec_time(struct clocksource *cs)
+{
+	unsigned long flags;
+	unsigned long long this_time;
+
+	co_passage_page_assert_valid();
+
+	co_passage_page_acquire(&flags);
+	co_passage_page->operation = CO_OPERATION_GET_HIGH_PREC_TIME;
+	co_switch_wrapper();
+	this_time = *(unsigned long long *)(&co_passage_page->params[0]);
+	co_passage_page_release(flags);
+
+	return this_time;
+}
+
+static struct clocksource co_clocksource = {
+	.name		= "cooperative",
+	.rating		= 450,
+	.read		= query_host_highprec_time,
+	.mask		= CLOCKSOURCE_MASK(64),
+	.shift		= CO_CLOCK_SHIFT,
+	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+
+static void co_timer_setup(enum clock_event_mode mode,
+			   struct clock_event_device *evt)
+{
+}
+
+struct clock_event_device co_clockevent = {
+	.name		= "clock",
+	.features	= CLOCK_EVT_FEAT_PERIODIC,
+	.set_mode	= co_timer_setup,
+	.shift		= CO_CLOCK_SHIFT,
+};
+
+static irqreturn_t co_timer_interrupt(int irq, void *dev_id)
+{
+	struct clock_event_device *evt = &co_clockevent;
+
+	evt->event_handler(evt);
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction co_timer_irq = {
+	.name		= "timer",
+	.flags		= IRQF_DISABLED | IRQF_TIMER | IRQF_IRQPOLL,
+	.handler	= co_timer_interrupt,
+};
+
+extern void (*late_time_init)(void);
+static void __init co_register_timer(void)
+{
+	setup_irq(TIMER_IRQ, &co_timer_irq);
+}
+
+void __init time_init(void)
+{
+	u64 tmp;
+
+	tmp = (u64)CO_HOST_HZ << CO_CLOCK_SHIFT;
+	do_div(tmp, FSEC_PER_NSEC);
+	co_clockevent.mult = (u32)tmp;
+
+	co_clocksource.mult = clocksource_hz2mult(CO_HOST_HZ, CO_CLOCK_SHIFT);
+	co_clockevent.cpumask = cpumask_of(0);
+
+	clockevents_register_device(&co_clockevent);
+	late_time_init = co_register_timer;
+
+	cpu_khz = co_boot_params.co_cpu_khz;
+}
Index: linux-2.6.33-source/arch/x86/include/asm/delay.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/delay.h
+++ linux-2.6.33-source/arch/x86/include/asm/delay.h
@@ -26,6 +26,8 @@
 	((n) > 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
 	__ndelay(n))
 
+#ifndef CONFIG_COOPERATIVE
 void use_tsc_delay(void);
+#endif
 
 #endif /* _ASM_X86_DELAY_H */
Index: linux-2.6.33-source/arch/x86/include/asm/timex.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/timex.h
+++ linux-2.6.33-source/arch/x86/include/asm/timex.h
@@ -7,6 +7,8 @@
 /* Assume we use the PIT time source for the clock tick */
 #define CLOCK_TICK_RATE		PIT_TICK_RATE
 
+#ifndef CONFIG_COOPERATIVE
 #define ARCH_HAS_READ_CURRENT_TIMER
+#endif /* !CONFIG_COOPERATIVE */
 
 #endif /* _ASM_X86_TIMEX_H */
Index: linux-2.6.33-source/arch/x86/include/asm/msr.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/msr.h
+++ linux-2.6.33-source/arch/x86/include/asm/msr.h
@@ -113,7 +113,12 @@
 	return err;
 }
 
+#ifdef CONFIG_COOPERATIVE
+/* FIXME: */
+#define native_read_tsc() 0
+#else
 extern unsigned long long native_read_tsc(void);
+#endif
 
 extern int native_rdmsr_safe_regs(u32 regs[8]);
 extern int native_wrmsr_safe_regs(u32 regs[8]);
Index: linux-2.6.33-source/arch/x86/lib/delay_cooperative.c
===================================================================
--- /dev/null
+++ linux-2.6.33-source/arch/x86/lib/delay_cooperative.c
@@ -0,0 +1,44 @@
+/*
+ *	Delay Loops for coLinux
+ *
+ *	The __delay function is not very precise under coLinux.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/timex.h>
+#include <linux/preempt.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <asm/processor.h>
+#include <asm/delay.h>
+#include <asm/timer.h>
+
+void __delay(unsigned long loops)
+{
+	struct timespec tv;
+
+	/*
+	 * A bogos delay loop for creating BogoMIPS...
+	 */
+
+	loops = loops / 0x10000;
+	while (loops--)
+		read_persistent_clock(&tv);
+}
+EXPORT_SYMBOL(__delay);
+
+void __const_udelay(unsigned long xloops)
+{
+	int d0;
+
+	xloops *= 4;
+	asm("mull %%edx"
+		:"=d" (xloops), "=&a" (d0)
+		:"1" (xloops), "0"
+		(cpu_data(raw_smp_processor_id()).loops_per_jiffy * (HZ/4)));
+
+	__delay(++xloops);
+}
+EXPORT_SYMBOL(__const_udelay);
Implements console support


Index: linux-2.6.33-source/drivers/video/console/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/video/console/Kconfig
+++ linux-2.6.33-source/drivers/video/console/Kconfig
@@ -6,7 +6,7 @@
 
 config VGA_CONSOLE
 	bool "VGA text console" if EMBEDDED || !X86
-	depends on !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && !ARCH_VERSATILE && !SUPERH && !BLACKFIN && !AVR32 && !MN10300
+	depends on !COOPERATIVE && !ARCH_ACORN && !ARCH_EBSA110 && !4xx && !8xx && !SPARC && !M68K && !PARISC && !FRV && !ARCH_VERSATILE && !SUPERH && !BLACKFIN && !AVR32 && !MN10300
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
@@ -43,6 +43,14 @@
 	 buffer.  Each 64KB will give you approximately 16 80x25
 	 screenfuls of scrollback buffer
 
+config COOPERATIVE_CONSOLE
+	bool 'coLinux Pseudo-VGA text console' if COOPERATIVE
+	depends on !VGA_CONSOLE && COOPERATIVE
+	default y
+	help
+	  You need to say Y here if you compile a Linux kernel in cooperative
+	  mode.
+
 config MDA_CONSOLE
 	depends on !M68K && !PARISC && ISA
 	tristate "MDA text console (dual-headed) (EXPERIMENTAL)"
@@ -69,7 +77,7 @@
 
 config DUMMY_CONSOLE
 	bool
-	depends on VGA_CONSOLE!=y || SGI_NEWPORT_CONSOLE!=y 
+	depends on COOPERATIVE_CONSOLE!=y || VGA_CONSOLE!=y || SGI_NEWPORT_CONSOLE!=y
 	default y
 
 config DUMMY_CONSOLE_COLUMNS
Index: linux-2.6.33-source/include/linux/console.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/console.h
+++ linux-2.6.33-source/include/linux/console.h
@@ -61,6 +61,7 @@
 
 extern const struct consw dummy_con;	/* dummy console buffer */
 extern const struct consw vga_con;	/* VGA text console */
+extern const struct consw colinux_con;	/* coLinux Mode text console */
 extern const struct consw newport_con;	/* SGI Newport console  */
 extern const struct consw prom_con;	/* SPARC PROM console */
 
Index: linux-2.6.33-source/drivers/video/console/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/video/console/Makefile
+++ linux-2.6.33-source/drivers/video/console/Makefile
@@ -24,6 +24,7 @@
 obj-$(CONFIG_SGI_NEWPORT_CONSOLE) += newport_con.o font.o
 obj-$(CONFIG_STI_CONSOLE)         += sticon.o sticore.o font.o
 obj-$(CONFIG_VGA_CONSOLE)         += vgacon.o
+obj-$(CONFIG_COOPERATIVE_CONSOLE) += cocon.o
 obj-$(CONFIG_MDA_CONSOLE)         += mdacon.o
 obj-$(CONFIG_FRAMEBUFFER_CONSOLE) += fbcon.o bitblit.o font.o softcursor.o
 ifeq ($(CONFIG_FB_TILEBLITTING),y)
Index: linux-2.6.33-source/drivers/video/console/cocon.c
===================================================================
--- linux-2.6.33-source.orig/drivers/video/console/cocon.c
+++ linux-2.6.33-source/drivers/video/console/cocon.c
@@ -170,8 +170,8 @@
 	co_console_message_t *message;
 	co_message_t *co_message;
 
-	if (count > CO_MAX_PARAM_SIZE/2 - 16)
-		return;
+//	if (count > CO_MAX_PARAM_SIZE/2 - 16)
+//		return;
 
 	co_message = co_send_message_save(&flags);
 	if (!co_message)
@@ -454,8 +454,8 @@
 	co_send_message_restore(flags);
 }
 
-static int cocon_resize(struct vc_data *c, unsigned int width,
-				unsigned int height)
+static int cocon_resize(struct vc_data *vc, unsigned int width,
+			unsigned int height, unsigned int user)
 {
 	return -EINVAL;
 }
Index: linux-2.6.33-source/include/linux/console_struct.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/console_struct.h
+++ linux-2.6.33-source/include/linux/console_struct.h
@@ -130,7 +130,11 @@
 #define CUR_HWMASK	0x0f
 #define CUR_SWMASK	0xfff0
 
-#define CUR_DEFAULT CUR_UNDERLINE
+#ifdef CONFIG_COOPERATIVE
+# define CUR_DEFAULT CUR_DEF
+#else
+# define CUR_DEFAULT CUR_UNDERLINE
+#endif
 
 #define CON_IS_VISIBLE(conp) (*conp->vc_display_fg == conp)
 
Index: linux-2.6.33-source/drivers/char/vt.c
===================================================================
--- linux-2.6.33-source.orig/drivers/char/vt.c
+++ linux-2.6.33-source/drivers/char/vt.c
@@ -2858,7 +2858,8 @@
 		vc->vc_palette[k++] = default_grn[j] ;
 		vc->vc_palette[k++] = default_blu[j] ;
 	}
-	vc->vc_def_color       = 0x07;   /* white */
+	if (!vc->vc_def_color)
+		vc->vc_def_color       = 0x07;   /* white */
 	vc->vc_ulcolor         = default_underline_color;
 	vc->vc_itcolor         = default_italic_color;
 	vc->vc_halfcolor       = 0x08;   /* grey */
Serial support

Index: linux-2.6.33-source/drivers/char/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/char/Kconfig
+++ linux-2.6.33-source/drivers/char/Kconfig
@@ -112,7 +112,7 @@
 
 config SERIAL_NONSTANDARD
 	bool "Non-standard serial port support"
-	depends on HAS_IOMEM
+	depends on HAS_IOMEM && !COOPERATIVE
 	---help---
 	  Say Y here if you have any non-standard serial boards -- boards
 	  which aren't supported using the standard "dumb" serial driver.
Index: linux-2.6.33-source/drivers/serial/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/serial/Kconfig
+++ linux-2.6.33-source/drivers/serial/Kconfig
@@ -1491,3 +1491,15 @@
 	Support for running a console on the GRLIB APBUART
 
 endmenu
+
+config SERIAL_COOPERATIVE
+	bool "coLinux serial device support"
+	depends on COOPERATIVE
+	default y
+	help
+	  Say Y, if you have colinux
+
+config SERIAL_COOPERATIVE_CONSOLE
+	bool "coLinux serial console support"
+	depends on SERIAL_COOPERATIVE=y
+	select SERIAL_CORE_CONSOLE
Index: linux-2.6.33-source/drivers/serial/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/serial/Makefile
+++ linux-2.6.33-source/drivers/serial/Makefile
@@ -82,3 +82,4 @@
 obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
 obj-$(CONFIG_SERIAL_TIMBERDALE)	+= timbuart.o
 obj-$(CONFIG_SERIAL_GRLIB_GAISLER_APBUART) += apbuart.o
+obj-$(CONFIG_SERIAL_COOPERATIVE) += coserial.o
Implements network support


Index: linux-2.6.33-source/drivers/net/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/net/Kconfig
+++ linux-2.6.33-source/drivers/net/Kconfig
@@ -139,6 +139,11 @@
 	  When one end receives the packet it appears on its pair and vice
 	  versa.
 
+config CONET_COOPERATIVE
+	bool 'Cooperative Virtual Ethernet driver support'
+	depends on COOPERATIVE
+	select MII
+
 config NET_SB1000
 	tristate "General Instruments Surfboard 1000"
 	depends on PNP
@@ -173,7 +178,7 @@
 
 menuconfig NET_ETHERNET
 	bool "Ethernet (10 or 100Mbit)"
-	depends on !UML
+	depends on !UML && !COOPERATIVE
 	---help---
 	  Ethernet (also called IEEE 802.3 or ISO 8802-2) is the most common
 	  type of Local Area Network (LAN) in universities and companies.
@@ -1963,7 +1968,7 @@
 
 menuconfig NETDEV_1000
 	bool "Ethernet (1000 Mbit)"
-	depends on !UML
+	depends on !UML && !COOPERATIVE
 	default y
 	---help---
 	  Ethernet (also called IEEE 802.3 or ISO 8802-2) is the most common
@@ -2497,7 +2502,7 @@
 
 menuconfig NETDEV_10000
 	bool "Ethernet (10000 Mbit)"
-	depends on !UML
+	depends on !UML && !COOPERATIVE
 	default y
 	---help---
 	  Say Y here to get to see options for 10 Gigabit Ethernet drivers.
Index: linux-2.6.33-source/drivers/net/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/net/Makefile
+++ linux-2.6.33-source/drivers/net/Makefile
@@ -206,6 +206,7 @@
 
 # This is also a 82596 and should probably be merged
 obj-$(CONFIG_LP486E) += lp486e.o
+obj-$(CONFIG_CONET_COOPERATIVE) += conet.o
 
 obj-$(CONFIG_ETH16I) += eth16i.o
 obj-$(CONFIG_ZORRO8390) += zorro8390.o 8390.o
Index: linux-2.6.33-source/drivers/net/conet.c
===================================================================
--- linux-2.6.33-source.orig/drivers/net/conet.c
+++ linux-2.6.33-source/drivers/net/conet.c
@@ -1,3 +1,4 @@
+
 /*
  *  Copyright (C) 2003-2004 Dan Aloni <da-x@gmx.net>
  *  Copyright (C) 2004 Pat Erley
@@ -321,6 +322,14 @@
 
 MODULE_DEVICE_TABLE(pci, conet_pci_ids);
 
+static const struct net_device_ops net_ops = {
+	.ndo_open		= conet_open,
+	.ndo_stop		= conet_stop,
+	.ndo_start_xmit 	= conet_hard_start_xmit,
+	.ndo_get_stats		= conet_get_stats,
+	.ndo_do_ioctl		= conet_ioctl,
+};
+
 static int __devinit conet_pci_probe( struct pci_dev *pdev,
                                     const struct pci_device_id *ent)
 {
@@ -346,16 +355,11 @@
 		rc = -ENOMEM;
 		goto error_out_pdev;
 	}
-	SET_MODULE_OWNER(dev);
 	SET_NETDEV_DEV(dev, &pdev->dev);
 	memcpy(dev->dev_addr, addr, 6);
 
-	dev->open = conet_open;
-	dev->stop = conet_stop;
-	dev->hard_start_xmit = conet_hard_start_xmit;
+	dev->netdev_ops	= &net_ops;
 	dev->ethtool_ops = &conet_ethtool_ops;
-	dev->get_stats = conet_get_stats;
-	dev->do_ioctl = conet_ioctl;
 	dev->irq = pdev->irq;
 
 	priv = netdev_priv(dev);
Index: linux-2.6.33-source/include/linux/major.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/major.h
+++ linux-2.6.33-source/include/linux/major.h
@@ -131,6 +131,7 @@
 #define VIOCD_MAJOR		113
 
 #define ATARAID_MAJOR		114
+#define COLINUX_MAJOR		117
 
 #define SCSI_DISK8_MAJOR	128
 #define SCSI_DISK9_MAJOR	129
Index: linux-2.6.33-source/drivers/block/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/block/Kconfig
+++ linux-2.6.33-source/drivers/block/Kconfig
@@ -383,6 +383,15 @@
 	  will prevent RAM block device backing store memory from being
 	  allocated from highmem (only a problem for highmem systems).
 
+config BLK_DEV_COBD
+	tristate 'Cooperative block device support'
+	default y
+	depends on COOPERATIVE
+	help
+	  Virtual block device support for cooperative kernels.
+
+	  If unsure, say Y.
+
 config CDROM_PKTCDVD
 	tristate "Packet writing on CD/DVD media"
 	depends on !UML
Index: linux-2.6.33-source/drivers/block/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/block/Makefile
+++ linux-2.6.33-source/drivers/block/Makefile
@@ -14,6 +14,7 @@
 obj-$(CONFIG_ATARI_FLOPPY)	+= ataflop.o
 obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= brd.o
+obj-$(CONFIG_BLK_DEV_COBD)	+= cobd.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
 obj-$(CONFIG_BLK_DEV_XD)	+= xd.o
 obj-$(CONFIG_BLK_CPQ_DA)	+= cpqarray.o
Index: linux-2.6.33-source/drivers/block/cobd.c
===================================================================
--- linux-2.6.33-source.orig/drivers/block/cobd.c
+++ linux-2.6.33-source/drivers/block/cobd.c
@@ -44,7 +44,6 @@
 	long rc;
 
 	co_passage_page_assert_valid();
-
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_DEVICE;
 	co_passage_page->params[0] = CO_DEVICE_BLOCK;
@@ -70,21 +69,21 @@
 	return cobd_request(cobd, CO_BLOCK_GET_ALIAS, out_request);
 }
 
-static int cobd_ioctl(struct inode * inode, struct file * file,
+static int cobd_ioctl(struct block_device *bdev, fmode_t mode,
 		      unsigned int cmd, unsigned long arg)
 {
 	return -ENOTTY; /* unknown command */
 }
 
-static int cobd_open(struct inode *inode, struct file *file)
+static int cobd_open(struct block_device *bdev, fmode_t mode)
 {
-	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	struct cobd_device *cobd = bdev->bd_disk->private_data;
 	co_block_request_t *co_request;
 	co_block_request_t stat_request;
 	unsigned long flags;
 	int result;
 
-	if (cobd->device  &&  cobd->device != inode->i_bdev)
+	if (cobd->device && cobd->device != bdev)
 		return -EBUSY;
 
 	if (cobd->refcount == 0) {
@@ -96,7 +95,6 @@
 	result = 0;
 
 	co_passage_page_assert_valid();
-
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_DEVICE;
 	co_passage_page->params[0] = CO_DEVICE_BLOCK;
@@ -114,22 +112,21 @@
 		return result;
 
 	if (cobd->refcount == 1) {
-		set_capacity(inode->i_bdev->bd_disk, stat_request.disk_size >> hardsect_size_shift);
-		cobd->device = inode->i_bdev;
+		set_capacity(bdev->bd_disk, stat_request.disk_size >> hardsect_size_shift);
+		cobd->device = bdev;
 	}
 
 	return 0;
 }
 
-static int cobd_release(struct inode *inode, struct file *file)
+static int cobd_release(struct gendisk *disk, fmode_t mode)
 {
-	struct cobd_device *cobd = (struct cobd_device *)(inode->i_bdev->bd_disk->private_data);
+	struct cobd_device *cobd = disk->private_data;
 	co_block_request_t *co_request;
 	unsigned long flags;
 	int ret = 0;
 
 	co_passage_page_assert_valid();
-
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_DEVICE;
 	co_passage_page->params[0] = CO_DEVICE_BLOCK;
@@ -151,14 +148,17 @@
 /*
  * Handle an I/O request.
  */
-static int cobd_transfer(struct cobd_device *cobd, struct request *req, int *async)
+static void cobd_transfer(struct request_queue *q, struct request *req)
 {
+	struct cobd_device *cobd = (struct cobd_device *)(req->rq_disk->private_data);
 	co_block_request_t *co_request;
 	unsigned long flags;
+	int async;
 	int ret;
 
-	co_passage_page_assert_valid();
+next_segment:
 
+	co_passage_page_assert_valid();
 	co_passage_page_acquire(&flags);
 	co_passage_page->operation = CO_OPERATION_DEVICE;
 	co_passage_page->params[0] = CO_DEVICE_BLOCK;
@@ -166,47 +166,43 @@
 	co_request = (co_block_request_t *)&co_passage_page->params[2];
 	co_request->type = (rq_data_dir(req) == READ) ? CO_BLOCK_READ : CO_BLOCK_WRITE;
 	co_request->irq_request = req;
-	co_request->offset = ((unsigned long long)(req->sector)) << hardsect_size_shift;
-	co_request->size = req->current_nr_sectors << hardsect_size_shift;
+	co_request->offset = ((unsigned long long)blk_rq_pos(req)) << hardsect_size_shift;
+	co_request->size = blk_rq_cur_bytes(req);
 	co_request->address = req->buffer;
 	co_request->rc = 0;
 	co_request->async = 0;
 	co_switch_wrapper();
-	*async = co_request->async;
+	async = co_request->async;
 	ret = co_request->rc;
-
 	co_passage_page_release(flags);
-	return ret;
+
+	/*
+	 * OK:   ret ==  0
+	 * FAIL: ret == -1
+	 */
+	if (ret == CO_BLOCK_REQUEST_RETCODE_OK) {
+		if (async)
+			return; /* wait for interrupt */
+
+		if (__blk_end_request_cur(req, 0))
+			goto next_segment;
+
+	} else {
+		__blk_end_request_all(req, -EIO);
+	}
 }
 
-static void do_cobd_request(request_queue_t *q)
+static void do_cobd_request(struct request_queue *q)
 {
         struct request *req;
-	struct cobd_device *cobd;
-
-        while ((req = elv_next_request(q)) != NULL) {
-		int ret;
-		int async;
 
+        while ((req = blk_fetch_request(q)) != NULL) {
 		if (!blk_fs_request(req)) {
-			end_request(req, 0);
+			__blk_end_request_all(req, -EIO);
 			continue;
 		}
-		cobd = (struct cobd_device *)(req->rq_disk->private_data);
-
-		ret = cobd_transfer(cobd, req, &async);
 
-		/*
-		 * OK:   ret ==  0 --> uptodate = 1
-		 * FAIL: ret == -1 --> uptodate = 0
-		 */
-		if (ret == CO_BLOCK_REQUEST_RETCODE_OK) {
-			if (async)
-				break; /* wait for interrupt */
-			end_request(req, 1);
-		} else {
-			end_request(req, 0);
-		}
+		cobd_transfer(q, req);
         }
 }
 
@@ -231,8 +227,10 @@
 		BUG_ON(!req);
 
 		spin_lock(&cobd_lock);
-		end_request(req, intr->uptodate);
-		do_cobd_request(req->q);
+		if (__blk_end_request_cur(req, intr->uptodate ? 0 : -EIO))
+			cobd_transfer(req->q, req); /* next segment */
+		else
+			do_cobd_request(req->q);
 		spin_unlock(&cobd_lock);
 
 goto_next_message:
@@ -284,7 +282,7 @@
 		if (!disk->queue)
 			goto fail_malloc4;
 
-		blk_queue_hardsect_size(disk->queue, hardsect_size);
+		blk_queue_logical_block_size(disk->queue, hardsect_size);
 
 		cobd->unit = i;
 		disk->major = COLINUX_MAJOR;
@@ -314,8 +312,7 @@
 	kfree(cobd_disks);
 
 fail_malloc:
-	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
-		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+	unregister_blkdev(COLINUX_MAJOR, "cobd");
 
 fail_irq:
 	free_irq(BLOCKDEV_IRQ, NULL);
@@ -460,7 +457,7 @@
 	}
 
 	cobd = &cobd_devs[cobd_unit];
-	blk_queue_hardsect_size(disk->queue, hardsect_size);
+	blk_queue_logical_block_size(disk->queue, hardsect_size);
 	disk->major = alias->major->number;
 	disk->first_minor = alias->minor_start + index;
 	disk->fops = &cobd_fops;
@@ -514,8 +511,7 @@
 		put_disk(cobd_disks[i]);
 	}
 
-	if (unregister_blkdev(COLINUX_MAJOR, "cobd"))
-		printk(KERN_WARNING "cobd: cannot unregister blkdev\n");
+	unregister_blkdev(COLINUX_MAJOR, "cobd");
 
 	free_irq(BLOCKDEV_IRQ, NULL);
 	kfree(cobd_disks);
Keyboard driver


Index: linux-2.6.33-source/drivers/input/keyboard/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/input/keyboard/Kconfig
+++ linux-2.6.33-source/drivers/input/keyboard/Kconfig
@@ -73,7 +73,7 @@
 	default y
 	select SERIO
 	select SERIO_LIBPS2
-	select SERIO_I8042 if X86
+	select SERIO_I8042 if X86 && !COOPERATIVE
 	select SERIO_GSCPS2 if GSC
 	help
 	  Say Y here if you want to use a standard AT or PS/2 keyboard. Usually
Index: linux-2.6.33-source/drivers/input/keyboard/atkbd.c
===================================================================
--- linux-2.6.33-source.orig/drivers/input/keyboard/atkbd.c
+++ linux-2.6.33-source/drivers/input/keyboard/atkbd.c
@@ -28,6 +28,7 @@
 #include <linux/libps2.h>
 #include <linux/mutex.h>
 #include <linux/dmi.h>
+#include <linux/cooperative_internal.h>
 
 #define DRIVER_DESC	"AT and PS/2 keyboard driver"
 
@@ -680,6 +681,9 @@
 	struct ps2dev *ps2dev = &atkbd->ps2dev;
 	unsigned char param[2];
 
+	if (cooperative_mode_enabled())
+		return 0;
+
 /*
  * Some systems, where the bit-twiddling when testing the io-lines of the
  * controller may confuse the keyboard need a full reset of the keyboard. On
@@ -1129,8 +1133,8 @@
 		}
 
 		atkbd->set = atkbd_select_set(atkbd, atkbd_set, atkbd_extra);
-		atkbd_reset_state(atkbd);
-		atkbd_activate(atkbd);
+		if (!atkbd_reset_state(atkbd))
+			atkbd_activate(atkbd);
 
 	} else {
 		atkbd->set = 2;
Index: linux-2.6.33-source/drivers/input/serio/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/input/serio/Kconfig
+++ linux-2.6.33-source/drivers/input/serio/Kconfig
@@ -21,7 +21,7 @@
 config SERIO_I8042
 	tristate "i8042 PC Keyboard controller" if EMBEDDED || !X86
 	default y
-	depends on !PARISC && (!ARM || ARCH_SHARK || FOOTBRIDGE_HOST) && !M68K && !BLACKFIN
+	depends on !PARISC && (!ARM || ARCH_SHARK || FOOTBRIDGE_HOST) && !M68K && !BLACKFIN && !COOPERATIVE
 	help
 	  i8042 is the chip over which the standard AT keyboard and PS/2
 	  mouse are connected to the computer. If you use these devices,
@@ -169,6 +169,7 @@
 config SERIO_LIBPS2
 	tristate "PS/2 driver library" if EMBEDDED
 	depends on SERIO_I8042 || SERIO_I8042=n
+	depends on !COOPERATIVE
 	help
 	  Say Y here if you are using a driver for device connected
 	  to a PS/2 port, such as PS/2 mouse or standard AT keyboard.
@@ -209,4 +210,9 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called altera_ps2.
 
+config SERIO_COKBD
+ 	tristate "Cooperative Linux virtual keyboard controller driver"
+ 	depends on COOPERATIVE
+ 	default y
+
 endif
Index: linux-2.6.33-source/drivers/input/serio/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/input/serio/Makefile
+++ linux-2.6.33-source/drivers/input/serio/Makefile
@@ -23,3 +23,4 @@
 obj-$(CONFIG_SERIO_RAW)		+= serio_raw.o
 obj-$(CONFIG_SERIO_XILINX_XPS_PS2)	+= xilinx_ps2.o
 obj-$(CONFIG_SERIO_ALTERA_PS2)	+= altera_ps2.o
+obj-$(CONFIG_SERIO_COKBD)	+= cokbd.o
Index: linux-2.6.33-source/drivers/char/keyboard.c
===================================================================
--- linux-2.6.33-source.orig/drivers/char/keyboard.c
+++ linux-2.6.33-source/drivers/char/keyboard.c
@@ -379,6 +379,14 @@
 	}
 }
 
+#ifdef CONFIG_COOPERATIVE
+void keyboard_inject_utf8(uint c)
+{
+	to_utf8(vc_cons[fg_console].d, c);
+}
+EXPORT_SYMBOL_GPL(keyboard_inject_utf8);
+#endif
+
 /*
  * Called after returning from RAW mode or when changing consoles - recompute
  * shift_down[] and shift_state from key_down[] maybe called when keymap is
Index: linux-2.6.33-source/include/linux/kbd_kern.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/kbd_kern.h
+++ linux-2.6.33-source/include/linux/kbd_kern.h
@@ -1,3 +1,4 @@
+
 #ifndef _KBD_KERN_H
 #define _KBD_KERN_H
 
@@ -66,6 +67,7 @@
 
 extern struct kbd_struct kbd_table[];
 
+extern void keyboard_inject_utf8(uint c);
 extern int kbd_init(void);
 
 extern unsigned char getledstate(void);
Mouse driver


Index: linux-2.6.33-source/drivers/input/mouse/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/input/mouse/Kconfig
+++ linux-2.6.33-source/drivers/input/mouse/Kconfig
@@ -12,9 +12,19 @@
 
 if INPUT_MOUSE
 
+config MOUSE_COOPERATIVE
+	bool "Cooperative Mouse driver"
+       	default n
+        depends on COOPERATIVE
+        ---help---
+          Virtual mouse driver for cooperative kernels.
+
+          If unsure, say N
+
 config MOUSE_PS2
 	tristate "PS/2 mouse"
 	default y
+	depends on !COOPERATIVE
 	select SERIO
 	select SERIO_LIBPS2
 	select SERIO_I8042 if X86
@@ -137,6 +147,7 @@
 
 config MOUSE_SERIAL
 	tristate "Serial mouse"
+	depends on !COOPERATIVE
 	select SERIO
 	help
 	  Say Y here if you have a serial (RS-232, COM port) mouse connected
@@ -261,6 +272,7 @@
 
 config MOUSE_VSXXXAA
 	tristate "DEC VSXXX-AA/GA mouse and VSXXX-AB tablet"
+	depends on !COOPERATIVE
 	select SERIO
 	help
 	  Say Y (or M) if you want to use a DEC VSXXX-AA (hockey
Index: linux-2.6.33-source/drivers/input/mouse/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/input/mouse/Makefile
+++ linux-2.6.33-source/drivers/input/mouse/Makefile
@@ -14,6 +14,7 @@
 obj-$(CONFIG_MOUSE_MAPLE)		+= maplemouse.o
 obj-$(CONFIG_MOUSE_PC110PAD)		+= pc110pad.o
 obj-$(CONFIG_MOUSE_PS2)			+= psmouse.o
+obj-$(CONFIG_MOUSE_COOPERATIVE)		+= comouse.o
 obj-$(CONFIG_MOUSE_PXA930_TRKBALL)	+= pxa930_trkball.o
 obj-$(CONFIG_MOUSE_RISCPC)		+= rpcmouse.o
 obj-$(CONFIG_MOUSE_SERIAL)		+= sermouse.o
Implements host filesystem support


Index: linux-2.6.33-source/fs/cofusefs/Kconfig
===================================================================
--- /dev/null
+++ linux-2.6.33-source/fs/cofusefs/Kconfig
@@ -0,0 +1,13 @@
+config COFUSE_FS
+	tristate "Cooperative Host file system support (COFUSE)"
+	depends on COOPERATIVE
+	default y
+	help
+	  In Cooperative mode, this file system allows you to mount an host
+	  directory structure to a local mountpoint.
+	  COFUSE (Cooperative FUSE) is based on the original FUSE
+	  (File System in User Space).
+
+	  To compile the cofuse support as a module, choose M here: the
+	  module will be called cofusefs.
+
Index: linux-2.6.33-source/fs/Kconfig
===================================================================
--- linux-2.6.33-source.orig/fs/Kconfig
+++ linux-2.6.33-source/fs/Kconfig
@@ -62,6 +62,7 @@
 source "fs/autofs/Kconfig"
 source "fs/autofs4/Kconfig"
 source "fs/fuse/Kconfig"
+source "fs/cofusefs/Kconfig"
 
 config CUSE
 	tristate "Character device in Userpace support"
Index: linux-2.6.33-source/fs/Makefile
===================================================================
--- linux-2.6.33-source.orig/fs/Makefile
+++ linux-2.6.33-source/fs/Makefile
@@ -108,6 +108,7 @@
 obj-$(CONFIG_AUTOFS4_FS)	+= autofs4/
 obj-$(CONFIG_ADFS_FS)		+= adfs/
 obj-$(CONFIG_FUSE_FS)		+= fuse/
+obj-$(CONFIG_COFUSE_FS)		+= cofusefs/
 obj-$(CONFIG_UDF_FS)		+= udf/
 obj-$(CONFIG_SUN_OPENPROMFS)	+= openpromfs/
 obj-$(CONFIG_OMFS_FS)		+= omfs/
Index: linux-2.6.33-source/fs/cofusefs/Makefile
===================================================================
--- /dev/null
+++ linux-2.6.33-source/fs/cofusefs/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the Linux cofuse filesystem routines.
+#
+
+obj-$(CONFIG_COFUSE_FS) += cofusefs.o
+
+cofusefs-objs := inode.o dir.o file.o util.o dev.o
+
Index: linux-2.6.33-source/fs/cofusefs/dir.c
===================================================================
--- linux-2.6.33-source.orig/fs/cofusefs/dir.c
+++ linux-2.6.33-source/fs/cofusefs/dir.c
@@ -28,7 +28,7 @@
 static void change_attributes(struct inode *inode, struct fuse_attr *attr)
 {
 	if(S_ISREG(inode->i_mode) && i_size_read(inode) != attr->size)
-		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+		invalidate_inode_pages2(inode->i_mapping);
 
 	inode->i_mode    = (inode->i_mode & S_IFMT) + (attr->mode & 07777);
 	inode->i_nlink   = attr->nlink;
@@ -388,7 +388,7 @@
 
 	if(inode->i_ino == FUSE_ROOT_INO) {
 		if(!(fc->flags & FUSE_ALLOW_OTHER) &&
-		   current->fsuid != fc->uid)
+		   current_fsuid() != fc->uid)
 			return -EACCES;
 	} else if(!(fc->flags & COFS_MOUNT_NOCACHE) &&
 		  time_before_eq(jiffies, entry->d_time + FUSE_REVALIDATE_TIME))
@@ -397,11 +397,11 @@
 	return fuse_do_getattr(inode);
 }
 
-static int _fuse_permission(struct inode *inode, int mask)
+static int fuse_permission(struct inode *inode, int mask)
 {
 	struct fuse_conn *fc = INO_FC(inode);
 
-	if(!(fc->flags & FUSE_ALLOW_OTHER) && current->fsuid != fc->uid)
+	if(!(fc->flags & FUSE_ALLOW_OTHER) && current_fsuid() != fc->uid)
 		return -EACCES;
 	else if(fc->flags & FUSE_DEFAULT_PERMISSIONS) {
 		int err = generic_permission(inode, mask, NULL);
@@ -758,12 +758,6 @@
 	return _fuse_create(dir, entry, mode);
 }
 
-static int fuse_permission(struct inode *inode, int mask,
-			    struct nameidata *nd)
-{
-	return _fuse_permission(inode, mask);
-}
-
 static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
 {
 	return _fuse_dentry_revalidate(entry);
Index: linux-2.6.33-source/fs/cofusefs/file.c
===================================================================
--- linux-2.6.33-source.orig/fs/cofusefs/file.c
+++ linux-2.6.33-source/fs/cofusefs/file.c
@@ -42,7 +42,7 @@
 	in.args[0].value = &inarg;
 	request_send(fc, &in, &out);
 	if(!out.h.error && !(fc->flags & FUSE_KERNEL_CACHE)) {
-		invalidate_mapping_pages(inode->i_mapping, 0, -1);
+		invalidate_inode_pages2(inode->i_mapping);
 	}
 
 	return out.h.error;
@@ -385,28 +385,54 @@
 	return err;
 }
 
-static int fuse_prepare_write(struct file *file, struct page *page,
-			      unsigned offset, unsigned to)
+static int fuse_write_begin(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned flags,
+			struct page **pagep, void **fsdata)
 {
-	/* No op */
+	pgoff_t index = pos >> PAGE_CACHE_SHIFT;
+
+	*pagep = grab_cache_page_write_begin(mapping, index, flags);
+	if (!*pagep)
+		return -ENOMEM;
 	return 0;
 }
 
-static int fuse_commit_write(struct file *file, struct page *page,
-			     unsigned offset, unsigned to)
+static int fuse_buffered_write(struct file *file, struct inode *inode,
+			       loff_t pos, unsigned count, struct page *page)
 {
 	int err;
-	struct inode *inode = page->mapping->host;
+	unsigned offset = pos & (PAGE_CACHE_SIZE - 1);
+
+	if (is_bad_inode(inode))
+		return -EIO;
 
-	err = write_buffer(inode, page, offset, to - offset);
-	if(!err) {
-		loff_t pos = (page->index << PAGE_CACHE_SHIFT) + to;
+	err = write_buffer(inode, page, offset, count);
+	if (!err) {
+		pos += count;
 		if(pos > i_size_read(inode))
 			i_size_write(inode, pos);
+		if (count == PAGE_CACHE_SIZE)
+			SetPageUptodate(page);
 	}
-	return err;
+	return err ? err : count;
+}
+
+static int fuse_write_end(struct file *file, struct address_space *mapping,
+			loff_t pos, unsigned len, unsigned copied,
+			struct page *page, void *fsdata)
+{
+	struct inode *inode = mapping->host;
+	int res = 0;
+
+	if (copied)
+		res = fuse_buffered_write(file, inode, pos, copied, page);
+
+	unlock_page(page);
+	page_cache_release(page);
+	return res;
 }
 
+
 static struct file_operations fuse_file_operations = {
 	.llseek		= generic_file_llseek,
 	.read		= fuse_file_read,
@@ -421,10 +447,10 @@
 };
 
 static struct address_space_operations fuse_file_aops  = {
-	.readpage =		fuse_readpage,
-	.writepage =		fuse_writepage,
-	.prepare_write =	fuse_prepare_write,
-	.commit_write =		fuse_commit_write,
+	.readpage	= fuse_readpage,
+	.writepage	= fuse_writepage,
+	.write_begin	= fuse_write_begin,
+	.write_end	= fuse_write_end,
 };
 
 void fuse_init_file_inode(struct inode *inode)
Index: linux-2.6.33-source/fs/cofusefs/fuse_i.h
===================================================================
--- linux-2.6.33-source.orig/fs/cofusefs/fuse_i.h
+++ linux-2.6.33-source/fs/cofusefs/fuse_i.h
@@ -85,7 +85,7 @@
 	struct fuse_out_arg args[3];
 };
 
-#define FUSE_IN_INIT { {0, 0, 0, current->fsuid, current->fsgid}, 0}
+#define FUSE_IN_INIT { {0, 0, 0, current_fsuid(), current_fsgid()}, 0}
 #define FUSE_OUT_INIT { {0, 0}, 0, 0}
 
 struct fuse_req;
Index: linux-2.6.33-source/fs/cofusefs/inode.c
===================================================================
--- linux-2.6.33-source.orig/fs/cofusefs/inode.c
+++ linux-2.6.33-source/fs/cofusefs/inode.c
@@ -355,8 +355,8 @@
 	struct fuse_mount_data md = {0, };
 	int ret;
 
-	co_md.uid = current->uid;
-	co_md.gid = current->gid;
+	co_md.uid = current_uid();
+	co_md.gid = current_gid();
 	co_md.dir_mode = FUSE_S_IRWXU | FUSE_S_IRGRP | FUSE_S_IXGRP |
 		FUSE_S_IROTH | FUSE_S_IXOTH | S_IFDIR;
 	co_md.file_mode = FUSE_S_IRWXU | FUSE_S_IRGRP | FUSE_S_IXGRP |
Index: linux-2.6.33-source/drivers/block/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/block/Kconfig
+++ linux-2.6.33-source/drivers/block/Kconfig
@@ -271,6 +271,12 @@
 	  instead, which can be configured to be on-disk compatible with the
 	  cryptoloop device.
 
+config BLK_DEV_CLOOP
+	tristate "Compressed Loopback device support (from Knoppix)"
+	default m
+	help
+	  Adds an compressed loopback device.
+
 source "drivers/block/drbd/Kconfig"
 
 config BLK_DEV_NBD
Index: linux-2.6.33-source/drivers/block/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/block/Makefile
+++ linux-2.6.33-source/drivers/block/Makefile
@@ -15,6 +15,8 @@
 obj-$(CONFIG_AMIGA_Z2RAM)	+= z2ram.o
 obj-$(CONFIG_BLK_DEV_RAM)	+= brd.o
 obj-$(CONFIG_BLK_DEV_COBD)	+= cobd.o
+obj-$(CONFIG_BLK_DEV_CLOOP)	+= cloop.o
+cloop-objs := compressed_loop.o
 obj-$(CONFIG_BLK_DEV_LOOP)	+= loop.o
 obj-$(CONFIG_BLK_DEV_XD)	+= xd.o
 obj-$(CONFIG_BLK_CPQ_DA)	+= cpqarray.o
Index: linux-2.6.33-source/arch/x86/Kconfig
===================================================================
--- linux-2.6.33-source.orig/arch/x86/Kconfig
+++ linux-2.6.33-source/arch/x86/Kconfig
@@ -1893,6 +1893,9 @@
 	  direct access method and falls back to the BIOS if that doesn't
 	  work. If unsure, go with the default, which is "Any".
 
+config PCI_GOCO
+	bool "Cooperative"
+
 config PCI_GOBIOS
 	bool "BIOS"
 
@@ -1911,6 +1914,11 @@
 
 endchoice
 
+config PCI_COOPERATIVE
+	bool
+ 	depends on PCI && PCI_GOCO && COOPERATIVE
+	default y
+
 config PCI_BIOS
 	def_bool y
 	depends on X86_32 && PCI && (PCI_GOBIOS || PCI_GOANY)
@@ -1992,6 +2000,7 @@
 
 # x86_64 have no ISA slots, but do have ISA-style DMA.
 config ISA_DMA_API
+	depends on !COOPERATIVE
 	def_bool y
 
 if X86_32
Index: linux-2.6.33-source/arch/x86/kernel/cpu/cyrix.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/kernel/cpu/cyrix.c
+++ linux-2.6.33-source/arch/x86/kernel/cpu/cyrix.c
@@ -254,6 +254,7 @@
 
 	case 4: /* MediaGX/GXm or Geode GXM/GXLV/GX1 */
 #ifdef CONFIG_PCI
+#ifndef CONFIG_COOPERATIVE
 	{
 		u32 vendor, device;
 		/*
@@ -287,6 +288,7 @@
 			mark_tsc_unstable("cyrix 5510/5520 detected");
 	}
 #endif
+#endif
 		c->x86_cache_size = 16;	/* Yep 16K integrated cache thats it */
 
 		/* GXm supports extended cpuid levels 'ala' AMD */
Index: linux-2.6.33-source/arch/x86/pci/init.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/init.c
+++ linux-2.6.33-source/arch/x86/pci/init.c
@@ -11,6 +11,9 @@
 
 	type = pci_direct_probe();
 #endif
+#ifdef CONFIG_PCI_COOPERATIVE
+	pci_cooperative_init();
+#endif
 
 	if (!(pci_probe & PCI_PROBE_NOEARLY))
 		pci_mmcfg_early_init();
Index: linux-2.6.33-source/arch/x86/include/asm/pci_x86.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pci_x86.h
+++ linux-2.6.33-source/arch/x86/include/asm/pci_x86.h
@@ -103,6 +103,7 @@
 
 /* arch_initcall level */
 extern int pci_direct_probe(void);
+extern void pci_cooperative_init(void);
 extern void pci_direct_init(int type);
 extern void pci_pcbios_init(void);
 extern int pci_olpc_init(void);
Index: linux-2.6.33-source/arch/x86/pci/Makefile
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/Makefile
+++ linux-2.6.33-source/arch/x86/pci/Makefile
@@ -1,5 +1,6 @@
 obj-y				:= i386.o init.o
 
+obj-$(CONFIG_PCI_COOPERATIVE)	+= copci.o irq_cooperative.o
 obj-$(CONFIG_PCI_BIOS)		+= pcbios.o
 obj-$(CONFIG_PCI_MMCONFIG)	+= mmconfig_$(BITS).o direct.o mmconfig-shared.o
 obj-$(CONFIG_PCI_DIRECT)	+= direct.o
@@ -7,13 +8,19 @@
 
 obj-y				+= fixup.o
 obj-$(CONFIG_ACPI)		+= acpi.o
-obj-y				+= legacy.o irq.o
+obj-y				+= legacy.o
+ifndef CONFIG_COOPERATIVE
+obj-y				+= irq.o
+endif
 
 obj-$(CONFIG_X86_VISWS)		+= visws.o
 
 obj-$(CONFIG_X86_NUMAQ)		+= numaq_32.o
 
-obj-y				+= common.o early.o
+obj-y				+= common.o
+ifndef CONFIG_COOPERATIVE
+obj-y				+= early.o
+endif
 obj-y				+= amd_bus.o
 obj-$(CONFIG_X86_64)		+= bus_numa.o
 
Index: linux-2.6.33-source/drivers/pci/pci.c
===================================================================
--- linux-2.6.33-source.orig/drivers/pci/pci.c
+++ linux-2.6.33-source/drivers/pci/pci.c
@@ -2111,6 +2111,7 @@
 }
 
 #ifndef HAVE_ARCH_PCI_SET_DMA_MASK
+#error BUG1 HAVE_ARCH_PCI_SET_DMA_MASK
 /*
  * These can be overridden by arch-specific implementations
  */
@@ -2876,9 +2877,13 @@
 EXPORT_SYMBOL(pci_try_set_mwi);
 EXPORT_SYMBOL(pci_clear_mwi);
 EXPORT_SYMBOL_GPL(pci_intx);
+#ifndef HAVE_ARCH_PCI_SET_DMA_MASK
 EXPORT_SYMBOL(pci_set_dma_mask);
 EXPORT_SYMBOL(pci_set_consistent_dma_mask);
+#endif
+#ifndef CONFIG_COOPERATIVE
 EXPORT_SYMBOL(pci_assign_resource);
+#endif
 EXPORT_SYMBOL(pci_find_parent_resource);
 EXPORT_SYMBOL(pci_select_bars);
 
Index: linux-2.6.33-source/arch/x86/include/asm/pci.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/pci.h
+++ linux-2.6.33-source/arch/x86/include/asm/pci.h
@@ -70,7 +70,7 @@
 			       int write_combine);
 
 
-#ifdef CONFIG_PCI
+#if defined(CONFIG_PCI) && !defined(CONFIG_COOPERATIVE)
 extern void early_quirks(void);
 static inline void pci_dma_burst_advice(struct pci_dev *pdev,
 					enum pci_dma_burst_strategy *strat,
@@ -83,12 +83,18 @@
 static inline void early_quirks(void) { }
 #endif
 
+#ifndef CONFIG_COOPERATIVE
 extern void pci_iommu_alloc(void);
+#endif
 
 /* MSI arch hook */
 #define arch_setup_msi_irqs arch_setup_msi_irqs
 
+#ifdef CONFIG_COOPERATIVE
+#define PCI_DMA_BUS_IS_PHYS 0
+#else
 #define PCI_DMA_BUS_IS_PHYS (dma_ops->is_phys)
+#endif
 
 #if defined(CONFIG_X86_64) || defined(CONFIG_DMAR) || defined(CONFIG_DMA_API_DEBUG)
 
Index: linux-2.6.33-source/arch/x86/pci/i386.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/i386.c
+++ linux-2.6.33-source/arch/x86/pci/i386.c
@@ -242,7 +242,9 @@
 	pcibios_allocate_resources(0);
 	pcibios_allocate_resources(1);
 
+#ifndef CONFIG_COOPERATIVE
 	e820_reserve_resources_late();
+#endif
 	/*
 	 * Insert the IO APIC resources after PCI initialization has
 	 * occured to handle IO APICS that are mapped in on a BAR in
Index: linux-2.6.33-source/arch/x86/pci/legacy.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/legacy.c
+++ linux-2.6.33-source/arch/x86/pci/legacy.c
@@ -66,7 +66,9 @@
 #endif
 	pci_legacy_init();
 	pcibios_fixup_peer_bridges();
+#ifndef CONFIG_COOPERATIVE
 	pcibios_irq_init();
+#endif
 	pcibios_init();
 
 	return 0;
Index: linux-2.6.33-source/drivers/usb/host/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/usb/host/Makefile
+++ linux-2.6.33-source/drivers/usb/host/Makefile
@@ -16,7 +16,9 @@
 
 obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
 
+ifndef CONFIG_COOPERATIVE
 obj-$(CONFIG_PCI)		+= pci-quirks.o
+endif
 
 obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
 obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
Index: linux-2.6.33-source/arch/x86/pci/irq_cooperative.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/irq_cooperative.c
+++ linux-2.6.33-source/arch/x86/pci/irq_cooperative.c
@@ -7,7 +7,7 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/pci.h>
-#include "pci.h"
+#include <asm/pci_x86.h>
 
 /*
  * Never use: 0, 1, 2 (timer, keyboard, and cascade)
Index: linux-2.6.33-source/arch/x86/pci/copci.c
===================================================================
--- linux-2.6.33-source.orig/arch/x86/pci/copci.c
+++ linux-2.6.33-source/arch/x86/pci/copci.c
@@ -4,13 +4,14 @@
  *  Cooperative Linux PCI Driver implementation
  */
 
+
 #include <linux/kernel.h>
 #include <linux/pci.h>
 #include <linux/pci_regs.h>
 #include <linux/interrupt.h>
 #include <linux/cooperative_pci.h>
 #include <linux/cooperative_internal.h>
-#include "pci.h"
+#include <asm/pci_x86.h>
 
 #include <linux/copci.h>
 
@@ -304,3 +305,15 @@
 
 	raw_pci_ops = &copci_ops;
 }
+
+int pci_set_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	return -EIO;
+}
+EXPORT_SYMBOL(pci_set_dma_mask);
+
+int pci_set_consistent_dma_mask(struct pci_dev *dev, u64 mask)
+{
+	return -EIO;
+}
+EXPORT_SYMBOL(pci_set_consistent_dma_mask);
Index: linux-2.6.33-source/arch/x86/include/asm/dma.h
===================================================================
--- linux-2.6.33-source.orig/arch/x86/include/asm/dma.h
+++ linux-2.6.33-source/arch/x86/include/asm/dma.h
@@ -12,6 +12,11 @@
 #include <asm/io.h>		/* need byte IO */
 #include <linux/delay.h>
 
+/* coLinux have a dummy implementation of pci_set_dma_mask() */
+#ifdef CONFIG_COOPERATIVE
+# define HAVE_ARCH_PCI_SET_DMA_MASK
+#endif
+
 #ifdef HAVE_REALLY_SLOW_DMA_CONTROLLER
 #define dma_outb	outb_p
 #else
Index: linux-2.6.33-source/drivers/scsi/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/scsi/Kconfig
+++ linux-2.6.33-source/drivers/scsi/Kconfig
@@ -262,6 +262,7 @@
 	default m
 	depends on SCSI
 	depends on MODULES
+	depends on !COOPERATIVE
 # scsi_wait_scan is a loadable module which waits until all the async scans are
 # complete.  The idea is to use it in initrd/ initramfs scripts.  You modprobe
 # it after all the modprobes of the root SCSI drivers and it will wait until
@@ -340,6 +341,12 @@
 
 if SCSI_LOWLEVEL && SCSI
 
+config SCSI_COOPERATIVE
+	bool "Cooperative Linux support"
+	depends on COOPERATIVE
+	help
+	  SCSI Driver for Cooperative Linux
+
 config ISCSI_TCP
 	tristate "iSCSI Initiator over TCP/IP"
 	depends on SCSI && INET
Index: linux-2.6.33-source/drivers/scsi/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/scsi/Makefile
+++ linux-2.6.33-source/drivers/scsi/Makefile
@@ -58,6 +58,7 @@
 obj-$(CONFIG_SCSI_SIM710)	+= 53c700.o	sim710.o
 obj-$(CONFIG_SCSI_ADVANSYS)	+= advansys.o
 obj-$(CONFIG_SCSI_BUSLOGIC)	+= BusLogic.o
+obj-$(CONFIG_SCSI_COOPERATIVE)	+= coscsi.o
 obj-$(CONFIG_SCSI_DPT_I2O)	+= dpt_i2o.o
 obj-$(CONFIG_SCSI_U14_34F)	+= u14-34f.o
 obj-$(CONFIG_SCSI_ARCMSR)	+= arcmsr/
Index: linux-2.6.33-source/include/linux/blkdev.h
===================================================================
--- linux-2.6.33-source.orig/include/linux/blkdev.h
+++ linux-2.6.33-source/include/linux/blkdev.h
@@ -1011,7 +1011,11 @@
 
 extern int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm);
 
+#ifdef CONFIG_COOPERATIVE
+#define MAX_PHYS_SEGMENTS 256
+#else
 #define MAX_PHYS_SEGMENTS 128
+#endif
 #define MAX_HW_SEGMENTS 128
 #define SAFE_MAX_SECTORS 255
 #define BLK_DEF_MAX_SECTORS 1024
Index: linux-2.6.33-source/drivers/scsi/coscsi.c
===================================================================
--- linux-2.6.33-source.orig/drivers/scsi/coscsi.c
+++ linux-2.6.33-source/drivers/scsi/coscsi.c
@@ -9,10 +9,6 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 
-#include <asm/system.h>
-#include <asm/dma-mapping.h>
-#include <asm/string.h>
-
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
@@ -28,7 +24,7 @@
 /* Special pass through type */
 #define TYPE_PASS 0x1f
 
-#define COSCSI_VERSION "1.01"
+#define COSCSI_VERSION "1.02"
 
 MODULE_AUTHOR("Steve Shoecraft <sshoecraft@earthlink.net>");
 MODULE_DESCRIPTION("Cooperative Linux SCSI Driver " COSCSI_VERSION);
@@ -244,6 +240,38 @@
 static unsigned int max_xfer = 4096;
 #endif
 
+static inline int coscsi_map_sg(struct scatterlist *sgl, int sg_count)
+{
+	unsigned char *virt;
+	size_t sg_len = 0;
+	struct scatterlist *sg;
+	int i;
+
+	// Set dma_address for old host driver
+	for_each_sg(sgl, sg, sg_count, i) {
+		virt = kmap_atomic(sg_page(sg), KM_SOFTIRQ0);
+		sg->dma_address = __pa(virt) + sg->offset;
+		sg_len += sg->length;
+#if COSCSI_DEBUG_HOST
+		printk(KERN_INFO "coscsi_map_sg: sg:%p virt:%p sg->len:%d i:%d sg_count:%d sg->offset:%zx\n",
+			                            sg,     virt,     sg->length, i, sg_count, sg->offset);
+#endif
+		BUG_ON(!virt);
+	}
+
+	return i;
+}
+
+static inline void coscsi_unmap_sg(struct scatterlist *sgl, int sg_count)
+{
+	struct scatterlist *sg;
+	int i;
+
+	for_each_sg(sgl, sg, sg_count, i) {
+		scsi_kunmap_atomic_sg(__va(sgl->dma_address - sg->offset));
+	}
+}
+
 /*
  * Read/Write block(s)
 */
@@ -257,7 +285,8 @@
 	int count,rc,total;
 
 #if COSCSI_DEBUG_HOST
-	if (wp->dp->debug) printk(KERN_INFO "host_rw: lba: %lld, sector_size: %d, num: %ld, write: %d\n",
+	if (wp->dp->debug) printk(KERN_INFO "host_rw: sg:%p count:%d lba: %lld, sector_size: %d, num: %ld, write: %d\n",
+		sg, scsi_sg_count(scp),
 		lba, scp->device->sector_size, num, write);
 #endif
 
@@ -267,11 +296,13 @@
 	}
 
 	/* XXX needed when clustering is enabled */
-	count = dma_map_sg(&scp->device->host->shost_gendev, sg, scsi_sg_count(scp), scp->sc_data_direction);
+	local_irq_save(flags);
+	count = coscsi_map_sg(sg, scsi_sg_count(scp));
+	BUG_ON(!count);
 
 	/* Get passage page */
 	co_passage_page_assert_valid();
-	co_passage_page_acquire(&flags);
+	co_passage_page_ref_up(); /* aka co_passage_page_acquire */
 	co_passage_page->operation = CO_OPERATION_DEVICE;
 	co_passage_page->params[0] = CO_DEVICE_SCSI;
 	co_passage_page->params[1] = CO_SCSI_IO;
@@ -290,9 +321,10 @@
 	co_switch_wrapper();
 
 	rc = co_passage_page->params[0];
-	co_passage_page_release(flags);
+	co_passage_page_ref_down(); /* aka co_passage_page_release */
 
-	dma_unmap_sg(&scp->device->host->shost_gendev, sg, scsi_sg_count(scp), scp->sc_data_direction);
+	coscsi_unmap_sg(sg, scsi_sg_count(scp));
+	local_irq_restore(flags);
 
 #if COSCSI_DUMP_STATS
 	if (rc == GOOD) {
@@ -952,7 +984,7 @@
 	case TYPE_ROM:
 	case TYPE_WORM:
 		/* XXX required to get rid of "unaligned transfer" errors */
-		blk_queue_hardsect_size(sdev->request_queue, 2048);
+	        blk_queue_logical_block_size(sdev->request_queue, 2048);
 		break;
 	default:
 		break;
Index: linux-2.6.33-source/sound/pci/Kconfig
===================================================================
--- linux-2.6.33-source.orig/sound/pci/Kconfig
+++ linux-2.6.33-source/sound/pci/Kconfig
@@ -9,6 +9,14 @@
 
 if SND_PCI
 
+config COOPERATIVE_AUDIO
+	bool "Cooperative audio support"
+	default n
+	depends on COOPERATIVE
+	select SND_PCM
+	help
+	   Say Y here if you are compiling in Cooperative mode
+
 config SND_AD1889
 	tristate "Analog Devices AD1889"
 	select SND_AC97_CODEC
Index: linux-2.6.33-source/sound/pci/Makefile
===================================================================
--- linux-2.6.33-source.orig/sound/pci/Makefile
+++ linux-2.6.33-source/sound/pci/Makefile
@@ -28,6 +28,8 @@
 snd-via82xx-objs := via82xx.o
 snd-via82xx-modem-objs := via82xx_modem.o
 
+obj-$(CONFIG_COOPERATIVE_AUDIO) += coaudio.o
+
 # Toplevel Module Dependency
 obj-$(CONFIG_SND_AD1889) += snd-ad1889.o
 obj-$(CONFIG_SND_ALS300) += snd-als300.o
Index: linux-2.6.33-source/drivers/video/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/video/Kconfig
+++ linux-2.6.33-source/drivers/video/Kconfig
@@ -242,6 +242,23 @@
 comment "Frame buffer hardware drivers"
 	depends on FB
 
+config COOPERATIVE_VIDEO
+	bool "Cooperative Video"
+	default n
+	depends on COOPERATIVE
+	select FB
+        select FB_SYS_FILLRECT
+        select FB_SYS_COPYAREA
+        select FB_SYS_IMAGEBLIT
+        select FB_SYS_FOPS
+	select FRAMEBUFFER_CONSOLE if !COOPERATIVE_CONSOLE
+	select LOGO if !COOPERATIVE_CONSOLE
+	select LOGO_LINUX_CLUT224 if !COOPERATIVE_CONSOLE
+	---help---
+	  This enables the Cooperative Framebuffer Video driver.
+
+	  Say N unless you are compiling a Cooperative kernel.
+
 config FB_CIRRUS
 	tristate "Cirrus Logic support"
 	depends on FB && (ZORRO || PCI)
Index: linux-2.6.33-source/drivers/video/Makefile
===================================================================
--- linux-2.6.33-source.orig/drivers/video/Makefile
+++ linux-2.6.33-source/drivers/video/Makefile
@@ -27,6 +27,8 @@
 obj-$(CONFIG_FB_DDC)           += fb_ddc.o
 obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
 
+obj-$(CONFIG_COOPERATIVE_VIDEO)	  += covideo.o
+
 # Hardware specific drivers go first
 obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
 obj-$(CONFIG_FB_ARC)              += arcfb.o
Index: linux-2.6.33-source/drivers/gpu/vga/Kconfig
===================================================================
--- linux-2.6.33-source.orig/drivers/gpu/vga/Kconfig
+++ linux-2.6.33-source/drivers/gpu/vga/Kconfig
@@ -1,7 +1,7 @@
 config VGA_ARB
 	bool "VGA Arbitration" if EMBEDDED
 	default y
-	depends on PCI
+	depends on PCI && !COOPERATIVE
 	help
 	  Some "legacy" VGA devices implemented on PCI typically have the same
 	  hard-decoded addresses as they did on ISA. When multiple PCI devices
